{"title":"【实例1の更新2】表达式求值——加入括号运算","uid":"fe68a41eeb4610b86a3bfb5b3b4407ee","slug":"example-optimization-2","date":"2022-05-24T11:20:52.000Z","updated":"2022-06-19T13:58:03.129Z","comments":true,"path":"api/articles/example-optimization-2.json","keywords":null,"cover":[],"content":"<p>前段时间我们制作了一个表达式求值的程序，</p>\n<p>我们赋予他基本框架与功能：<a href=\"https://kcsj.i-nmb.cn/example.html\">【实例】表达式求值——利用stack实现五种运算符的运算 | 《课程设计》笔记 (i-nmb.cn)</a></p>\n<p>以及更新了一目运算符的支持：<a href=\"https://kcsj.i-nmb.cn/example-optimization-1.html\">【实例更新】表达式求值——加入新的单目运算符 | 《课程设计》笔记 (i-nmb.cn)</a></p>\n<h2 id=\"问题引入\"><a href=\"#问题引入\" class=\"headerlink\" title=\"问题引入\"></a>问题引入</h2><p>我们在经过这两个步骤之后，我们可以基本实现 表达式的求值操作 ，但是<code>L 2 8 =</code>没有括号就显得十分奇怪，并且我们在输入其他字符时报错方法还可以加以优化，让程序能够定位错误。</p>\n<p>所以目前我们需要解决的问题有两种，即：</p>\n<h5 id=\"1-加入括号进行运算\"><a href=\"#1-加入括号进行运算\" class=\"headerlink\" title=\"1.加入括号进行运算\"></a>1.加入括号进行运算</h5><h5 id=\"2-优化报错方法\"><a href=\"#2-优化报错方法\" class=\"headerlink\" title=\"2.优化报错方法\"></a>2.优化报错方法</h5><h2 id=\"一、加入括号\"><a href=\"#一、加入括号\" class=\"headerlink\" title=\"一、加入括号\"></a>一、加入括号</h2><p>首先我们要进行加入括号的运算方法</p>\n<h3 id=\"问题思考\"><a href=\"#问题思考\" class=\"headerlink\" title=\"问题思考\"></a>问题思考</h3><p>1.在前面的单目运算符以及双目运算符中，我们需要进行数的运算，那么加入括号，操作数又有什么变化？</p>\n<p>2.括号的特点是什么？他的左右运算符有没有什么特点？</p>\n<p>3.插入括号后，具体的算法（或者说 运算流程 ）是怎么样子的？</p>\n<p>4.如何“优雅地”添加括号并且不让程序做很大改动？</p>\n<p>这些问题我们需要思考与解决，以下为思考解决的部分过程</p>\n<h4 id=\"加入括号，操作数又有什么变化？\"><a href=\"#加入括号，操作数又有什么变化？\" class=\"headerlink\" title=\"加入括号，操作数又有什么变化？\"></a>加入括号，操作数又有什么变化？</h4><p>无论是单目运算符或者是双目运算符，其本质为运算符，是处理数的一种符号，只是运算过程中在处理 操作数的数目 的多少而划分。</p>\n<p>但是<strong>括号不是数学中的运算符号</strong>，他并没有处理操作数，没有改变操作数的数目和数值，他只是单纯的改变运算符之间的优先级、只是运算顺序的辅助符号。添加括号时 在栈顶的操作数 就在栈顶，没有任何变化。</p>\n<h4 id=\"括号的特点是什么？\"><a href=\"#括号的特点是什么？\" class=\"headerlink\" title=\"括号的特点是什么？\"></a>括号的特点是什么？</h4><p>1.因为<strong>括号不是数学中的运算符号</strong>，括号最直接的特点就是，加入左括号时，不改变在左括号<code>（</code>之前的其他符号的运算顺序，并且在右括号<code>）</code>之前，都正常运算（即括号内的正常运算），左括号需要等待右括号才进行出栈</p>\n<p>2.由1可以推断，无论左括号前面是什么，直接进栈；左括号后面的符号只要不是右括号，左括号始终不出栈，右括号始终不进栈。</p>\n<h4 id=\"具体的算法（或者说-运算流程-）\"><a href=\"#具体的算法（或者说-运算流程-）\" class=\"headerlink\" title=\"具体的算法（或者说 运算流程 ）\"></a>具体的算法（或者说 运算流程 ）</h4><p>比如<code>3*(2+4)=</code></p>\n<p>首先等号入栈[<code>history.top()</code>]</p>\n<p>第一步，<code>3</code>入栈 <code>operands</code></p>\n<p>第二步， * 与<code>history.top()</code>（&#x3D;）优先级比较， * 入栈。</p>\n<p>第三步，由上述问题，无论左括号前面是什么，直接进栈，所以<code>(</code>入栈</p>\n<p>第四步，<code>2</code>入栈</p>\n<p>第五步，左括号与+进行优先级比较，由上述括号的特点可知：左括号后面的符号只要不是右括号，左括号始终不出栈，所以开始计算</p>\n<p>第六步，输入4入栈，两次取出栈顶的元素（4和2）并进行＋运算，得数为6，压入 <code>operands</code>栈顶，弹出 + 号</p>\n<p>第七步，输入右括号，与栈顶<code>history.top()</code>的左括号匹配，所以弹出左括号，并且右括号始终不进栈。</p>\n<p>第八步，输入等号，等号优先级最小，先运算现在栈顶<code>history.top()</code>的 * 号，连续从栈顶取出两个元素相乘，得数18，弹出 * 号</p>\n<p>第九步，此时栈顶[<code>history.top()</code>]为“&#x3D;”，与输入的等号相等，程序结束，输出<code>operands.top()</code>【此时为得数】</p>\n<h4 id=\"如何“优雅地”添加括号？\"><a href=\"#如何“优雅地”添加括号？\" class=\"headerlink\" title=\"如何“优雅地”添加括号？\"></a>如何“优雅地”添加括号？</h4><p>根据以上括号的特点及运算流程</p>\n<p>我们可以知道：</p>\n<p>1.无论左括号前面是什么，直接进栈；</p>\n<p>2.左括号后面的符号只要不是右括号，左括号始终不出栈，并且将符号压入栈</p>\n<p>3.当等到右括号，则开始计算【等到右括号，“（）”内的数计算完毕】</p>\n<p>4.当等到右括号，则弹出左括号</p>\n<h5 id=\"换成伪代码的形式\"><a href=\"#换成伪代码的形式\" class=\"headerlink\" title=\"换成伪代码的形式\"></a>换成伪代码的形式</h5><p>将以上四点转换成伪代码的形式：</p>\n<ol>\n<li><p><code>if(op==&#39;(&#39;)&#123;push(op)&#125;</code></p>\n</li>\n<li><p><code>top==&#39;(&#39;&amp;&amp;op!=&#39;)&#39;:push(op)</code></p>\n</li>\n<li><p><code>if(op==&#39;)&#39;):calc</code></p>\n</li>\n<li><p><code>top==&#39;(&#39;&amp;&amp;op==&#39;)&#39;:pop(&#39;(&#39;)</code></p>\n</li>\n</ol>\n<h5 id=\"将伪代码转换为现实\"><a href=\"#将伪代码转换为现实\" class=\"headerlink\" title=\"将伪代码转换为现实\"></a>将伪代码转换为现实</h5><p>以上的伪代码只是我们的“梦想”，要让其成为现实的道路并不容易。</p>\n<p>因为我们之前的程序大体以及框架已经确定，不能重新打乱和改变。</p>\n<p>那么我们如何“优雅地”添加括号并且不让程序做很大改动？</p>\n<p><strong>答案是<u>把括号作为一种特殊的“运算符”加入map</u></strong></p>\n<p>我们需要用以下特性：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>1.无论左括号前面是什么，直接进栈</p>\n<p>2.只要不是右括号，左括号始终不出栈</p>\n<p>3.右括号始终不进栈</p></blockquote>\n<p>得出以下结论</p>\n<p>1.（左括号的右优先级要非常大）</p>\n<p>2.（左括号的左优先级要非常小）</p>\n<p>3.（右括号的右优先级非常小）</p>\n<p>转为代码</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">std::map&lt;oper, prv_num_t&gt;  p_num&#x3D;&#123;\n…………\n​\t&#123;&#39;(&#39;,&#123;99,1&#125;&#125;,&#x2F;&#x2F;左边的优先数代表在栈顶的优先数\n​\t&#123;&#39;)&#39;,&#123;0,99&#125;&#125;,&#x2F;&#x2F;右边的优先数代表在op中的优先数，\n    &#x2F;&#x2F;因为)不可能在栈内，所以左优先数为0，代表错误\n…………\n&#125;</code></pre>\n\n<p>我们重新审查代码，使用以上代码，可以实现以下目标：</p>\n<p>1.无论左括号前面是什么，直接进栈；<code>if(op==&#39;(&#39;)&#123;push(op)&#125;</code></p>\n<p>2.左括号后面的符号只要不是右括号，左括号始终不出栈，并且将符号压入栈 <code>top==&#39;(&#39;&amp;&amp;op!=&#39;)&#39;:push(op)</code></p>\n<p>3.当等到右括号，则开始计算 <code>if(op==&#39;)&#39;):calc</code>【等到右括号，“（）”内的数计算完毕】</p>\n<p>但是还有最后一点没有实现</p>\n<p>即：4.当等到右括号，则弹出左括号<code>top==&#39;(&#39;&amp;&amp;op==&#39;)&#39;:pop(&#39;(&#39;)</code></p>\n<p>此时我们必须修改源代码，在之前的判断等号与哨兵相等之前（<code>if(prior(history.top(),op)==0) break;</code>）根据伪代码<code>if(top==&#39;(&#39;&amp;&amp;op==&#39;)&#39;):pop(&#39;(&#39;)</code>加入以下代码，</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">if(op&#x3D;&#x3D;&quot;)&quot;)&#123;\n\t\t\thistory.pop();\n\t\t\tcontinue;\n\t\t&#125; </code></pre>\n\n<p>因为左括号的左优先数&#x3D;&#x3D;右括号的右优先数，如果经过<code>if(prior(history.top(),op)==0) break;</code>那就跳出循环，运算就出错了，所以我们应该在此之前加入代码即可</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">while(1)\n\t&#123;\n\t&#x2F;&#x2F;scanf(&quot;%f %c&quot;,&amp;x,&amp;op); 3+40&#x3D;;3+C0&#x3D;两个符号合起来，2L10&#x3D;，2 10 L&#x3D; ，L 2 10 &#x3D;；1 2 3 + *&#x3D; \n\tscanf(&quot; %c&quot;,&amp;op);&#x2F;&#x2F;预读下一位数 \n\tif(op&#x3D;&#x3D;&#39;,&#39;) continue;\n&#x2F;&#x2F;\tif(op是数字)\n\tif(isdigit(op)) &#123;&#x2F;&#x2F;isdigiy判断是否是数字 \n\t\tungetc(op, stdin);&#x2F;&#x2F;还回字符 ,还给stdin（键盘） \n\t\tscanf(&quot;%f&quot;,&amp;x);\n\t\toperands.push(x);\n\t\tcontinue; \n\t&#125;\t\n\twhile(prior(history.top(),op)&lt;0)&#123;\n\t\toperands.push(calc());\n\t\thistory.pop();\n\t&#125;\n+\t\tif(op&#x3D;&#x3D;&#39;)&#39;)&#123;\n+\t\t\thistory.pop();\n+\t\t\tcontinue;\n+\t\t&#125; \n\t\tif(prior(history.top(),op)&#x3D;&#x3D;0) break;\n\t\thistory.push(op);\n\t&#125;</code></pre>\n\n<p>此时我们基本<strong>实现了加入括号的问题</strong>了</p>\n<h2 id=\"二、优化报错方法\"><a href=\"#二、优化报错方法\" class=\"headerlink\" title=\"二、优化报错方法\"></a>二、优化报错方法</h2><p>解决了上面的问题，在输入右括号而不输入左括号，或者输入其他不识别的运算符时，报错代码来自</p>\n<img src=\"https://img1.i-nmb.cn/img/image-20220524233540858.png\" alt=\"报错代码来自calc函数\" style=\"zoom:60%;\" />\n\n<p>这样不利于我们定位出错的位置，所以我们需要优化程序：优化报错方法</p>\n<p>若我们输入其他错误字符时，若需要报错，则需要正在通过map函数查找字符对应的优先数的函数中<code>int prior(oper op1, oper op2)</code>进行</p>\n<p>在其中加入以下代码</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int prior(oper op1, oper op2)\n&#123;\n+\tif(p_num.find(op1)&#x3D;&#x3D;p_num.end()||p_num[op1].left&#x3D;&#x3D;0)&#123; &#x2F;&#x2F;如果找不到运算符的优先数||左优先数&#x3D;0\n+\tprintf(&quot;错误的运算符：%c\\n【程序即将终止】&quot;,op1);\n+\texit (-1);\t&#x2F;&#x2F;异常退出，终止程序\n+\t&#125;\n+\tif(p_num.find(op2)&#x3D;&#x3D;p_num.end()||p_num[op1].right&#x3D;&#x3D;0)&#123; &#x2F;&#x2F;如果找不到运算符的优先数||右优先数&#x3D;0\n+\tprintf(&quot;错误的运算符：%c\\n【程序即将终止】&quot;,op2);\n+\texit (-1);\n+\t&#125;\n\treturn p_num[op1].left - p_num[op2].right;\n&#125;</code></pre>\n\n\n\n<p>若我们在没有左括号的情况下输入右括号，报错，则需要在<code>字符</code>压入栈之前判断</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">operand solve()\n&#x2F;*****************************************\n* 2. 输入下一个运算符op；\n* 3. while(prior(h.top(),op)&lt;0)\n*    栈顶元素出栈并计算；\n* 4. if(prior(h.top(),op)&#x3D;&#x3D;0)结束；\n* 5. if(prior(h.top(),op)&gt;0) h.push(op);\n*******************************************&#x2F;\n&#123;\n\toperand x, y;\n\toper op;\n\thistory.push(&#39;&#x3D;&#39;);\n\twhile(1)\n\t&#123;\n\t&#x2F;&#x2F;scanf(&quot;%f %c&quot;,&amp;x,&amp;op); 3+40&#x3D;;3+C0&#x3D;两个符号合起来，2L10&#x3D;，2 10 L&#x3D; ，L 2 10 &#x3D;；1 2 3 + *&#x3D; \n\tscanf(&quot; %c&quot;,&amp;op);&#x2F;&#x2F;预读下一位数 \n\tif(op&#x3D;&#x3D;&#39;,&#39;) continue;\n&#x2F;&#x2F;\tif(op是数字)\n\tif(isdigit(op)) &#123;&#x2F;&#x2F;isdigiy判断是否是数字 \n\t\tungetc(op, stdin);&#x2F;&#x2F;还回字符 ,还给stdin（键盘） \n\t\tscanf(&quot;%f&quot;,&amp;x);\n\t\toperands.push(x);\n\t\tcontinue; \n\t&#125;\t\n\twhile(prior(history.top(),op)&lt;0)&#123;\n\t\toperands.push(calc());\n\t\thistory.pop();\n\t&#125;\n+\t\tif(op&#x3D;&#x3D;&#39;)&#39;)&#123;\n+\t\t\tif(history.top()!&#x3D;&#39;(&#39;)&#123;\n+\t\t\t\tprintf(&quot;请检测：有没有成对括号\\n截止目前，计算&quot;); \n+\t\t\t\tbreak;\n+\t\t\t&#125;\n\t\t\thistory.pop();\n\t\t\tcontinue;\n\t\t&#125; \n\t\tif(prior(history.top(),op)&#x3D;&#x3D;0) break;\n\t\thistory.push(op);\n\t&#125;\n\treturn operands.top();\t\n&#125;</code></pre>\n\n\n\n<h2 id=\"三、问题解决完毕\"><a href=\"#三、问题解决完毕\" class=\"headerlink\" title=\"三、问题解决完毕\"></a>三、问题解决完毕</h2><p>目前我们需要解决的问题有两种，即：</p>\n<h5 id=\"1-加入括号进行运算-1\"><a href=\"#1-加入括号进行运算-1\" class=\"headerlink\" title=\"1.加入括号进行运算\"></a>1.加入括号进行运算</h5><h5 id=\"2-优化报错方法-1\"><a href=\"#2-优化报错方法-1\" class=\"headerlink\" title=\"2.优化报错方法\"></a>2.优化报错方法</h5><p>而这两种在上面已经基本上解决了，至此完结~（撒花）</p>\n<p>下面附上更改后的代码</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include&lt;stdio.h&gt;\n#include&lt;stack&gt;\n#include&lt;map&gt;\n#include&lt;math.h&gt;\ntypedef char oper;\ntypedef float operand;\nstd::stack&lt;oper&gt; history;\nstd::stack&lt;operand&gt; operands;\n\n&#x2F;*优先数表*&#x2F;\nstruct prv_num_t&#123;char left,right;&#125;;\nstd::map&lt;oper, prv_num_t&gt;  p_num&#x3D;&#123;\n\t&#123;&#39;+&#39;,&#123;81,82&#125;&#125;,\n\t&#123;&#39;-&#39;,&#123;81,82&#125;&#125;,\n\t&#123;&#39;*&#39;,&#123;41,42&#125;&#125;,\n\t&#123;&#39;&#x2F;&#39;,&#123;41,42&#125;&#125;,\n\t&#123;&#39;&#x3D;&#39;, &#123;100,100&#125;&#125;,\n\t&#123;&#39;^&#39;,&#123;32,31&#125;&#125;, \n\t&#123;&#39;L&#39;,&#123;22,21&#125;&#125;,&#x2F;&#x2F;对数运算符log(x,y) ；log (x,log(x,x)) ，右边优先 \n\t&#123;&#39;S&#39;,&#123;22,21&#125;&#125;,&#x2F;&#x2F;定义sin函数 \n\t&#123;&#39;C&#39;,&#123;22,21&#125;&#125;,&#x2F;&#x2F;定义cos函数; \n\t&#123;&#39;(&#39;,&#123;99,1&#125;&#125;,\n\t&#123;&#39;)&#39;,&#123;0,99&#125;&#125;,&#x2F;&#x2F;0作为错误标志 \n&#125;;\n&#x2F;&#x2F;&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;, &#x2F;* 0-9 *&#x2F;\n&#x2F;&#x2F;&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;, &#x2F;* 10-19 *&#x2F;\n&#x2F;&#x2F;&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;, &#x2F;* 20-29 *&#x2F;\n&#x2F;&#x2F;&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;, &#x2F;* 30-39 *&#x2F;\n&#x2F;&#x2F;&#123;0,0&#125;,&#123;0,0&#125;,&#123;41,42&#125;,&#123;81,82&#125;,&#123;0,0&#125;,&#123;81,82&#125;,&#123;0,0&#125;,&#123;41,42&#125;,&#123;0,0&#125;,&#123;0,0&#125;, &#x2F;* 40-49 *&#x2F;\n&#x2F;&#x2F;&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;, &#x2F;* 50-59 *&#x2F;\n&#x2F;&#x2F;&#123;0,0&#125;,&#123;100,100&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;, &#x2F;* 60-69 *&#x2F;\n&#x2F;&#x2F;&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;, &#x2F;* 70-79 *&#x2F;\n&#x2F;&#x2F;&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;, &#x2F;* 80-89 *&#x2F;\n&#x2F;&#x2F;&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;, &#x2F;* 90-99 *&#x2F;\n&#x2F;&#x2F;&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;, &#x2F;* 100-109 *&#x2F;\n&#x2F;&#x2F;&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;, &#x2F;* 110-119 *&#x2F;\n&#x2F;&#x2F;&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125; &#x2F;* 120-127 *&#x2F;\n&#x2F;&#x2F;&#125;;\n\n&#x2F;&#x2F;43 45 42 47 61\n\n\n&#x2F;*op1在左，op2在右*&#x2F; \n&#x2F;*返回值为负：op1优先级高于op2*&#x2F;\n&#x2F;*返回值为正：op2优先级高于op1*&#x2F;\n&#x2F;*返回值为0：op1优先级等于op2*&#x2F;\nint prior(oper op1, oper op2)\n&#123;\n\tif(p_num.find(op1)&#x3D;&#x3D;p_num.end()||p_num[op1].left&#x3D;&#x3D;0)&#123; &#x2F;&#x2F;如果找不到运算符\n\tprintf(&quot;错误的运算符：%c\\n【程序即将终止】&quot;,op1);\n\texit (-1);\n\t&#125;\n\tif(p_num.find(op2)&#x3D;&#x3D;p_num.end()||p_num[op1].right&#x3D;&#x3D;0)&#123; &#x2F;&#x2F;如果找不到运算符\n\tprintf(&quot;错误的运算符：%c\\n【程序即将终止】&quot;,op2);\n\texit (-1);\n\t&#125;\n\treturn p_num[op1].left - p_num[op2].right;\n&#125;\n#include&lt;ctype.h&gt;&#x2F;&#x2F;判断字符类型 \n#include&lt;string.h&gt; \noperand calc()&#123;\n\toperand x, y;\n&#x2F;&#x2F;\tif(history.top()是双目运算符)&#123;\n\tif(strchr(&quot;+-*&#x2F;^L&quot;,history.top()))&#123;&#x2F;&#x2F;strchr在 &quot;+-*&#x2F;^L&quot;找到 history.top()，如果找到返回位置，找不到返回空值【用来判断（整数和0）】 \n\t\ty &#x3D; operands.top();\n\t\toperands.pop();\n\t&#125;\n\n\tx &#x3D; operands.top();\n\toperands.pop();\n\tswitch(history.top())&#123;\n\t\tcase &#39;+&#39;: return x+y;\n\t\tcase &#39;-&#39;: return x-y;\n\t\tcase &#39;*&#39;: return x*y;\n\t\tcase &#39;&#x2F;&#39;: return x&#x2F;y;\n\t\tcase &#39;^&#39;: return pow(x,y);\n\t\tcase &#39;L&#39;: return log(y)&#x2F;log(x);&#x2F;&#x2F;log c库的对数换底公式 \n\t\tcase &#39;S&#39;: return sin(y); &#x2F;&#x2F;\t\tcase &#39;S&#39;: operands.push(x); return sin(y); \n\t\tcase &#39;C&#39;: return cos(y); &#x2F;&#x2F;\t\tcase &#39;C&#39;: operands.push(x); return cos(y);\n\t&#125;\n\tprintf(&quot;Err&quot;);\n\treturn -1;\n&#125;\noperand solve()\n&#x2F;*****************************************\n* 2. 输入下一个运算符op；\n* 3. while(prior(h.top(),op)&lt;0)\n*    栈顶元素出栈并计算；\n* 4. if(prior(h.top(),op)&#x3D;&#x3D;0)结束；\n* 5. if(prior(h.top(),op)&gt;0) h.push(op);\n*******************************************&#x2F;\n&#123;\n\toperand x, y;\n\toper op;\n\thistory.push(&#39;&#x3D;&#39;);\n\twhile(1)\n\t&#123;\n\t&#x2F;&#x2F;scanf(&quot;%f %c&quot;,&amp;x,&amp;op); 3+40&#x3D;;3+C0&#x3D;两个符号合起来，2L10&#x3D;，2 10 L&#x3D; ，L 2 10 &#x3D;；1 2 3 + *&#x3D; \n\tscanf(&quot; %c&quot;,&amp;op);&#x2F;&#x2F;预读下一位数 \n\tif(op&#x3D;&#x3D;&#39;,&#39;) continue;\n&#x2F;&#x2F;\tif(op是数字)\n\tif(isdigit(op)) &#123;&#x2F;&#x2F;isdigiy判断是否是数字 \n\t\tungetc(op, stdin);&#x2F;&#x2F;还回字符 ,还给stdin（键盘） \n\t\tscanf(&quot;%f&quot;,&amp;x);\n\t\toperands.push(x);\n\t\tcontinue; \n\t&#125;\t\n\twhile(prior(history.top(),op)&lt;0)&#123;\n\t\toperands.push(calc());\n\t\thistory.pop();\n\t&#125;\n\t\tif(op&#x3D;&#x3D;&#39;)&#39;)&#123;\n\t\t\tif(history.top()!&#x3D;&#39;(&#39;)&#123;\n\t\t\t\tprintf(&quot;请检测：有没有成对括号\\n截止目前，计算&quot;); \n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t\thistory.pop();\n\t\t\tcontinue;\n\t\t&#125; \n\t\tif(prior(history.top(),op)&#x3D;&#x3D;0) break;\n\t\thistory.push(op);\n\t&#125;\n\treturn operands.top();\t\n&#125;\n\nint main()\n&#123;\n&#x2F;&#x2F;\tprintf(&quot;%d %d %d %d %d&quot;, &#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;&#x2F;&#39;, &#39;&#x3D;&#39;);return 0;\n\tprintf(&quot;%g\\n&quot;, solve());\n\treturn 0;\n&#125;</code></pre>\n\n","text":"前段时间我们制作了一个表达式求值的程序， 我们赋予他基本框架与功能：【实例】表达式求值——利用stack实现五种运算符的运算 | 《课程设计》笔记 (i-nmb.cn) 以及更新了一目运算符的支持：【实例更新】表达式求值——加入新的单目运算符 | 《课程设计》笔记 (i-nmb....","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[],"tags":[{"name":"运算符","slug":"运算符","count":3,"path":"api/tags/运算符.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98%E5%BC%95%E5%85%A5\"><span class=\"toc-text\">问题引入</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E5%8A%A0%E5%85%A5%E6%8B%AC%E5%8F%B7%E8%BF%9B%E8%A1%8C%E8%BF%90%E7%AE%97\"><span class=\"toc-text\">1.加入括号进行运算</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E4%BC%98%E5%8C%96%E6%8A%A5%E9%94%99%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2.优化报错方法</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E5%8A%A0%E5%85%A5%E6%8B%AC%E5%8F%B7\"><span class=\"toc-text\">一、加入括号</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98%E6%80%9D%E8%80%83\"><span class=\"toc-text\">问题思考</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8A%A0%E5%85%A5%E6%8B%AC%E5%8F%B7%EF%BC%8C%E6%93%8D%E4%BD%9C%E6%95%B0%E5%8F%88%E6%9C%89%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96%EF%BC%9F\"><span class=\"toc-text\">加入括号，操作数又有什么变化？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8B%AC%E5%8F%B7%E7%9A%84%E7%89%B9%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">括号的特点是什么？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%B7%E4%BD%93%E7%9A%84%E7%AE%97%E6%B3%95%EF%BC%88%E6%88%96%E8%80%85%E8%AF%B4-%E8%BF%90%E7%AE%97%E6%B5%81%E7%A8%8B-%EF%BC%89\"><span class=\"toc-text\">具体的算法（或者说 运算流程 ）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E2%80%9C%E4%BC%98%E9%9B%85%E5%9C%B0%E2%80%9D%E6%B7%BB%E5%8A%A0%E6%8B%AC%E5%8F%B7%EF%BC%9F\"><span class=\"toc-text\">如何“优雅地”添加括号？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%8D%A2%E6%88%90%E4%BC%AA%E4%BB%A3%E7%A0%81%E7%9A%84%E5%BD%A2%E5%BC%8F\"><span class=\"toc-text\">换成伪代码的形式</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%B0%86%E4%BC%AA%E4%BB%A3%E7%A0%81%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%8E%B0%E5%AE%9E\"><span class=\"toc-text\">将伪代码转换为现实</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E4%BC%98%E5%8C%96%E6%8A%A5%E9%94%99%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">二、优化报错方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%AE%8C%E6%AF%95\"><span class=\"toc-text\">三、问题解决完毕</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E5%8A%A0%E5%85%A5%E6%8B%AC%E5%8F%B7%E8%BF%9B%E8%A1%8C%E8%BF%90%E7%AE%97-1\"><span class=\"toc-text\">1.加入括号进行运算</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E4%BC%98%E5%8C%96%E6%8A%A5%E9%94%99%E6%96%B9%E6%B3%95-1\"><span class=\"toc-text\">2.优化报错方法</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"ACbug战队","slug":"blog-author","avatar":"https://img1.i-nmb.cn/ava.png","link":"/","description":"西北民族大学数学与计算机科学学院<br>系统与软件工作室网络安全组","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"【实例2】24点游戏","uid":"f6e40bab8f6950a622e72a274ec12c0e","slug":"Point-24-Game","date":"2022-06-09T03:06:24.000Z","updated":"2022-06-19T13:58:10.802Z","comments":true,"path":"api/articles/Point-24-Game.json","keywords":null,"cover":[],"text":"描述问题在确认程序编写之前我们需要思考如何描述，表达问题 算法具有五个特性 1.输入：在算法中可以有零个或者多个输入 2.输出：在算法中至少有一个或者多个输出 3.有穷行：在执行有限的步骤之后，自动结束不会出现无限循环并且每一个步骤在可接受的时间内完成 4.确定性：算法的每一个步...","link":"","photos":[],"count_time":{"symbolsCount":"9.4k","symbolsTime":"9 mins."},"categories":[],"tags":[{"name":"24点","slug":"24点","count":1,"path":"api/tags/24点.json"}],"author":{"name":"ACbug战队","slug":"blog-author","avatar":"https://img1.i-nmb.cn/ava.png","link":"/","description":"西北民族大学数学与计算机科学学院<br>系统与软件工作室网络安全组","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"【实例1の更新1】表达式求值——加入新的单目运算符","uid":"6c04c36ceec929560d9050b95673c3cf","slug":"example-optimization-1","date":"2022-05-23T22:38:52.000Z","updated":"2022-06-19T13:56:51.545Z","comments":true,"path":"api/articles/example-optimization-1.json","keywords":null,"cover":null,"text":"前段时间我们学习了利用stack实现五种运算符的运算：【实例】表达式求值——利用stack实现五种运算符的运算 | 《课程设计》笔记 (i-nmb.cn) 实际上我们的表达式求值中并不是只有这5种运算，他还包括了 指数、对数以及三角函数等等。 今天我们就在原基础上逐一的实现 指数...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[],"tags":[{"name":"运算符","slug":"运算符","count":3,"path":"api/tags/运算符.json"}],"author":{"name":"ACbug战队","slug":"blog-author","avatar":"https://img1.i-nmb.cn/ava.png","link":"/","description":"西北民族大学数学与计算机科学学院<br>系统与软件工作室网络安全组","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}