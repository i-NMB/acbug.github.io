{"title":"【实例1の更新1】表达式求值——加入新的单目运算符","uid":"6c04c36ceec929560d9050b95673c3cf","slug":"example-optimization-1","date":"2022-05-23T22:38:52.000Z","updated":"2022-06-19T13:56:51.545Z","comments":true,"path":"api/articles/example-optimization-1.json","keywords":null,"cover":null,"content":"<p>前段时间我们学习了利用stack实现五种运算符的运算：<a href=\"https://kcsj.i-nmb.cn/example.html\">【实例】表达式求值——利用stack实现五种运算符的运算 | 《课程设计》笔记 (i-nmb.cn)</a></p>\n<p>实际上我们的表达式求值中并不是只有这5种运算，他还包括了 指数、对数以及三角函数等等。</p>\n<p>今天我们就在原基础上逐一的实现 <code>指数、对数以及三角函数</code> 的表达式求值</p>\n<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>之前，在<a href=\"https://kcsj.i-nmb.cn/example.html\">【实例】表达式求值——利用stack实现五种运算符的运算 | 《课程设计》笔记 (i-nmb.cn)</a>中，我们做出了一下代码</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">#include&lt;stdio.h&gt;\n#include&lt;stack&gt;\n#include&lt;map&gt;\n\ntypedef char oper;&#x2F;&#x2F;运算符\ntypedef float operand;\n\n&#x2F;*优先数表*&#x2F;\nstruct prv_num_t&#123;char left,right;&#125;;&#x2F;&#x2F;定义结构体 prv_num_t  _t代表类型 \n&#x2F;&#x2F;关键字只包含一部分数据项,就称为map\n&#x2F;&#x2F;关键字包含全部数据项,成为 \nstd::map&lt;oper, prv_num_t&gt; p_num&#x3D;&#123;\n\t&#123;&#39;+&#39;,&#123;81,82&#125;&#125;,\n\t&#123;&#39;-&#39;,&#123;81,82&#125;&#125;,\n\t&#123;&#39;*&#39;,&#123;41,42&#125;&#125;,\n\t&#123;&#39;&#x2F;&#39;,&#123;41,42&#125;&#125;,\n\t&#123;&#39;&#x3D;&#39;,&#123;100,100&#125;&#125;\n&#125;;\n\n\n&#x2F;*op1在左，op2在右*&#x2F;\n&#x2F;*返回值为负: op1优先级高于op2*&#x2F;\n&#x2F;*返回值为正: op2优先级高于op1*&#x2F;\n&#x2F;*返回值为0: op1优先级等于op2*&#x2F;\n\nint prior(oper op1, oper op2)&#123;\n\treturn p_num[op1].left - p_num[op2].right;\n&#125;\n\noperand solve()&#123;\n\toperand x, y;\n\toper op;\n\tstd::stack&lt;oper&gt; history;&#x2F;&#x2F;历史栈 \n\tstd::stack&lt;operand&gt; operands;\n\thistory.push(&#39;&#x3D;&#39;);&#x2F;&#x2F;输入等号，whach dog（士兵）进栈 \n\twhile(1)&#123;\n&#x2F;****************************************\n*2.  输入下一个运算符op;\n*3.  while（h.top()比op优先）&#123;\t栈顶元素出栈计算；&#125;\n*4.  if(h.top()&#x3D;&#x3D;&#39;&#x3D;&#39;&amp;&amp; op&#x3D;&#x3D;&#39;&#x3D;&#39;)&#123;结束&#125;\n*5.  h.push(op);\n*6.  转2。\n******************************************&#x2F;\n\t\tscanf(&quot;%f %c&quot;,&amp;x,&amp;op);\n\t\toperands.push(x);\n\t\twhile(prior(history.top(), op)&lt;0)&#123;\n\t\t\t\n\t\t\ty &#x3D; operands.top();\n\t\t\toperands.pop();\n\t\t\tx &#x3D; operands.top();\n\t\t\toperands.pop();\n\t\t\tswitch(history.top())&#123;\n\t\t\t\tcase &#39;+&#39;: operands.push(x + y) ; break;\n\t\t\t\tcase &#39;-&#39;: operands.push(x - y) ; break;\n\t\t\t\tcase &#39;*&#39;: operands.push(x * y) ; break;\n\t\t\t\tcase &#39;&#x2F;&#39;: operands.push(x &#x2F; y) ; break;\n\t\t\t&#125;\n\t\t\thistory.pop();\n\t\t&#125;\n\t\tif(prior(history.top(),op)&#x3D;&#x3D;0) break;\n\t\thistory.push(op);\n\t&#125;\n\treturn operands.top();\n&#125;\n\nint main()&#123;\n\tprintf(&quot;%g\\n&quot;,solve());\n\t\n\treturn 0;\n&#125;\n </code></pre>\n\n\n\n<p>今天的实例更新，是建立再此代码基础上的</p>\n<h2 id=\"实现目标\"><a href=\"#实现目标\" class=\"headerlink\" title=\"实现目标\"></a>实现目标</h2><p>1、优化之前的代码</p>\n<p>2、逐一的实现 <code>指数、对数以及三角函数</code> 的表达式求值</p>\n<h2 id=\"1-优化代码\"><a href=\"#1-优化代码\" class=\"headerlink\" title=\"1.优化代码\"></a>1.优化代码</h2><p>在加入新功能之前，我们先审视之前我们敲击的代码，我们在<code>operand solve()&#123;&#125;</code>函数中使用了以下循环</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">operand solve()&#123;\n\twhile(1)&#123;\n\t……………………………………………………\n\t\twhile(prior(history.top(), op)&lt;0)&#123;\n\t\t\ty &#x3D; operands.top();\n\t\t\toperands.pop();\n\t\t\tx &#x3D; operands.top();\n\t\t\toperands.pop();\n\t\t\tswitch(history.top())&#123;\n\t\t\t\tcase &#39;+&#39;: operands.push(x + y) ; break;\n\t\t\t\tcase &#39;-&#39;: operands.push(x - y) ; break;\n\t\t\t\tcase &#39;*&#39;: operands.push(x * y) ; break;\n\t\t\t\tcase &#39;&#x2F;&#39;: operands.push(x &#x2F; y) ; break;\n\t\t&#125;\n\t\t……………………………………\n\t&#125;\n\t…………………………………………\n&#125;</code></pre>\n\n<p>这个循环实质上是一个运算核心，放在循环中，总是不太合适。</p>\n<p>所以我们把他提取出来，改造成一个函数<code>operand calc()&#123;&#125;</code>，返回类型为之前定义的operand（操作数）</p>\n<p><code>operand calc()</code>在循环while(prior(history.top(),op)&lt;0)返回运算结果，若输入出错，则输出Err，返回-1</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">operand calc()&#123;\n\toperand x, y;\n\ty &#x3D; operands.top();\n\toperands.pop();\n\tx &#x3D; operands.top();\n\toperands.pop();\n\tswitch(history.top())&#123;\n\t\tcase &#39;+&#39;: return x+y;&#x2F;&#x2F;当运算符为+时，在循环while(prior(history.top(),op)&lt;0)返回x+y运算结果\n\t\tcase &#39;-&#39;: return x-y;&#x2F;&#x2F;当运算符为-时，在循环while(prior(history.top(),op)&lt;0)返回x-y运算结果\n\t\tcase &#39;*&#39;: return x*y;&#x2F;&#x2F;当运算符为*时，在循环while(prior(history.top(),op)&lt;0)返回x*y运算结果\n\t\tcase &#39;&#x2F;&#39;: return x&#x2F;y;&#x2F;&#x2F;当运算符为&#x2F;时，在循环while(prior(history.top(),op)&lt;0)返回x&#x2F;y运算结果\n\t&#125;\n\tprintf(&quot;Err&quot;);\n\treturn -1;\n&#125;</code></pre>\n\n\n\n<p>而原\t<code>while(prior(history.top(), op)&lt;0)&#123;&#125;</code>循环体中改为</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">while(prior(history.top(),op)&lt;0)&#123;\n\toperands.push(calc());\n\thistory.pop();\n&#125;</code></pre>\n\n\n\n<p>最后将以下代码设置为全局变量</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">std::stack&lt;oper&gt; history;&#x2F;&#x2F;历史栈 \nstd::stack&lt;operand&gt; operands;</code></pre>\n\n<p>至此优化结束，优化后的总代码为：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include&lt;stdio.h&gt;\n#include&lt;stack&gt;\n#include&lt;map&gt;\n\ntypedef char oper;&#x2F;&#x2F;运算符\ntypedef float operand;\nstd::stack&lt;oper&gt; history;&#x2F;&#x2F;历史栈 \nstd::stack&lt;operand&gt; operands;\n\n&#x2F;*优先数表*&#x2F;\nstruct prv_num_t&#123;char left,right;&#125;;&#x2F;&#x2F;定义结构体 prv_num_t  _t代表类型 \n&#x2F;&#x2F;关键字只包含一部分数据项,就称为map\n&#x2F;&#x2F;关键字包含全部数据项,成为 \nstd::map&lt;oper, prv_num_t&gt; p_num&#x3D;&#123;\n\t&#123;&#39;+&#39;,&#123;81,82&#125;&#125;,\n\t&#123;&#39;-&#39;,&#123;81,82&#125;&#125;,\n\t&#123;&#39;*&#39;,&#123;41,42&#125;&#125;,\n\t&#123;&#39;&#x2F;&#39;,&#123;41,42&#125;&#125;,\n\t&#123;&#39;&#x3D;&#39;,&#123;100,100&#125;&#125;\n&#125;;\n\n\n&#x2F;*op1在左，op2在右*&#x2F;\n&#x2F;*返回值为负: op1优先级高于op2*&#x2F;\n&#x2F;*返回值为正: op2优先级高于op1*&#x2F;\n&#x2F;*返回值为0: op1优先级等于op2*&#x2F;\n\nint prior(oper op1, oper op2)&#123;\n\treturn p_num[op1].left - p_num[op2].right;\n&#125;\n\n\noperand calc()&#123;\n\toperand x, y;\n\ty &#x3D; operands.top();\n\toperands.pop();\n\tx &#x3D; operands.top();\n\toperands.pop();\n\tswitch(history.top())&#123;\n\t\tcase &#39;+&#39;: return x+y;\n\t\tcase &#39;-&#39;: return x-y;\n\t\tcase &#39;*&#39;: return x*y;\n\t\tcase &#39;&#x2F;&#39;: return x&#x2F;y;\n\t&#125;\n\tprintf(&quot;Err&quot;);\n\treturn -1;\n&#125;\n\n\noperand solve()&#123;\n\toperand x, y;\n\toper op;\n\n\thistory.push(&#39;&#x3D;&#39;);&#x2F;&#x2F;输入等号，whach dog（士兵）进栈 \n\twhile(1)&#123;\n&#x2F;****************************************\n*2.  输入下一个运算符op;\n*3.  while（h.top()比op优先）&#123;\t栈顶元素出栈计算；&#125;\n*4.  if(h.top()&#x3D;&#x3D;&#39;&#x3D;&#39;&amp;&amp; op&#x3D;&#x3D;&#39;&#x3D;&#39;)&#123;结束&#125;\n*5.  h.push(op);\n*6.  转2。\n******************************************&#x2F;\n\t\tscanf(&quot;%f %c&quot;,&amp;x,&amp;op);\n\t\toperands.push(x);\n\t\twhile(prior(history.top(), op)&lt;0)&#123;\n\t\t\toperands.push(calc());\n\t\t\thistory.pop();\n\t\t&#125;\n\t\tif(prior(history.top(),op)&#x3D;&#x3D;0) break;\n\t\thistory.push(op);\n\t&#125;\n\treturn operands.top();\n&#125;\n\nint main()&#123;\n\tprintf(&quot;%g\\n&quot;,solve());\n\t\n\treturn 0;\n&#125;\n </code></pre>\n\n\n\n<h2 id=\"2-增加指数运算和对数运算符\"><a href=\"#2-增加指数运算和对数运算符\" class=\"headerlink\" title=\"2.增加指数运算和对数运算符\"></a>2.增加指数运算和对数运算符</h2><h3 id=\"增加指数运算符\"><a href=\"#增加指数运算符\" class=\"headerlink\" title=\"增加指数运算符\"></a>增加指数运算符</h3><p>增加指数运算相对简单，在map（<code>std::map&lt;oper, prv_num_t&gt; p_num</code>）里面增加<code>&#123;&quot;关键字&quot;,&#123;左优先数,右优先数&#125;&#125;</code>，左优先级大于右优先（从左到右运算）【2^3^2&#x3D;&#x3D;64!&#x3D;2^(3^2)】</p>\n<p>即</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">std::map&lt;oper, prv_num_t&gt; p_num&#x3D;&#123;\n\t&#123;&#39;+&#39;,&#123;81,82&#125;&#125;,\n\t&#123;&#39;-&#39;,&#123;81,82&#125;&#125;,\n\t&#123;&#39;*&#39;,&#123;41,42&#125;&#125;,\n\t&#123;&#39;&#x2F;&#39;,&#123;41,42&#125;&#125;,\n\t&#123;&#39;&#x3D;&#39;,&#123;100,100&#125;&#125;,\n    \n+    &#123;&#39;^&#39;,&#123;32,31&#125;&#125;\n    \n&#125;;</code></pre>\n\n\n\n<p>并且在运算函数<code>calc()&#123;&#125;</code>加入返回运算值</p>\n<p>即</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\tcase &#39;*&#39;: return x*y;\n\tcase &#39;&#x2F;&#39;: return x&#x2F;y;\n\n+\tcase &#39;^&#39;: return pow(x,y);\n\n&#125;\nprintf(&quot;Err&quot;);</code></pre>\n\n<p>因为用到了pow函数，所以我们在头文件加入<code>#include&lt;math.h&gt;</code></p>\n<p>至此，增加指数运算符操作结束</p>\n<h3 id=\"增加对数运算符\"><a href=\"#增加对数运算符\" class=\"headerlink\" title=\"增加对数运算符\"></a>增加对数运算符</h3><p>同理</p>\n<p>在map（<code>std::map&lt;oper, prv_num_t&gt; p_num</code>）里面增加<code>&#123;&quot;关键字&quot;,&#123;左优先数,右优先数&#125;&#125;</code>，左优先级小于右优先（从右到左运算）【log （2,log(2,8))&#x3D;3】</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">std::map&lt;oper, prv_num_t&gt;  p_num&#x3D;&#123;\n\t&#123;&#39;+&#39;,&#123;81,82&#125;&#125;,\n\t&#123;&#39;-&#39;,&#123;81,82&#125;&#125;,\n\t&#123;&#39;*&#39;,&#123;41,42&#125;&#125;,\n\t&#123;&#39;&#x2F;&#39;,&#123;41,42&#125;&#125;,\n\t&#123;&#39;&#x3D;&#39;, &#123;100,100&#125;&#125;,\n\t&#123;&#39;^&#39;,&#123;32,31&#125;&#125;, \n    \n+\t&#123;&#39;L&#39;,&#123;22,21&#125;&#125;&#x2F;&#x2F;对数运算符log(x,y) ；log (x,log(x,x)) ，右边优先 \n    \n&#125;\nprintf(&quot;Err&quot;);</code></pre>\n\n\n\n<p>在运算函数<code>calc()&#123;&#125;</code>加入返回运算值</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\tcase &#39;*&#39;: return x*y;\n\tcase &#39;&#x2F;&#39;: return x&#x2F;y;\n\tcase &#39;^&#39;: return pow(x,y);\n\t\n+\tcase &#39;L&#39;: return log(y)&#x2F;log(x);&#x2F;&#x2F;对数换底公式 ,以x（先输入的数）为底数\n\n&#125;\nprintf(&quot;Err&quot;);\n</code></pre>\n\n<p>至此，增加对数运算符操作结束</p>\n<p>试试<code>2L8=</code> 答案是3</p>\n<h2 id=\"3-增加三角函数（单目运算符）\"><a href=\"#3-增加三角函数（单目运算符）\" class=\"headerlink\" title=\"3.增加三角函数（单目运算符）\"></a>3.增加三角函数（单目运算符）</h2><p>在map添加关键字</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">std::map&lt;oper, prv_num_t&gt;  p_num&#x3D;&#123;\n\t&#123;&#39;+&#39;,&#123;81,82&#125;&#125;,\n\t&#123;&#39;-&#39;,&#123;81,82&#125;&#125;,\n\t&#123;&#39;*&#39;,&#123;41,42&#125;&#125;,\n\t&#123;&#39;&#x2F;&#39;,&#123;41,42&#125;&#125;,\n\t&#123;&#39;&#x3D;&#39;, &#123;100,100&#125;&#125;,\n\t&#123;&#39;^&#39;,&#123;32,31&#125;&#125;, \n    &#123;&#39;L&#39;,&#123;22,21&#125;&#125;,\t&#x2F;&#x2F;对数运算符log(x,y) ；log (x,log(x,x)) ，右边优先 \n    \n+    &#123;&#39;S&#39;,&#123;22,21&#125;&#125;,&#x2F;&#x2F;定义sin函数 \n+\t&#123;&#39;C&#39;,&#123;22,21&#125;&#125;,&#x2F;&#x2F;定义cos函数; \n&#125;\nprintf(&quot;Err&quot;);</code></pre>\n\n\n\n\n\n\n\n<p>在运算函数<code>calc()&#123;&#125;</code>加入返回运算值</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\tcase &#39;*&#39;: return x*y;\n\tcase &#39;&#x2F;&#39;: return x&#x2F;y;\n\tcase &#39;^&#39;: return pow(x,y);\n\tcase &#39;L&#39;: return log(y)&#x2F;log(x);&#x2F;&#x2F;对数换底公式 ,以x（先输入的数）为底数\n\n+\tcase &#39;S&#39;: return sin(y); \t\t\n+\tcase &#39;C&#39;: return cos(y); \n\n&#125;\nprintf(&quot;Err&quot;);\n</code></pre>\n\n<p>至此，增加三角函数符号</p>\n<h3 id=\"冲突\"><a href=\"#冲突\" class=\"headerlink\" title=\"冲突\"></a>冲突</h3><p>之前我们增加的是双目运算符，遵循着 <code>&#39;操作数&#39; &#39;运算符&#39; &#39;操作数&#39;</code></p>\n<p>现在，我们的单目运算符，遵循 <code>&#39;运算符&#39; &#39;操作数&#39;</code></p>\n<h3 id=\"一、输入模式不同的解决办法\"><a href=\"#一、输入模式不同的解决办法\" class=\"headerlink\" title=\"一、输入模式不同的解决办法\"></a>一、输入模式不同的解决办法</h3><p>二者输入模式不同，怎么办？难道之前辛苦搭建的程序崩塌了？</p>\n<p>其实我们输入表达式的时候已经将完整的表达式输入了，<strong>此时我们只需要判断下一位是不是运算符，而进行对应计算，也就是<u>预读下一位数</u></strong></p>\n<p><strong>预读下一位数如果是数字，那么返还给键盘（模拟键盘重新输入）</strong></p>\n<p><strong>预读下一位数如果不是数字，那么作为op（运算符）</strong></p>\n<p>所以在<code>while(1)&#123;&#125;</code>处，更改以下代码</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">while(1)&#123;\n&#x2F;****************************************\n*2.  输入下一个运算符op;\n*3.  while（h.top()比op优先）&#123;\t栈顶元素出栈计算；&#125;\n*4.  if(h.top()&#x3D;&#x3D;&#39;&#x3D;&#39;&amp;&amp; op&#x3D;&#x3D;&#39;&#x3D;&#39;)&#123;结束&#125;\n*5.  h.push(op);\n*6.  转2。\n******************************************&#x2F;\n\n-\t\tscanf(&quot;%f %c&quot;,&amp;x,&amp;op);\t\t&#x2F;&#x2F;scanf(&quot;%f %c&quot;,&amp;x,&amp;op); 3+40&#x3D;;3+C0&#x3D;两个符号合起来\n-\t\toperands.push(x);\n\n\t\n+\tscanf(&quot; %c&quot;,&amp;op);&#x2F;&#x2F;预读下一位数 \n\n+\tif(isdigit(op)) &#123;\t\t\t&#x2F;&#x2F;isdigiy判断是否是数字 &#x2F;&#x2F;if(op是数字) #include&lt;ctype.h&gt;&#x2F;&#x2F;判断字符类型 \n+\t\tungetc(op, stdin);\t\t&#x2F;&#x2F;还回字符 ,还给stdin（键盘）\n+\t\tscanf(&quot;%f&quot;,&amp;x);\n+\t\toperands.push(x);\n+\t\tcontinue; \n+\t&#125;\t</code></pre>\n\n<p>并且增加头文件<code>#include&lt;ctype.h&gt;</code> </p>\n<p>此时输入模式不同的问题得以解决</p>\n<h3 id=\"二、运算模式不同的解决\"><a href=\"#二、运算模式不同的解决\" class=\"headerlink\" title=\"二、运算模式不同的解决\"></a>二、运算模式不同的解决</h3><p>如果是双目运算符，那么我们操作数栈的操作如下</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">y &#x3D; operands.top();\noperands.pop();\nx &#x3D; operands.top();\noperands.pop();</code></pre>\n\n<p>由此可见，我们在运算双目运算符的时候，把y赋予栈顶值，然后弹出栈顶以获取下一个数来赋予x，之后再一次弹出栈顶</p>\n<p><strong>相当于一个双目运算符运算过后，弹出两个数</strong></p>\n<p>而如果用单目运算符运算，只需要运算一个数</p>\n<p>也就是说，<strong>单目运算符运算过后，弹出一个数</strong></p>\n<h4 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h4><p>我们需要判断运算符是单目运算符还是双目运算符</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">if(history.top()是双目运算符)&#123;\n\ty &#x3D; operands.top();\n\toperands.pop();\n&#125;</code></pre>\n\n<p>如果是双目运算符我们就弹多走1个栈顶</p>\n<p>​\t<code>if(history.top()是双目运算符)</code>我们使用<code>if(strchr(&quot;+-*/^L&quot;,history.top()))</code>实现</p>\n<p>也就是在<code>operand calc()</code>函数中做以下操作</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">operand calc()&#123;\n\toperand x, y;\n\t\n-\ty &#x3D; operands.top();\n-\toperands.pop();\n\n+\tif(strchr(&quot;+-*&#x2F;^L&quot;,history.top()))&#123;\t&#x2F;&#x2F;strchr在 &quot;+-*&#x2F;^L&quot;找到 history.top()，如果找到返回位置，找不到返回空值【用来判断（整数和0）】 \n+\t\ty &#x3D; operands.top();\n+\t\toperands.pop();\n+\t&#125;\n\t\n\tx &#x3D; operands.top();\n\toperands.pop();\n\tswitch(history.top())&#123;\n\t\tcase &#39;+&#39;: return x+y;\n\t\tcase &#39;-&#39;: return x-y;\n\t\tcase &#39;*&#39;: return x*y;\n\t\tcase &#39;&#x2F;&#39;: return x&#x2F;y;\n\t\tcase &#39;^&#39;: return pow(x,y);\n\t\tcase &#39;L&#39;: return log(y)&#x2F;log(x);&#x2F;&#x2F;log c库的对数换底公式 \n        case &#39;S&#39;: return sin(y);\n\t\tcase &#39;C&#39;: return cos(y); \n\t&#125;\n\tprintf(&quot;Err&quot;);\n\treturn -1;\n&#125;</code></pre>\n\n\n\n<p>我们引用了<code>strchr(&quot;+-*/^L&quot;,history.top())</code>因此需要加入<code>#include&lt;string.h&gt;</code> </p>\n<p>问题解决</p>\n<h2 id=\"最终代码\"><a href=\"#最终代码\" class=\"headerlink\" title=\"最终代码\"></a>最终代码</h2><p>处理完毕后最终代码如下</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include&lt;stdio.h&gt;\n#include&lt;stack&gt;\n#include&lt;map&gt;\n#include&lt;math.h&gt;\ntypedef char oper;&#x2F;&#x2F;运算符\ntypedef float operand;\nstd::stack&lt;oper&gt; history;&#x2F;&#x2F;历史栈 \nstd::stack&lt;operand&gt; operands;\n\n&#x2F;*优先数表*&#x2F;\nstruct prv_num_t&#123;char left,right;&#125;;&#x2F;&#x2F;定义结构体 prv_num_t  _t代表类型 \n&#x2F;&#x2F;关键字只包含一部分数据项,就称为map\n&#x2F;&#x2F;关键字包含全部数据项,成为 \nstd::map&lt;oper, prv_num_t&gt; p_num&#x3D;&#123;\n\t&#123;&#39;+&#39;,&#123;81,82&#125;&#125;,\n\t&#123;&#39;-&#39;,&#123;81,82&#125;&#125;,\n\t&#123;&#39;*&#39;,&#123;41,42&#125;&#125;,\n\t&#123;&#39;&#x2F;&#39;,&#123;41,42&#125;&#125;,\n\t&#123;&#39;&#x3D;&#39;,&#123;100,100&#125;&#125;,\n\t&#123;&#39;^&#39;,&#123;32,31&#125;&#125;, \n\t&#123;&#39;L&#39;,&#123;22,21&#125;&#125;,&#x2F;&#x2F;对数运算符log(x,y) ；log (x,log(x,x)) ，右边优先 \n\t&#123;&#39;S&#39;,&#123;22,21&#125;&#125;,&#x2F;&#x2F;定义sin函数 \n\t&#123;&#39;C&#39;,&#123;22,21&#125;&#125;,&#x2F;&#x2F;定义cos函数; \n&#125;;\n\n\n&#x2F;*op1在左，op2在右*&#x2F;\n&#x2F;*返回值为负: op1优先级高于op2*&#x2F;\n&#x2F;*返回值为正: op2优先级高于op1*&#x2F;\n&#x2F;*返回值为0: op1优先级等于op2*&#x2F;\n\nint prior(oper op1, oper op2)&#123;\n\treturn p_num[op1].left - p_num[op2].right;\n&#125;\n\n#include&lt;string.h&gt;\noperand calc()&#123;\n\toperand x, y;\n&#x2F;&#x2F;\tif(history.top()是双目运算符)&#123;\n\tif(strchr(&quot;+-*&#x2F;^L&quot;,history.top()))&#123;&#x2F;&#x2F;strchr在 &quot;+-*&#x2F;^L&quot;找到 history.top()，如果找到返回位置，找不到返回空值【用来判断（整数和0）】 \n\t\ty &#x3D; operands.top();\n\t\toperands.pop();\n\t&#125;\n\tx &#x3D; operands.top();\n\toperands.pop();\n\tswitch(history.top())&#123;\n\t\tcase &#39;+&#39;: return x+y;\n\t\tcase &#39;-&#39;: return x-y;\n\t\tcase &#39;*&#39;: return x*y;\n\t\tcase &#39;&#x2F;&#39;: return x&#x2F;y;\n\t\tcase &#39;^&#39;: return pow(x,y);\n\t\tcase &#39;L&#39;: return log(y)&#x2F;log(x);&#x2F;&#x2F;log c库的对数换底公式\n\t\tcase &#39;S&#39;: return sin(y); \n\t\tcase &#39;C&#39;: return cos(y); \n\t&#125;\n\tprintf(&quot;Err&quot;);\n\treturn -1;\n&#125;\n\n\noperand solve()&#123;\n\toperand x, y;\n\toper op;\n\n\thistory.push(&#39;&#x3D;&#39;);&#x2F;&#x2F;输入等号，whach dog（士兵）进栈 \n\twhile(1)&#123;\n&#x2F;****************************************\n*2.  输入下一个运算符op;\n*3.  while（h.top()比op优先）&#123;\t栈顶元素出栈计算；&#125;\n*4.  if(h.top()&#x3D;&#x3D;&#39;&#x3D;&#39;&amp;&amp; op&#x3D;&#x3D;&#39;&#x3D;&#39;)&#123;结束&#125;\n*5.  h.push(op);\n*6.  转2。\n******************************************&#x2F;\n\tscanf(&quot; %c&quot;,&amp;op);&#x2F;&#x2F;预读下一位数 \n&#x2F;&#x2F;\tif(op是数字)\n\tif(isdigit(op)) &#123;&#x2F;&#x2F;isdigiy判断是否是数字 \n\t\tungetc(op, stdin);&#x2F;&#x2F;还回字符 ,还给stdin（键盘） \n\t\tscanf(&quot;%f&quot;,&amp;x);\n\t\toperands.push(x);\n\t\tcontinue; \n\t&#125;\t\n\t\twhile(prior(history.top(), op)&lt;0)&#123;\n\t\t\toperands.push(calc());\n\t\t\thistory.pop();\n\t\t&#125;\n\t\tif(prior(history.top(),op)&#x3D;&#x3D;0) break;\n\t\thistory.push(op);\n\t&#125;\n\treturn operands.top();\n&#125;\n\nint main()&#123;\n\tprintf(&quot;%g\\n&quot;,solve());\n\t\n\treturn 0;\n&#125;\n </code></pre>\n\n","text":"前段时间我们学习了利用stack实现五种运算符的运算：【实例】表达式求值——利用stack实现五种运算符的运算 | 《课程设计》笔记 (i-nmb.cn) 实际上我们的表达式求值中并不是只有这5种运算，他还包括了 指数、对数以及三角函数等等。 今天我们就在原基础上逐一的实现 指数...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[],"tags":[{"name":"运算符","slug":"运算符","count":3,"path":"api/tags/运算符.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2\"><span class=\"toc-text\">写在前面</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E7%9B%AE%E6%A0%87\"><span class=\"toc-text\">实现目标</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">1.优化代码</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%A2%9E%E5%8A%A0%E6%8C%87%E6%95%B0%E8%BF%90%E7%AE%97%E5%92%8C%E5%AF%B9%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">2.增加指数运算和对数运算符</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A2%9E%E5%8A%A0%E6%8C%87%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">增加指数运算符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A2%9E%E5%8A%A0%E5%AF%B9%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">增加对数运算符</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E5%A2%9E%E5%8A%A0%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%EF%BC%88%E5%8D%95%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89\"><span class=\"toc-text\">3.增加三角函数（单目运算符）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%86%B2%E7%AA%81\"><span class=\"toc-text\">冲突</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F%E4%B8%8D%E5%90%8C%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95\"><span class=\"toc-text\">一、输入模式不同的解决办法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E8%BF%90%E7%AE%97%E6%A8%A1%E5%BC%8F%E4%B8%8D%E5%90%8C%E7%9A%84%E8%A7%A3%E5%86%B3\"><span class=\"toc-text\">二、运算模式不同的解决</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95\"><span class=\"toc-text\">解决办法</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%80%E7%BB%88%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">最终代码</span></a></li></ol>","author":{"name":"ACbug","slug":"blog-author","avatar":"https://img1.i-nmb.cn/ava.png","link":"/","description":"西北民族大学数学与计算机科学学院<br>系统与软件工作室网络安全组","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"【实例1の更新2】表达式求值——加入括号运算","uid":"fe68a41eeb4610b86a3bfb5b3b4407ee","slug":"example-optimization-2","date":"2022-05-24T11:20:52.000Z","updated":"2022-06-19T13:58:03.129Z","comments":true,"path":"api/articles/example-optimization-2.json","keywords":null,"cover":[],"text":"前段时间我们制作了一个表达式求值的程序， 我们赋予他基本框架与功能：【实例】表达式求值——利用stack实现五种运算符的运算 | 《课程设计》笔记 (i-nmb.cn) 以及更新了一目运算符的支持：【实例更新】表达式求值——加入新的单目运算符 | 《课程设计》笔记 (i-nmb....","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[],"tags":[{"name":"运算符","slug":"运算符","count":3,"path":"api/tags/运算符.json"}],"author":{"name":"ACbug","slug":"blog-author","avatar":"https://img1.i-nmb.cn/ava.png","link":"/","description":"西北民族大学数学与计算机科学学院<br>系统与软件工作室网络安全组","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"【实例1】表达式求值——利用stack实现五种运算符的运算","uid":"2ee39bc7ef8592ef83ca72fba476f564","slug":"example","date":"2022-05-22T15:38:33.000Z","updated":"2022-06-19T13:56:45.212Z","comments":true,"path":"api/articles/example.json","keywords":null,"cover":[],"text":"看了标题有人会问，运算符的运算实现？直接printf(“%d”,a+b*c);不就完了么？ 当然没有那么简单！ 本篇带读者走进如何用stack来实现加减乘除运算 [原则：没有解决方案之前绝不能试图开始编程]在我们拿到题目后，有些读者习惯于直接开始敲代码，我觉得这样不方便思路的养成...","link":"","photos":[],"count_time":{"symbolsCount":"8.1k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"运算符","slug":"运算符","count":3,"path":"api/tags/运算符.json"}],"author":{"name":"ACbug","slug":"blog-author","avatar":"https://img1.i-nmb.cn/ava.png","link":"/","description":"西北民族大学数学与计算机科学学院<br>系统与软件工作室网络安全组","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}