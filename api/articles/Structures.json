{"title":"《数据结构》知识总结","uid":"1b543e84ac41cc09af328e6f7689b488","slug":"Structures","date":"2022-05-13T15:03:29.000Z","updated":"2022-05-14T14:36:51.050Z","comments":true,"path":"api/articles/Structures.json","keywords":null,"cover":[],"content":"<p>参考视频：<a href=\"https://www.bilibili.com/video/BV1vS4y1Z7nY?spm_id_from=333.880.my_history.page.click\">速成数据结构与算法-【期末不挂科】_哔哩哔哩_bilibili</a></p>\n<h2 id=\"数据结构和算法\"><a href=\"#数据结构和算法\" class=\"headerlink\" title=\"数据结构和算法\"></a>数据结构和算法</h2><h3 id=\"1-数据结构\"><a href=\"#1-数据结构\" class=\"headerlink\" title=\"1.数据结构\"></a>1.数据结构</h3><p>1）数据:\t\t\t\t对客观事物的符号表示\t\t图像、声音等</p>\n<p>2）数据元素:\t\t数据的基本单位\t\t\t\t\t学生的信息记录</p>\n<p>3）数据项:\t\t\t构成数据元素的不可分割的最小单位</p>\n<p>​\t\t\t\t\t\t\t\t一个数据元素可由若干个数据项组成\t\t学号、姓名、性别等</p>\n<p>(4）数据对象:\t\t具有相同性质的数据元素的集合<br>(5）数据结构:\t\t相互之间存在一种或多种特定关系的数据元素的集合</p>\n<p>​\t\t\t\t\t\t\t\t逻辑结构、存储结构和数据的运算<br>​\t\t\t\t\t\t\t\tData_ Structure&#x3D;(D,S)</p>\n<p>自我理解如图</p>\n<p><img src=\"https://img1.i-nmb.cn/img/image-20220514003144582.png\" alt=\"自我理解\"></p>\n<p>例题如下</p>\n<img src=\"https://img1.i-nmb.cn/img/image-20220514003256363.png\" alt=\"例题\" style=\"zoom:40%;\" />\n\n\n\n<h4 id=\"逻辑结构\"><a href=\"#逻辑结构\" class=\"headerlink\" title=\"逻辑结构\"></a>逻辑结构</h4><p>逻辑结构分为<strong>线性结构</strong>和<strong>非线性结构</strong>，其中非线性结构还分有<u>集合、树形结构、图形结构或网状结构</u></p>\n<img src=\"https://img1.i-nmb.cn/img/image-20220514003429202.png\" alt=\"数据结构包含\" style=\"zoom:40%;\" />\n\n\n\n<p>例题：</p>\n<img src=\"https://img1.i-nmb.cn/img/image-20220514003802432.png\" alt=\"例题\" style=\"zoom:40%;\" />\n\n<img src=\"https://img1.i-nmb.cn/img/image-20220514003853826.png\" alt=\"例题\" style=\"zoom:70%;\" />\n\n\n\n<h4 id=\"存储结构\"><a href=\"#存储结构\" class=\"headerlink\" title=\"存储结构\"></a>存储结构</h4><p>存储结构【区别于存取】大致有：<strong>顺序存储、链式存储、索引存储、散列存储</strong></p>\n<img src=\"https://img1.i-nmb.cn/img/image-20220514004010594.png\" alt=\"存储结构\" style=\"zoom:65%;\" />\n\n\n\n<p>在顺序存储、链式存储、索引存储和散列存储这4种存储方式中，<u>最基本、最常用</u>的两种存储结构是<strong>顺序结构、链式结构</strong></p>\n<h3 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h3><p>算法是对特定问题求解步骤的一种描述</p>\n<h4 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h4><p><strong>算法应该具有的以下特性</strong></p>\n<p>(1）有穷性\t\t有穷步骤有穷时间</p>\n<p>(2）确定性</p>\n<p>(3）可行性</p>\n<p>(4）输入\t\t\t一个算法有零个或多个输入</p>\n<p>(5）输出\t\t\t一个算法有一个或多个输出</p>\n<p>【例题】</p>\n<p>以下不属于算法特性的是（)</p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> A.可行性\t\t\t\t</li>\n<li><input disabled=\"\" type=\"checkbox\"> B.输入\t\t\t\t</li>\n<li><input disabled=\"\" type=\"checkbox\"> C.确定性\t\t\t\t</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> D.健壮性</li>\n</ul>\n<p>通常设计一个<strong>“好”的算法应考虑达到以下目标</strong>:</p>\n<p>(1）正确性</p>\n<p>(2）可读性</p>\n<p>(3）健壮性</p>\n<p>(4）效率与低存储量需求</p>\n<h4 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><p>算法效率的度量是通过时间复杂度和空间复杂度来描述的频度该语句在算法中被<strong>重复执行的次数</strong></p>\n<p>算法中所有语句的频度之和T(n)&#x3D;O(fn))</p>\n<p>若一个算法中的语句频度之和为T(n)&#x3D;n＋4n log2n，则算法的时间复杂度为O(nlog2n)<br>加法规则:<br>$$<br>T(n)&#x3D;T(n)＋T,(n)&#x3D;O(f(n))+O(g(n))&#x3D;O(max (f(n),g(m)))<br>$$<br>乘法规则:<br>$$<br>T(n)&#x3D;T (n)×T,(n)&#x3D;O(f(n))×O(g(n))&#x3D;O(f(n)×g(n))<br>$$<br>常见的渐近时间复杂度为<br>$$<br>O(1)&lt;O(log2n)&lt;O(n)&lt;O(nlog2n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)<br>$$<br>【例题】</p>\n<img src=\"https://img1.i-nmb.cn/img/image-20220514010348535.png\" alt=\"image-20220514010348535\" style=\"zoom:50%;\" />\n\n\n\n\n\n\n\n<h2 id=\"线性表\"><a href=\"#线性表\" class=\"headerlink\" title=\"线性表\"></a>线性表</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>线性表：具有<u><strong>相同数据类型</strong></u>的n(n≥0)个数据元素的**<u>有限序列</u>**<br>$$<br>L&#x3D;(a,a₂,…,a，aᵢ₊₁，…，aₙ)<br>$$<br>除第一个元素外，每个元素<strong>有且仅有</strong>一个直接前驱</p>\n<p>除最后一个元素外，每个元素<strong>有且仅有</strong>一个直接后继</p>\n<h3 id=\"线性表的基本操作\"><a href=\"#线性表的基本操作\" class=\"headerlink\" title=\"线性表的基本操作\"></a>线性表的基本操作</h3><p>线性表的基本操作:</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">InitList(&amp;L);\t\t\t&#x2F;&#x2F;初始化表\nLength(L);\t\t\t\t&#x2F;&#x2F;求表长\nLocateElem(L,e);\t\t&#x2F;&#x2F;按值查找操作\nGetElem(L,i);\t\t\t&#x2F;&#x2F;按位查找操作\nListInsert(&amp;L,i,e);\t\t&#x2F;&#x2F;插入操作\nListDelete(&amp;L,i,&amp;e);\t&#x2F;&#x2F;删除操作\nPrintList(L);\t\t\t&#x2F;&#x2F;输出操作\nEmpty(L);\t\t\t\t&#x2F;&#x2F;判空操作\nDestroyList(&amp;L);\t\t&#x2F;&#x2F;销毁操作</code></pre>\n\n\n\n<h3 id=\"线性表的结构\"><a href=\"#线性表的结构\" class=\"headerlink\" title=\"线性表的结构\"></a>线性表的结构</h3><p>线性表采用顺序存储结构表示时,必须占用一片<u>连续的存储单元</u></p>\n<p>顺序表是由一组地址<strong>连续的存储单元</strong>依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在<u>物理位置上也相邻</u></p>\n<p>如果一个顺序表中第一个元素的存储地址为1000,每个元素占4个地址单元，那么第6个元素的存储地址应是（)</p>\n<ul>\n<li><p><input checked=\"\" disabled=\"\" type=\"checkbox\"> \nA.1020</p>\n</li>\n<li><p><input disabled=\"\" type=\"checkbox\"> \nB.1010</p>\n</li>\n<li><p><input disabled=\"\" type=\"checkbox\"> \nC.1016</p>\n</li>\n<li><p><input disabled=\"\" type=\"checkbox\"> \nD.1024</p>\n<p>$$<br>LOC(A)+sizeof (ElemType)*(i-1)<br>$$</p>\n<pre class=\"line-numbers language-wolfram\" data-language=\"wolfram\"><code class=\"language-wolfram\">1000＋(6—1)*4&#x3D;1020</code></pre></li>\n</ul>\n<h3 id=\"顺序表的特点\"><a href=\"#顺序表的特点\" class=\"headerlink\" title=\"顺序表的特点\"></a>顺序表的特点</h3><p>顺序表的特点:<br>(1)顺序表最主要的特点是<strong>随机存取</strong>，即通过首地址和元素序号可在时间O(1)内找到指定的元素</p>\n<p>(2)顺序表的<strong>存储密度高</strong>，每个结点只存储数据元素</p>\n<p>(3)顺序表逻辑上相邻的元素<strong>物理上也相邻</strong>，所以<u>插入和删除操作需要移动大量元素</u></p>\n<h3 id=\"顺序表的实现\"><a href=\"#顺序表的实现\" class=\"headerlink\" title=\"顺序表的实现\"></a>顺序表的实现</h3><img src=\"https://img1.i-nmb.cn/img/image-20220514013011339.png\" alt=\"image-20220514013011339\" style=\"zoom:50%;\" />\n\n\n\n<p>【例题】在长度为n的顺序表的第i个位置上插入一个元素(1≤i≤n＋i)，元素的移动次数为（  )</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> A. n - i＋1</li>\n<li><input disabled=\"\" type=\"checkbox\"> B. n - i</li>\n<li><input disabled=\"\" type=\"checkbox\"> C. i</li>\n<li><input disabled=\"\" type=\"checkbox\"> D. i - 1</li>\n</ul>\n<img src=\"https://img1.i-nmb.cn/img/image-20220514013607711.png\" alt=\"image-20220514013607711\" style=\"zoom:50%;\" />\n\n<p>【例题】设顺序线性表中有n个数据元素，则删除表中第i个元素需要移动（）个元素</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> A. n - i</li>\n<li><input disabled=\"\" type=\"checkbox\"> B. n - i - 1</li>\n<li><input disabled=\"\" type=\"checkbox\"> C. n - i＋1</li>\n<li><input disabled=\"\" type=\"checkbox\"> D. i</li>\n</ul>\n<p>【例题】题3.对于顺序存储的线性表，访问结点和增加、删除结点的时间复杂度为（ )</p>\n<ul>\n<li><p><input disabled=\"\" type=\"checkbox\"> \nA. O(n),O(n)</p>\n</li>\n<li><p><input disabled=\"\" type=\"checkbox\"> \nB. O(n),O(1)</p>\n</li>\n<li><p><input disabled=\"\" type=\"checkbox\"> \nC. O(1),O(n)</p>\n</li>\n<li><p><input disabled=\"\" type=\"checkbox\"> \nD. O(1),0(1)</p>\n<p>顺序表最主要的特点是随机存取，即通过首地址和元素序号可在时间O(1)内找到指定的元素</p>\n<p>增加、删除结点的时间复杂度为O(n)</p>\n</li>\n</ul>\n<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><h3 id=\"单链表的结构\"><a href=\"#单链表的结构\" class=\"headerlink\" title=\"单链表的结构\"></a>单链表的结构</h3><p>单链表:链式存储的线性表</p>\n<img src=\"https://img1.i-nmb.cn/img/image-20220514014346639.png\" alt=\"image-20220514014346639\" style=\"zoom:50%;\" />\n\n<p>不带头结点</p>\n<img src=\"https://img1.i-nmb.cn/img/image-20220514014430889.png\" alt=\"image-20220514014430889\" style=\"zoom:50%;\" />\n\n<p>带头结点</p>\n<img src=\"https://img1.i-nmb.cn/img/image-20220514014453988.png\" alt=\"image-20220514014453988\" style=\"zoom:50%;\" />\n\n<p>【例题】</p>\n<img src=\"https://img1.i-nmb.cn/img/image-20220514014537681.png\" alt=\"image-20220514014537681\" style=\"zoom:50%;\" />\n\n<img src=\"https://img1.i-nmb.cn/img/image-20220514014601986.png\" alt=\"image-20220514014601986\" style=\"zoom:50%;\" />\n\n<h4 id=\"单链表的实现（操作）\"><a href=\"#单链表的实现（操作）\" class=\"headerlink\" title=\"单链表的实现（操作）\"></a>单链表的实现（操作）</h4><img src=\"https://img1.i-nmb.cn/img/image-20220514015033908.png\" alt=\"image-20220514015033908\" style=\"zoom:50%;\" />\n\n\n\n<p>实现代码如下</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">LNode *GetElem(LinkList L,int i)&#123;\t\t&#x2F;&#x2F;LNode结点类型，函数名为GetElem，单链表L,查找第几位数（要求返回第ai位的值）\n\tint j&#x3D;1;\t\t\t\t\t\t\t&#x2F;&#x2F;计数用\n\tLNode *p&#x3D;L-&gt;next;\t\t\t\t\t&#x2F;&#x2F;设置指针p为第一个结点（L头结点的下一个结点是a1）\n    if(i&#x3D;&#x3D;0)\treturn L;\t\t\t\t&#x2F;&#x2F;如果i&#x3D;0，返回L值\n\tif(i&lt;0)\t\treturn NULL;\t\t\t&#x2F;&#x2F;如果i&lt;0，返回错误\n\twhile(p&amp;&amp;j&lt;i)&#123;\t\t\t\t\t\t&#x2F;&#x2F;p的值为是否为空&amp;&amp;j是否超过i\n\tp&#x3D;p-&gt;next;\tj＋+;\t\t\t\t\t&#x2F;&#x2F;指针往下\n\t&#125;\n\treturn p;\t\t\t\t\t\t\t&#x2F;&#x2F;p的值为为空（i定义过大）或 j等于i（找到），返回p所指的ai位记录的值\n&#125;</code></pre>\n\n<p>时间复杂度为O(n)</p>\n<p>【例题】</p>\n<img src=\"https://img1.i-nmb.cn/img/image-20220514020522842.png\" alt=\"image-20220514020522842\" style=\"zoom:50%;\" />\n\n\n\n<h4 id=\"插入结点\"><a href=\"#插入结点\" class=\"headerlink\" title=\"插入结点\"></a>插入结点</h4><img src=\"https://img1.i-nmb.cn/img/image-20220514020843740.png\" alt=\"插入结点\" style=\"zoom:50%;\" />\n\n\n\n<p>实现插入结点的代码如下:</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">p&#x3D;GetElem(L,i-1);\ns一&gt;next&#x3D;p一&gt;next;\np-&gt;next &#x3D;s;</code></pre>\n\n<p>【例题】</p>\n<img src=\"https://img1.i-nmb.cn/img/image-20220514021127185.png\" alt=\"image-20220514021127185\" style=\"zoom:67%;\" />\n\n<p>按照一步一步操作，选B，</p>\n<h4 id=\"删除结点\"><a href=\"#删除结点\" class=\"headerlink\" title=\"删除结点\"></a>删除结点</h4><img src=\"https://img1.i-nmb.cn/img/image-20220514022814237.png\" alt=\"image-20220514022814237\" style=\"zoom:80%;\" />\n\n<p>实现删除结点的代码片段如下:</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">p&#x3D;GetElem (L,i—1);\nq&#x3D;p-&gt;next;\t\t\t&#x2F;&#x2F;定义q为p的下一个\np-&gt;next&#x3D;q-&gt;next;\t&#x2F;&#x2F;把q的下一个（c）作为p的下一个\nfree(q);\t\t\t&#x2F;&#x2F;释放q</code></pre>\n\n\n\n<h3 id=\"双链表\"><a href=\"#双链表\" class=\"headerlink\" title=\"双链表\"></a>双链表</h3><img src=\"https://img1.i-nmb.cn/img/image-20220514023350216.png\" alt=\"image-20220514023350216\" style=\"zoom:67%;\" />\n\n<p>双链表比单链表多了前驱（prior）指针，指向前面一个元素</p>\n<h4 id=\"插入操作\"><a href=\"#插入操作\" class=\"headerlink\" title=\"插入操作\"></a>插入操作</h4><img src=\"https://img1.i-nmb.cn/img/image-20220514023623622.png\" alt=\"image-20220514023623622\" style=\"zoom:50%;\" />\n\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">s-&gt;next &#x3D; p-&gt;next;\t&#x2F;&#x2F;让x的下一个给b（p-&gt;next）\np-&gt;next-&gt;prior &#x3D; s;\t&#x2F;&#x2F;让b（p-&gt;next）的前驱为x\ns-&gt;prior &#x3D; p;\t\t&#x2F;&#x2F;让x的前驱为a\np-&gt;next &#x3D; s;\t\t&#x2F;&#x2F;让p的后续为x</code></pre>\n\n<p>上述代码不唯一，<strong>但是第一行代码和第二行代码必须在第四行之前</strong></p>\n<h4 id=\"删除操作\"><a href=\"#删除操作\" class=\"headerlink\" title=\"删除操作\"></a>删除操作</h4><img src=\"https://img1.i-nmb.cn/img/image-20220514024342565.png\" alt=\"image-20220514024342565\" style=\"zoom:50%;\" />\n\n<p>代码如下</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">p-&gt;next&#x3D;q-&gt;next;\t&#x2F;&#x2F;让p的后续等于c（q-&gt;next）\nq-&gt;next—&gt;prior&#x3D;p;\t&#x2F;&#x2F;让c的前驱（q-&gt;next—&gt;prior）指向p\nfree(q);\t\t\t&#x2F;&#x2F;释放q</code></pre>\n\n\n\n<h3 id=\"循环列表\"><a href=\"#循环列表\" class=\"headerlink\" title=\"循环列表\"></a>循环列表</h3><img src=\"https://img1.i-nmb.cn/img/image-20220514024746327.png\" alt=\"image-20220514024746327\" style=\"zoom:50%;\" />\n\n<p>【例题】</p>\n<img src=\"https://img1.i-nmb.cn/img/image-20220514024830857.png\" alt=\"image-20220514024830857\" style=\"zoom:50%;\" />\n\n<p>由于</p>\n<p><img src=\"https://img1.i-nmb.cn/img/image-20220514024920444.png\" alt=\"image-20220514024920444\"></p>\n<p>所以本题选C</p>\n<img src=\"https://img1.i-nmb.cn/img/image-20220514025022685.png\" alt=\"image-20220514025022685\" style=\"zoom:80%;\" />\n\n\n\n<h2 id=\"栈和队列\"><a href=\"#栈和队列\" class=\"headerlink\" title=\"栈和队列\"></a>栈和队列</h2><h3 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h3><img src=\"https://img1.i-nmb.cn/img/v2-9b87a58683013d2cf04b3626926c60ab_1440w.jpg\" alt=\"img\" style=\"zoom:67%;\" />\n\n<p>栈:只允许在一端进行插入或删除操作的线性表<br>    栈顶\t\t栈底</p>\n<p><strong>初始化</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">Status lnitStack(SqStack &amp;s ,int MAXSIZE )&#123;\n\nS. base &#x3D;new SElemType[MAXSIZE];\n\nif( !S. base ) return OVERFLOW;\n\nS.top &#x3D; S. base;\n\nS.stacksize &#x3D; MAXSIZE;\n\nreturn OK;\n&#125;</code></pre>\n\n\n\n<p>空栈:不含任何元素的空表</p>\n<p>特性:先进后出</p>\n<img src=\"https://img1.i-nmb.cn/img/image-20220514132533777.png\" alt=\"image-20220514132533777\" style=\"zoom:67%;\" />\n\n\n\n\n\n<p>限定仅在表尾进行插入和删除操作的线性表称为 <u>栈</u> ,它的修改是按<strong>先进后出</strong>的原则进行的</p>\n<p>【例题】若进栈序列为a,b,c，则通过入栈操作可能得到的a,b,c出栈的不同排列个数（)<br>                A.4\t\t\tB.5\t\t\tC.6\t\t\tD.7</p>\n<p>n个不同元素进栈,出栈元素不同排列的个数为</p>\n<img src=\"https://img1.i-nmb.cn/img/image-20220514142311478.png\" alt=\"image-20220514142311478\" style=\"zoom:50%;\" />\n\n<p>所以选B.5</p>\n<h3 id=\"栈的存储结构\"><a href=\"#栈的存储结构\" class=\"headerlink\" title=\"栈的存储结构\"></a>栈的存储结构</h3><h4 id=\"顺序栈的实现\"><a href=\"#顺序栈的实现\" class=\"headerlink\" title=\"顺序栈的实现\"></a>顺序栈的实现</h4><p><img src=\"https://img1.i-nmb.cn/img/image-20220514142944195.png\" alt=\"image-20220514142944195\"></p>\n<p>栈的顺序存储类型可描述为:</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define MaxSize 50\ntypedef struct &#123;\n  ElemType data[MaxSize];\n  int top;\n&#125; SqStack;</code></pre>\n\n<h4 id=\"顺序栈的基本运算\"><a href=\"#顺序栈的基本运算\" class=\"headerlink\" title=\"顺序栈的基本运算\"></a>顺序栈的基本运算</h4><p>1.初始化</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void InitStack (SqStack &amp;S)&#123;\nS.top &#x3D; -1;\n&#125;</code></pre>\n\n<p>2.判栈空</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">bool StackEmpty (SqStack &amp;S)&#123;\nif(S.top &#x3D;&#x3D; -1)\n  return true;\nelse\n  return false;\n&#125;</code></pre>\n\n<p>3.进栈：栈不满时，栈顶指针先加1，再送值到栈顶元素</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">bool Push(SqStack &amp;S, ElemType x)&#123;\n  if(S.top &#x3D;&#x3D; MaxSize-1)\n    return false;\n  S.data[++S.top]&#x3D;x;\n  return true;\n&#125;</code></pre>\n\n<p>或</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">Status Push( SqStack &amp;s, SElemType e)\n\n&#123; \n  if( S.top - S.base&#x3D;&#x3D; S.stacksize )\n    return ERROR;\n  *S.top++&#x3D;e;\n  return OK;\n&#125;</code></pre>\n\n<p>4.取栈顶元素:</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">Status Pop(SqStack &amp;S,SElemType &amp;e)\n&#123;\n  if( S.top &#x3D;&#x3D; S.base ) &#x2F;&#x2F;栈空\n  return ERROR;\n  e&#x3D;*--S.top;\t\t\t&#x2F;&#x2F;e为原指针下一个，并且原指针--\n  return OK;&#125;\n</code></pre>\n\n<p>5.求栈长度:</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">int StackLength( SqStack S )&#123;\n  return(S.top - S. base) ;\n&#125;\n\n</code></pre>\n\n\n\n<h3 id=\"链栈\"><a href=\"#链栈\" class=\"headerlink\" title=\"链栈\"></a>链栈</h3><img src=\"https://img1.i-nmb.cn/img/image-20220514204239075.png\" alt=\"image-20220514204239075\" style=\"zoom:50%;\" />\n\n\n\n<img src=\"https://img1.i-nmb.cn/img/image-20220514204751258.png\" alt=\"image-20220514204751258\" style=\"zoom:50%;\" />\n\n\n\n<img src=\"https://img1.i-nmb.cn/img/image-20220514204836960.png\" alt=\"image-20220514204836960\" style=\"zoom:50%;\" />\n\n\n\n<h3 id=\"队列的基本概念\"><a href=\"#队列的基本概念\" class=\"headerlink\" title=\"队列的基本概念\"></a>队列的基本概念</h3><p>队列:\t\t队，只允许在表的一端进行插入，而在表的另一端进行删除<br>入队或进队<br>出队或离队<br>特性:\t\t先进先出</p>\n<img src=\"https://img1.i-nmb.cn/img/image-20220514205235637.png\" alt=\"image-20220514205235637\" style=\"zoom:50%;\" />\n\n<p>题1.队列是一种操作受限的线性表,它与栈不向的是,队列中所有的插入操作均限制在表的一段进行，而所有的删除操作都限制在表的另一端进行,允许插入的一端称为<u>队尾</u>，允许删除的一端称为<u>对头（对首）</u>，队列具有<u>先进先出</u>的特点</p>\n","text":"参考视频：速成数据结构与算法-【期末不挂科】_哔哩哔哩_bilibili 数据结构和算法1.数据结构1）数据: 对客观事物的符号表示 图像、声音等 2）数据元素: 数据的基本单位 学生的信息记录 3）数据项: 构成数据元素的不可分割的最小单位 ​ 一个数据元素可由若干个数据项组成...","link":"","photos":[],"count_time":{"symbolsCount":"5.2k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"-数据结构","slug":"数据结构","count":1,"path":"api/tags/数据结构.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">数据结构和算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">1.数据结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">逻辑结构</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">存储结构</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">特性</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A4%8D%E6%9D%82%E5%BA%A6\"><span class=\"toc-text\">复杂度</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E6%80%A7%E8%A1%A8\"><span class=\"toc-text\">线性表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">定义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">线性表的基本操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">线性表的结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">顺序表的特点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">顺序表的实现</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">链表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">单链表的结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%93%8D%E4%BD%9C%EF%BC%89\"><span class=\"toc-text\">单链表的实现（操作）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8F%92%E5%85%A5%E7%BB%93%E7%82%B9\"><span class=\"toc-text\">插入结点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9\"><span class=\"toc-text\">删除结点</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%8C%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">双链表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">插入操作</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">删除操作</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BE%AA%E7%8E%AF%E5%88%97%E8%A1%A8\"><span class=\"toc-text\">循环列表</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97\"><span class=\"toc-text\">栈和队列</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%88\"><span class=\"toc-text\">栈</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%88%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">栈的存储结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">顺序栈的实现</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97\"><span class=\"toc-text\">顺序栈的基本运算</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%93%BE%E6%A0%88\"><span class=\"toc-text\">链栈</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">队列的基本概念</span></a></li></ol></li></ol>","author":{"name":"ACbug","slug":"blog-author","avatar":"https://img1.i-nmb.cn/ava.png","link":"/","description":"西北民族大学数学与计算机科学学院<br>系统与软件工作室网络安全组","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"STL 线性结构","uid":"85b9560fd5f89937d71ee469baf4d06b","slug":"STL-linear-structure","date":"2022-05-22T04:55:33.000Z","updated":"2022-06-19T13:56:20.443Z","comments":true,"path":"api/articles/STL-linear-structure.json","keywords":null,"cover":[],"text":"问题引入如何输出6的二进制数？ 分析问题问题-&gt;解决方案-&gt;实现方案-&gt;编写 即 从问题得到解决方案（解决方案（具体步骤（过程可以问专业专家））） 实现方案有哪几种方法，并进行优化 编写代码 解决方案整数十进制整数转换为二进制整数采用”除2取余，逆序排列”法。 ...","link":"","photos":[],"count_time":{"symbolsCount":"5.2k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"线性结构","slug":"线性结构","count":1,"path":"api/tags/线性结构.json"}],"author":{"name":"ACbug","slug":"blog-author","avatar":"https://img1.i-nmb.cn/ava.png","link":"/","description":"西北民族大学数学与计算机科学学院<br>系统与软件工作室网络安全组","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"懒加载(lazyload/lozad)和Valine评论系统的头像、表情冲突","uid":"fbf2013fd372815138afff9263093bc8","slug":"lazyload-bug","date":"2022-05-12T13:49:09.000Z","updated":"2022-05-12T15:44:38.743Z","comments":true,"path":"api/articles/lazyload-bug.json","keywords":null,"cover":[],"text":"问题现象在使用lozad.js的情况下，同时使用了Valine评论系统，就会出现头像、表情不显示的问题。百度也一直找不到问题所在。 如图 问题分析在F12开发者工具下，看到所有的src变成了data-src，导致了src没有数据 查看代码，发现他把src一律转换成了data-sr...","link":"","photos":[],"count_time":{"symbolsCount":"4.9k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"hexo","slug":"hexo","count":5,"path":"api/tags/hexo.json"},{"name":"NexT","slug":"NexT","count":5,"path":"api/tags/NexT.json"},{"name":"lozad","slug":"lozad","count":1,"path":"api/tags/lozad.json"},{"name":"Valine","slug":"Valine","count":1,"path":"api/tags/Valine.json"}],"author":{"name":"ACbug","slug":"blog-author","avatar":"https://img1.i-nmb.cn/ava.png","link":"/","description":"西北民族大学数学与计算机科学学院<br>系统与软件工作室网络安全组","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}