{"title":"STL 线性结构","uid":"85b9560fd5f89937d71ee469baf4d06b","slug":"STL-linear-structure","date":"2022-05-22T04:55:33.000Z","updated":"2022-06-19T13:56:20.443Z","comments":true,"path":"api/articles/STL-linear-structure.json","keywords":null,"cover":[],"content":"<h2 id=\"问题引入\"><a href=\"#问题引入\" class=\"headerlink\" title=\"问题引入\"></a>问题引入</h2><p>如何输出6的二进制数？</p>\n<h2 id=\"分析问题\"><a href=\"#分析问题\" class=\"headerlink\" title=\"分析问题\"></a>分析问题</h2><p><strong>问题-&gt;解决方案-&gt;实现方案-&gt;编写</strong></p>\n<p>即</p>\n<p>从问题得到解决方案（解决方案（具体步骤（过程可以问专业专家）））</p>\n<p>实现方案有哪几种方法，并进行优化</p>\n<p>编写代码</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><h3 id=\"整数\"><a href=\"#整数\" class=\"headerlink\" title=\"整数\"></a>整数</h3><p><strong>十进制整数转换为二进制整数采用”除2取余，逆序排列”法。</strong></p>\n<p>具体做法是：用2整除十进制整数，可以得到一个商和余数；再用2去除商，又会得到一个商和余数，如此进行，直到商为小于1时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。</p>\n<h2 id=\"实现方案\"><a href=\"#实现方案\" class=\"headerlink\" title=\"实现方案\"></a>实现方案</h2><h3 id=\"一、使用stack【栈】输出\"><a href=\"#一、使用stack【栈】输出\" class=\"headerlink\" title=\"一、使用stack【栈】输出\"></a>一、使用stack【栈】输出</h3><p>因为 <u>将得到的余数作为二进制数的高位有效位依次排列起来</u> 的过程需要后进先出，所以我们使用栈进行输出</p>\n<p>老师给出代码如下</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include&lt;cstdio&gt;\n#include&lt;list&gt;\n#include&lt;stack&gt;\nmain()&#123;\n\tstd::list&lt;int&gt; q; &#x2F;&#x2F;定义（双向）链表（被除数q） \t\t\t#include&lt;list&gt;\n\tstd::stack&lt;int&gt; r;&#x2F;&#x2F;定义栈（余数r）\t\t\t\t\t#include&lt;stack&gt;\n\tint n;\n\tscanf(&quot;%d&quot;,&amp;n);\n\twhile(n!&#x3D;0)&#123;\n\t\tq.push_back(n&#x2F;2);\t&#x2F;&#x2F;push_back链表的后面插入  \n\t\tr.push(n%2); \t\t&#x2F;&#x2F;push余数压入栈 \n\t\tn&#x3D;n&#x2F;2;\n\t&#125; \n\twhile(!r.empty())&#123;\t&#x2F;&#x2F; empty()只返回真假值，栈空返回1，否则返回0 \n\tprintf(&quot;%d&quot;,r.top());&#x2F;&#x2F;top有返回值，而pop没有返回值 ，&#x2F;&#x2F;用stack倒叙输出 \n\tr.pop();\t\t\n\t&#125;\n\treturn 0;\n&#125;</code></pre>\n\n\n\n<p>其中<code>std::list&lt;int&gt; q;</code> 定义（双向）<strong>链表</strong> 来记录<u>商q</u>；<code>std::stack&lt;int&gt; r</code> 定义 <strong>栈</strong> 来记录<u>余数r</u>，定义n来表示操作数（要变为2进制的数）</p>\n<p>利用循环1来“压进”处理的数据：将<strong>商</strong>压进 链表的后面（<code>q.push_back(n/2)</code>）；将余数 压入栈 <code>r.push(n%2);</code> ；随后将n&#x2F;2向下取整（int型）</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">while(n!&#x3D;0)&#123;\n\t\tq.push_back(n&#x2F;2);\t&#x2F;&#x2F;push_back链表的后面插入  \n\t\tr.push(n%2); \t\t&#x2F;&#x2F;push余数压入栈 \n\t\tn&#x3D;n&#x2F;2;\n&#125; </code></pre>\n\n\n\n\n\n<p>利用循环2来输出：将 压入栈 <code>r.push(n%2);</code>  的元素从栈顶输出<code>printf(&quot;%d&quot;,r.top());</code>随后销毁栈顶元素[目的是为了让下一个元素输出]<code>r.pop();</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">while(!r.empty())&#123;\t&#x2F;&#x2F; empty()只返回真假值，栈空返回1，否则返回0 \n\tprintf(&quot;%d&quot;,r.top());&#x2F;&#x2F;top有返回值，而pop没有返回值 ，&#x2F;&#x2F;用stack倒叙输出 \n\tr.pop();\t\t\n&#125;</code></pre>\n\n\n\n<h4 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h4><p>我们发现，在输出时候，我们并没有输出双向链表<code>std::list&lt;int&gt; q;</code>，</p>\n<p>所以我们可以判断，双向链表是多余的，需要优化（但是思考实现方案的时候不能不考虑到双向链表）</p>\n<p>我们把list相关代码删除（或注释）</p>\n<p>得到</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include&lt;cstdio&gt;\n&#x2F;&#x2F;#include&lt;list&gt;\n#include&lt;stack&gt;\nmain()&#123;\n&#x2F;&#x2F;\tstd::list&lt;int&gt; q; &#x2F;&#x2F;定义（双向）链表（被除数q） \t#include&lt;list&gt;\n\tstd::stack&lt;int&gt; r;&#x2F;&#x2F;定义栈（余数r）\t\t\t\t\t#include&lt;stack&gt;\n\tint n;\n\tscanf(&quot;%d&quot;,&amp;n);\n\twhile(n!&#x3D;0)&#123;\n\t&#x2F;&#x2F;\tq.push_back(n&#x2F;2);商（不用输出）\t&#x2F;&#x2F;push_back链表的后面插入  \n\t\tr.push(n%2); \t\t&#x2F;&#x2F;push余数压入栈 \n\t\tn&#x3D;n&#x2F;2;\n\t&#125; \n\twhile(!r.empty())&#123;\t&#x2F;&#x2F; empty()只返回真假值，栈空返回1，否则返回0 \n\tprintf(&quot;%d&quot;,r.top());&#x2F;&#x2F;top有返回值，而pop没有返回值 ，&#x2F;&#x2F;用stack倒叙输出 \n\tr.pop();\t\t\n\t&#125;\n\treturn 0;\n&#125;</code></pre>\n\n\n\n\n\n<h3 id=\"二、使用list【链式存储】输出\"><a href=\"#二、使用list【链式存储】输出\" class=\"headerlink\" title=\"二、使用list【链式存储】输出\"></a>二、使用list【链式存储】输出</h3><p>具有三种实现list输出方案：</p>\n<h4 id=\"1）使用r-push-back-n-2-加上reverse\"><a href=\"#1）使用r-push-back-n-2-加上reverse\" class=\"headerlink\" title=\"1）使用r.push_back(n%2);加上reverse\"></a>1）使用r.push_back(n%2);加上reverse</h4><p>因为 <u>将得到的余数作为二进制数的高位有效位依次排列起来</u> 的过程需要后进先出，若我们需要使用list【链式存储】输出，要先将链式存储的顺序进行交换</p>\n<p>那么我们需要用到的是reverse函数，具体代码如下</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include&lt;cstdio&gt;\n#include&lt;list&gt;\nmain()&#123;\n\tstd::list&lt;int&gt; r;\n\tint n;\n\tscanf(&quot;%d&quot;,&amp;n);\n\twhile(n!&#x3D;0)&#123;\t \n\t\tr.push_back(n%2);\n\t\tn&#x3D;n&#x2F;2;\n\t&#125; \n\t\n\n\treverse(r.begin(),r.end());&#x2F;&#x2F;【或者】r.reverse;\n    &#x2F;&#x2F;auto *i;auto:自动类型推倒&#x2F;&#x2F;std::list&lt;int&gt;::iterator ;\n\tfor(auto i&#x3D;r.begin();i!&#x3D;r.end();++i)\n\t\tprintf(&quot;%d&quot;,*i) ;\n\treturn 0;\n\n&#125;</code></pre>\n\n<p>其中<code>reverse(r.begin(),r.end());</code>为交换顺序函数，将链表排序颠倒（1,2,3-&gt;3,2,1）</p>\n<p>在输出时，我们要用到类似指针的<code>i</code>，但是它的类型我们并不知道（或者不想写），那么我们使用<code>auto i</code>，让编译器自动识别</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>不过在使用时需要如下配置</p>\n<p><img src=\"https://img1.i-nmb.cn/img/image-20220522134832991.png\" alt=\"编译时加入以下命令\"></p></blockquote>\n<h4 id=\"2）使用r-push-back-n-2-利用属性改为rbigin，rend\"><a href=\"#2）使用r-push-back-n-2-利用属性改为rbigin，rend\" class=\"headerlink\" title=\"2）使用r.push_back(n%2);利用属性改为rbigin，rend\"></a>2）使用r.push_back(n%2);利用属性改为rbigin，rend</h4><p>利用双向链表的属性，我们可以重后往前输出</p>\n<p><strong>注意</strong>：双向链表不是数列，不能将上述<code>for(auto i=r.begin();i!=r.end();++i)</code>用<code>for(auto i=r.end();i!=r.begin();i--)</code>，而是要将<code>r.begin()</code>改为<code>r.rbegin</code>，<code>r.end</code>改为<code>r.rend</code>,即改为<code>for(auto i=r.rbegin();i!=r.rend();++i)</code></p>\n<p>具体代码如下</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include&lt;cstdio&gt;\n#include&lt;list&gt;\nmain()&#123;\n\tstd::list&lt;int&gt; r;\n\tint n;\n\tscanf(&quot;%d&quot;,&amp;n);\n\twhile(n!&#x3D;0)&#123;\t \n\t\tr.push_back(n%2); \t\t\n\t\tn&#x3D;n&#x2F;2;\n\t&#125; \n\n\t&#x2F;&#x2F;auto *i;auto:自动类型推倒&#x2F;&#x2F;std::list&lt;int&gt;::iterator ;\n\n\tfor(auto i&#x3D;r.rbegin();i!&#x3D;r.rend();++i)&#x2F;&#x2F; begin变成rbegin， end改为rend，双向链表从后向前读取 \n\tprintf(&quot;%d&quot;,*i) ;\n\treturn 0;\n\n&#125;</code></pre>\n\n\n\n<h4 id=\"3）使用r-push-front-n-2\"><a href=\"#3）使用r-push-front-n-2\" class=\"headerlink\" title=\"3）使用r.push_front(n%2);\"></a>3）使用r.push_front(n%2);</h4><p><u>将得到的余数作为二进制数的高位有效位依次排列起来</u> 的过程需要后进先出，我们还可以在插入时从链表头插入<code>r.push_front(n%2)</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include&lt;cstdio&gt;\n#include&lt;list&gt;\nmain()&#123;\n\tstd::list&lt;int&gt; r;\n\tint n;\n\tscanf(&quot;%d&quot;,&amp;n);\n\twhile(n!&#x3D;0)&#123;\t \n\t\tpush_front(n%2);\t\t&#x2F;&#x2F; push_front(n%2)（从前插入）顺序等于reverse(r.begin(),r.end())【或者】;数序颠倒，1,2,3-&gt;3,2,1 ,\n\t\tn&#x3D;n&#x2F;2;\n\t&#125; \n\tfor(auto i&#x3D;r.begin();i!&#x3D;r.end();++i)\n\tprintf(&quot;%d&quot;,*i) ;\n\treturn 0;\n\n&#125;</code></pre>\n\n\n\n<h3 id=\"三、vector【顺序存储，数组】输出\"><a href=\"#三、vector【顺序存储，数组】输出\" class=\"headerlink\" title=\"三、vector【顺序存储，数组】输出\"></a>三、vector【顺序存储，数组】输出</h3><p>同使用list【链式存储】输出一样，我们可以</p>\n<p><strong>1）使用r.push_back(n%2);加上reverse</strong></p>\n<p>方法同list，只不过将list替换为vector</p>\n<p><strong>2）使用r.push_back(n%2);利用属性改为rbigin，rend</strong></p>\n<p>方法同list，只不过将list替换为vector</p>\n<p>但是我们<u>不能使用<code>r.push_front(n%2);</code></u> ，因为vector作为顺序存储（数组），不能从头输入，只能从尾输入。即没有<code>r.push_front()</code></p>\n<p><strong>vector具有数组特性，我们可以使用数组的方法进行输出</strong> <strong>（不建议）</strong></p>\n<p>即使用</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">for(int i&#x3D;r.size();i&gt;0;--i)\n\t\tprintf(&quot;%d&quot;,r[i]) ;</code></pre>\n\n\n\n<p>得到：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include&lt;cstdio&gt;\n#include&lt;vector&gt;\nmain()&#123;\n\tstd::vector&lt;int&gt; r;\n\tint n;\n\tscanf(&quot;%d&quot;,&amp;n);\n\twhile(n!&#x3D;0)&#123;\t \n\t\tr.push_back(n%2); \t\t\n\t\tn&#x3D;n&#x2F;2;\n\t&#125;\n\n\tfor(int i&#x3D;r.size();i&gt;0;--i)\n\t\tprintf(&quot;%d&quot;,r[i]) ;\t\t\t&#x2F;&#x2F;数组从r[max]输出到r[1](r[0]为空)\n\treturn 0;\n\n&#125;</code></pre>\n\n\n\n\n\n<h3 id=\"四、双端队列deque【deque-是-double-ended-queue-的缩写，又称双端队列容器。】\"><a href=\"#四、双端队列deque【deque-是-double-ended-queue-的缩写，又称双端队列容器。】\" class=\"headerlink\" title=\"四、双端队列deque【deque 是 double-ended queue 的缩写，又称双端队列容器。】\"></a>四、双端队列deque【deque 是 double-ended queue 的缩写，又称双端队列容器。】</h3><p>和 vector 不同的是，deque 还擅长在序列头部添加或删除元素</p>\n<p>deque的内存模型相比于vector与list要复杂许多，它不像vector 把所有的对象保存在一块连续的内存块，而是采用多个连续的存储块，并且在一个映射结构中保存对这些块及其顺序的跟踪。向deque 两端添加或删除元素的开销很小，它不需要重新分配空间。</p>\n<p>具体模型见下图：</p>\n<p><img src=\"https://img1.i-nmb.cn/img/image-20220522141449464.png\" alt=\"image-20220522141449464\"></p>\n<p>他能支持上述所有方式：</p>\n<p><strong>1）使用r.push_back(n%2);加上reverse</strong></p>\n<p><strong>2）使用r.push_back(n%2);利用属性改为rbigin，rend</strong></p>\n<p><strong>3）使用r.push_front(n%2);</strong> </p>\n<p><strong>4）具有数组特性，可以使用数组的方法进行输出</strong> <strong>（不建议）</strong></p>\n","text":"问题引入如何输出6的二进制数？ 分析问题问题-&gt;解决方案-&gt;实现方案-&gt;编写 即 从问题得到解决方案（解决方案（具体步骤（过程可以问专业专家））） 实现方案有哪几种方法，并进行优化 编写代码 解决方案整数十进制整数转换为二进制整数采用”除2取余，逆序排列”法。 ...","link":"","photos":[],"count_time":{"symbolsCount":"5.2k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"线性结构","slug":"线性结构","count":1,"path":"api/tags/线性结构.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98%E5%BC%95%E5%85%A5\"><span class=\"toc-text\">问题引入</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">分析问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">解决方案</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B4%E6%95%B0\"><span class=\"toc-text\">整数</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">实现方案</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E4%BD%BF%E7%94%A8stack%E3%80%90%E6%A0%88%E3%80%91%E8%BE%93%E5%87%BA\"><span class=\"toc-text\">一、使用stack【栈】输出</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">优化</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8list%E3%80%90%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E3%80%91%E8%BE%93%E5%87%BA\"><span class=\"toc-text\">二、使用list【链式存储】输出</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%EF%BC%89%E4%BD%BF%E7%94%A8r-push-back-n-2-%E5%8A%A0%E4%B8%8Areverse\"><span class=\"toc-text\">1）使用r.push_back(n%2);加上reverse</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%EF%BC%89%E4%BD%BF%E7%94%A8r-push-back-n-2-%E5%88%A9%E7%94%A8%E5%B1%9E%E6%80%A7%E6%94%B9%E4%B8%BArbigin%EF%BC%8Crend\"><span class=\"toc-text\">2）使用r.push_back(n%2);利用属性改为rbigin，rend</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%EF%BC%89%E4%BD%BF%E7%94%A8r-push-front-n-2\"><span class=\"toc-text\">3）使用r.push_front(n%2);</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81vector%E3%80%90%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%EF%BC%8C%E6%95%B0%E7%BB%84%E3%80%91%E8%BE%93%E5%87%BA\"><span class=\"toc-text\">三、vector【顺序存储，数组】输出</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97deque%E3%80%90deque-%E6%98%AF-double-ended-queue-%E7%9A%84%E7%BC%A9%E5%86%99%EF%BC%8C%E5%8F%88%E7%A7%B0%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E5%AE%B9%E5%99%A8%E3%80%82%E3%80%91\"><span class=\"toc-text\">四、双端队列deque【deque 是 double-ended queue 的缩写，又称双端队列容器。】</span></a></li></ol></li></ol>","author":{"name":"ACbug战队","slug":"blog-author","avatar":"https://img1.i-nmb.cn/ava.png","link":"/","description":"西北民族大学数学与计算机科学学院<br>系统与软件工作室网络安全组","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"【实例1】表达式求值——利用stack实现五种运算符的运算","uid":"2ee39bc7ef8592ef83ca72fba476f564","slug":"example","date":"2022-05-22T15:38:33.000Z","updated":"2022-06-19T13:56:45.212Z","comments":true,"path":"api/articles/example.json","keywords":null,"cover":[],"text":"看了标题有人会问，运算符的运算实现？直接printf(“%d”,a+b*c);不就完了么？ 当然没有那么简单！ 本篇带读者走进如何用stack来实现加减乘除运算 [原则：没有解决方案之前绝不能试图开始编程]在我们拿到题目后，有些读者习惯于直接开始敲代码，我觉得这样不方便思路的养成...","link":"","photos":[],"count_time":{"symbolsCount":"8.1k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"运算符","slug":"运算符","count":3,"path":"api/tags/运算符.json"}],"author":{"name":"ACbug战队","slug":"blog-author","avatar":"https://img1.i-nmb.cn/ava.png","link":"/","description":"西北民族大学数学与计算机科学学院<br>系统与软件工作室网络安全组","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"《数据结构》知识总结","uid":"1b543e84ac41cc09af328e6f7689b488","slug":"Structures","date":"2022-05-13T15:03:29.000Z","updated":"2022-05-14T14:36:51.050Z","comments":true,"path":"api/articles/Structures.json","keywords":null,"cover":[],"text":"参考视频：速成数据结构与算法-【期末不挂科】_哔哩哔哩_bilibili 数据结构和算法1.数据结构1）数据: 对客观事物的符号表示 图像、声音等 2）数据元素: 数据的基本单位 学生的信息记录 3）数据项: 构成数据元素的不可分割的最小单位 ​ 一个数据元素可由若干个数据项组成...","link":"","photos":[],"count_time":{"symbolsCount":"5.2k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"-数据结构","slug":"数据结构","count":1,"path":"api/tags/数据结构.json"}],"author":{"name":"ACbug战队","slug":"blog-author","avatar":"https://img1.i-nmb.cn/ava.png","link":"/","description":"西北民族大学数学与计算机科学学院<br>系统与软件工作室网络安全组","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}