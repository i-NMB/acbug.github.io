{"title":"【实例1】表达式求值——利用stack实现五种运算符的运算","uid":"2ee39bc7ef8592ef83ca72fba476f564","slug":"example","date":"2022-05-22T15:38:33.000Z","updated":"2022-06-19T13:56:45.212Z","comments":true,"path":"api/articles/example.json","keywords":null,"cover":[],"content":"<p>看了标题有人会问，运算符的运算实现？直接printf(“%d”,a+b*c);不就完了么？</p>\n<p>当然没有那么简单！</p>\n<p>本篇带读者走进如何用stack来实现加减乘除运算</p>\n<h2 id=\"原则：没有解决方案之前绝不能试图开始编程\"><a href=\"#原则：没有解决方案之前绝不能试图开始编程\" class=\"headerlink\" title=\"[原则：没有解决方案之前绝不能试图开始编程]\"></a>[原则：没有解决方案之前绝不能试图开始编程]</h2><p>在我们拿到题目后，有些读者习惯于直接开始敲代码，我觉得这样不方便思路的养成。所以 没有解决方案之前绝不能试图开始编程</p>\n<p>那么解决方案哪里来？！探索解决方案，可以从百度来，可以问专业学者等等。</p>\n<h2 id=\"解决方案一-算符优先文法\"><a href=\"#解决方案一-算符优先文法\" class=\"headerlink\" title=\"[解决方案一:算符优先文法]\"></a>[解决方案一:算符优先文法]</h2><p>给不同运算符赋予“优先级”的概念<br>优先级相同的运算符按照结合性的顺序计算（从左到右或从右到左）<br>为了更简单地比较不同运算符的优先级<br>给每个运算符定义一个称为<strong>“优先数”的整数（以下优先数越小，优先级越高）</strong></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">+：81，82\n-：81，82\n*：41，42\n&#x2F;：41，42\n&#x3D;：100，100\n3+4*5+2&#x3D;</code></pre>\n\n<p>确定运算顺序:专家告诉我们：使用计算栈h（保存元素是运算符）<br>{a1, a2,…, an, k} 此时，k是watch dog，也就是哨兵<br>for (i&#x3D;1 ;ai !&#x3D;k ; ++k) ;</p>\n<h2 id=\"实践方案\"><a href=\"#实践方案\" class=\"headerlink\" title=\"实践方案\"></a>实践方案</h2><ol>\n<li><p>h.push(‘&#x3D;’);\t&#x2F;&#x2F; 用于判断结束，例如：若输入<code>6=</code>(当栈顶的&#x3D;和输入的&#x3D;匹配，则结束)</p>\n</li>\n<li><p>输入下一个运算符op;</p>\n</li>\n<li><p>while（h.top()比op优先）{\t栈顶元素出栈计算；}</p>\n</li>\n<li><p>if(h.top()&#x3D;&#x3D;’&#x3D;’&amp;&amp; op&#x3D;&#x3D;’&#x3D;’){结束}</p>\n</li>\n<li><p>h.push(op);</p>\n</li>\n<li><p>转2。（循环）</p>\n</li>\n</ol>\n<h3 id=\"首先，根据实践方案进行初始化\"><a href=\"#首先，根据实践方案进行初始化\" class=\"headerlink\" title=\"首先，根据实践方案进行初始化\"></a>首先，根据实践方案进行初始化</h3><p>根据上述实践方案，我们可以知道我们需要用到stack、stdio.h的头文件，并且需要用到oper（运算符）、和operand（操作数）,而运算符是char型，操作数为float型</p>\n<p>所以我们在文件头需要编写以下代码</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include&lt;stdio.h&gt;\n#include&lt;stack&gt;\n\ntypedef char oper;\t&#x2F;&#x2F;运算符\ntypedef float operand;</code></pre>\n\n\n\n<h3 id=\"其次，建立实践方案对应的函数\"><a href=\"#其次，建立实践方案对应的函数\" class=\"headerlink\" title=\"其次，建立实践方案对应的函数\"></a>其次，建立实践方案对应的函数</h3><p>我们初始化完成后，如果要解决问题，则需要建立解决问题的函数</p>\n<p>于是我们建立一个名为<code>solve</code>的函数，因为是处理数据的，将要返回处理数据的数值，而数值的类型上述定义是<code>operand</code>类型</p>\n<p>需要加入<code>operand solve()&#123;&#125;</code>函数。</p>\n<p>我们在处理运算符时，需要判断运算符的优先级，我们需要一个函数判断左边和右边优先级大小，所以我们引入一个函数 根据定义的一个称为<strong>“优先数”的整数</strong>（优先数越小，优先级越高）来判断优先级大小。</p>\n<p>我们使用<code>int prior(oper op1, oper op2)&#123;&#125;</code>，根据优先数相减得到的int型的正负值判断，其中<code>op1</code>为左符号类型为定义的<code>oper</code>，<code>op2</code>为右符号（新符号）</p>\n<p>最后使用必须要有main函数<code>main()&#123;&#125;</code></p>\n<p>所以构造完毕后，总代码如下</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include&lt;stdio.h&gt;\n#include&lt;stack&gt;\n\ntypedef char oper;\t\t&#x2F;&#x2F;运算符\ntypedef float operand;\t&#x2F;&#x2F;运算数\n\n\nint prior(oper op1, oper op2)&#123;\n    return;\n&#125;\n\noperand solve()&#123;\n\treturn;\n&#125;\n\nmain()&#123;\n    \n&#125;</code></pre>\n\n\n\n<h3 id=\"处理函数的丰富\"><a href=\"#处理函数的丰富\" class=\"headerlink\" title=\"处理函数的丰富\"></a>处理函数的丰富</h3><p>我们主要的处理函数是<code>operand solve()</code></p>\n<p>最简单的加减乘除运算是拥有两个数和一个运算符组成，所以我们要先定义两个数和运算符</p>\n<p>我们还需要两个栈（一个存放操作数，一个存放操作符）</p>\n<p>完善函数如下</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">operand solute()&#123;\n\toperand x, y;\n\toper op;\n\tstd::stack&lt;oper&gt; history;\t\t&#x2F;&#x2F;历史栈 ,存放历史操作符号\n\tstd::stack&lt;operand&gt; operands;\t&#x2F;&#x2F;存放操作数\n&#125;</code></pre>\n\n\n\n<p>我们根据<a href=\"#%E5%AE%9E%E8%B7%B5%E6%96%B9%E6%A1%88\"><strong>实践方案（点击转到）</strong></a></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ol>\n<li><p>h.push(‘&#x3D;’);\t&#x2F;&#x2F; 用于判断结束，例如：若输入<code>6=</code>(当栈顶的&#x3D;和输入的&#x3D;匹配，则结束)</p>\n</li>\n<li><p>输入下一个运算符op;</p>\n</li>\n<li><p>while（h.top()比op优先）{</p>\n</li>\n</ol>\n<p>​\t栈顶元素出栈计算；</p>\n<p>}</p>\n<ol start=\"4\">\n<li><p>if(h.top()&#x3D;&#x3D;’&#x3D;’&amp;&amp; op&#x3D;&#x3D;’&#x3D;’){结束}（若有等号匹配，则结束循环）</p>\n</li>\n<li><p>h.push(op);</p>\n</li>\n<li><p>转2。（循环）</p>\n</li>\n</ol></blockquote>\n<h4 id=\"1-h-push-‘-x3D-’\"><a href=\"#1-h-push-‘-x3D-’\" class=\"headerlink\" title=\"1.h.push(‘&#x3D;’);\"></a>1.h.push(‘&#x3D;’);</h4><p>那么我们添加<code>history.push(&#39;=&#39;);</code>输入等号，whach dog（士兵）进栈 </p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">operand solute()&#123;\n\toperand x, y;\n\toper op;\n\tstd::stack&lt;oper&gt; history;\t\t&#x2F;&#x2F;历史栈 ,存放历史操作符号\n\tstd::stack&lt;operand&gt; operands;\t&#x2F;&#x2F;存放操作数\n    history.push(&#39;&#x3D;&#39;);&#x2F;&#x2F;输入等号，whach dog（士兵）进栈 \n&#125;</code></pre>\n\n\n\n<h4 id=\"2-步骤2-5循环，直到若有等号匹配，则结束循环；\"><a href=\"#2-步骤2-5循环，直到若有等号匹配，则结束循环；\" class=\"headerlink\" title=\"2.步骤2-5循环，直到若有等号匹配，则结束循环；\"></a>2.步骤2-5循环，直到若有等号匹配，则结束循环；</h4><p>所以我们加入循环条件</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">operand solute()&#123;\n\toperand x, y;\n\toper op;\n\tstd::stack&lt;oper&gt; history;\t\t&#x2F;&#x2F;历史栈 ,存放历史操作符号\n\tstd::stack&lt;operand&gt; operands;\t&#x2F;&#x2F;存放操作数\n    history.push(&#39;&#x3D;&#39;);&#x2F;&#x2F;输入等号，whach dog（士兵）进栈 \n    \twhile(1)&#123;\n\t\t\n\t\tif(prior(history.top(),op)&#x3D;&#x3D;0) break;\n\t&#125;\n&#125;</code></pre>\n\n<h4 id=\"3-输入下一个数和运算符op\"><a href=\"#3-输入下一个数和运算符op\" class=\"headerlink\" title=\"3.输入下一个数和运算符op;\"></a>3.输入下一个数和运算符op;</h4><p>我们需要在循环体中持续不断的输入数和运算符</p>\n<p>观察式子：<code>3+2+1*5=</code>、<code>5*8/7-4=</code>、<code>9*8/7-5=</code></p>\n<p>我们发现，我们输入的每个数字后面有且仅有一个运算符</p>\n<p>所以我们加入</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">scanf(&quot;%f %c&quot;,&amp;x,&amp;op);\t\t&#x2F;&#x2F;输入一个数字和一个字符\n\t\toperands.push(x);\t&#x2F;&#x2F;将数字压入存放操作数的栈</code></pre>\n\n\n\n<h4 id=\"4-栈顶元素出栈计算；\"><a href=\"#4-栈顶元素出栈计算；\" class=\"headerlink\" title=\"4.栈顶元素出栈计算；\"></a>4.栈顶元素出栈计算；</h4><p>我们需要判断运算符的优先级，如果存放历史操作符号的栈顶比op优先，（优先数越小，优先级越高），那么直接计算历史操作数链接的两个数</p>\n<p>示意图如下</p>\n<img src=\"https://img1.i-nmb.cn/img/image-20220522224804731.png\" alt=\"image-20220522224804731\" style=\"zoom:67%;\" />\n\n\n\n<p>所以我们根据</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ol start=\"3\">\n<li>while（h.top()比op优先）{</li>\n</ol>\n<p>​\t栈顶元素出栈计算；</p>\n<p>}</p></blockquote>\n<p>进行栈顶元素出栈计算；</p>\n<p>所以写出以下循环</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">while（h.top()比op优先）&#123;\n\ty &#x3D; operands.top();\t&#x2F;&#x2F;让y为最新的数（优先级高的历史操作符的右边的数）\n\toperands.pop();\t\t&#x2F;&#x2F;弹走最新的数（优先级高的历史操作符的右边的数）\n\tx &#x3D; operands.top();\t&#x2F;&#x2F;让x为优先级高的历史操作符的左边的数\n\toperands.pop();\t\t&#x2F;&#x2F;弹走历史操作符的左边的数\n\tswitch(history.top())&#123;\t&#x2F;&#x2F;判断优先级高的历史操作符\n\t\tcase &#39;+&#39;: operands.push(x + y) ; break;\n\t\tcase &#39;-&#39;: operands.push(x - y) ; break;\n\t\tcase &#39;*&#39;: operands.push(x * y) ; break;\n\t\tcase &#39;&#x2F;&#39;: operands.push(x &#x2F; y) ; break;\n\t&#125;\n\thistory.pop();&#x2F;&#x2F;弹走历史操作符的栈顶\n&#125;</code></pre>\n\n\n\n<p>接下来我们需要对比<code>history.top()</code>【历史操作符（上一次的运算符号）】和<code>op</code>【即将压入history栈的符号】优先</p>\n<p>通过之前的函数<code>int prior(oper op1, oper op2)</code>进行丰富，</p>\n<p>又因为<strong>优先数越小，优先级越高</strong>，所以我们判断优先数的做差，判断差的正负性就可以判断优先级。</p>\n<p>我们完善函数<code>int prior(oper op1, oper op2)</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int prior(oper op1, oper op2)&#123;\n\treturn p_num[op1].left - p_num[op2].right;\n&#125;</code></pre>\n\n<p>从而完善循环判断</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">while（prior(history.top(), op)&lt;0）&#123;\n\ty &#x3D; operands.top();\t&#x2F;&#x2F;让y为最新的数（优先级高的历史操作符的右边的数）\n\toperands.pop();\t\t&#x2F;&#x2F;弹走最新的数（优先级高的历史操作符的右边的数）\n\tx &#x3D; operands.top();\t&#x2F;&#x2F;让x为优先级高的历史操作符的左边的数\n    ………………………………………………</code></pre>\n\n\n\n<h4 id=\"5-h-push-op-压入op\"><a href=\"#5-h-push-op-压入op\" class=\"headerlink\" title=\"5.h.push(op);压入op\"></a>5.h.push(op);压入op</h4><p>若优先级不大于栈顶的优先级，要将op压入history栈<code>history.push(op);</code>，此操作要在判断是否为等号之后</p>\n<p>即</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">operand solve()&#123;\n\toperand x, y;\n\toper op;\n\tstd::stack&lt;oper&gt; history;&#x2F;&#x2F;历史栈 \n\tstd::stack&lt;operand&gt; operands;\n\thistory.push(&#39;&#x3D;&#39;);&#x2F;&#x2F;输入等号，whach dog（士兵）进栈 \n\twhile(1)&#123;\n&#x2F;*******************\n*2.  输入下一个运算符op;\n*3.  while（h.top()比op优先）&#123;\t栈顶元素出栈计算；&#125;\n*4.  if(h.top()&#x3D;&#x3D;&#39;&#x3D;&#39;&amp;&amp; op&#x3D;&#x3D;&#39;&#x3D;&#39;)&#123;结束&#125;\n*5.  h.push(op);\n*6.  转2。\n********************&#x2F;\n\t\tscanf(&quot;%f %c&quot;,&amp;x,&amp;op);\n\t\toperands.push(x);\n\t\twhile(prior(history.top(), op)&lt;0)&#123;\n\t\t\ty &#x3D; operands.top();\n\t\t\toperands.pop();\n\t\t\tx &#x3D; operands.top();\n\t\t\toperands.pop();\n\t\t\tswitch(history.top())&#123;\n\t\t\t\tcase &#39;+&#39;: operands.push(x + y) ; break;\n\t\t\t\tcase &#39;-&#39;: operands.push(x - y) ; break;\n\t\t\t\tcase &#39;*&#39;: operands.push(x * y) ; break;\n\t\t\t\tcase &#39;&#x2F;&#39;: operands.push(x &#x2F; y) ; break;\n\t\t\t&#125;\n\t\t\thistory.pop();\n\t\t&#125;\n\t\tif(prior(history.top(),op)&#x3D;&#x3D;0) break;\n\t\thistory.push(op);\n\t&#125;\n    return operands.top();\n&#125;</code></pre>\n\n\n\n<h4 id=\"6-函数的完善\"><a href=\"#6-函数的完善\" class=\"headerlink\" title=\"6.函数的完善\"></a>6.函数的完善</h4><p>我们的解决函数<code>operand solve()&#123;&#125;</code>趋近完美，但是程序是由<code>main()&#123;&#125;</code>开始</p>\n<p>所以我们要完善main函数</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int main()&#123;\n\tprintf(&quot;%g\\n&quot;,solve());\n\treturn 0;\n&#125;</code></pre>\n\n\n\n<p>在函数<code>int prior(oper op1, oper op2)&#123;&#125;</code>中，我们没有赋予<code>p_num[op1].left</code>（左符号、旧符号）和<code>p_num[op2].right</code>（右符号、新符号）的值（优先数）。所以我们在函数<code>int prior(oper op1, oper op2)&#123;&#125;</code>之前加入以下代码，并且加入<code>#include&lt;map&gt;</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">struct prv_num_t&#123;char left,right;&#125;;&#x2F;&#x2F;定义结构体 prv_num_t  _t代表类型 \n&#x2F;&#x2F;关键字只包含一部分数据项,就称为map\nstd::map&lt;oper, prv_num_t&gt; p_num&#x3D;&#123;\n\t&#123;&#39;+&#39;,&#123;81,82&#125;&#125;,\n\t&#123;&#39;-&#39;,&#123;81,82&#125;&#125;,\n\t&#123;&#39;*&#39;,&#123;41,42&#125;&#125;,\n\t&#123;&#39;&#x2F;&#39;,&#123;41,42&#125;&#125;,\n\t&#123;&#39;&#x3D;&#39;,&#123;100,100&#125;&#125;\n&#125;;</code></pre>\n\n\n\n<img src=\"https://img1.i-nmb.cn/img/image-20220522232910691.png\" alt=\"计算优先数的示意图\" style=\"zoom:80%;\" />\n\n\n\n\n\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><p>最终获得代码</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include&lt;stdio.h&gt;\n#include&lt;stack&gt;\n#include&lt;map&gt;\n\ntypedef char oper;&#x2F;&#x2F;运算符\ntypedef float operand;\n\n&#x2F;*优先数表*&#x2F;\nstruct prv_num_t&#123;char left,right;&#125;;&#x2F;&#x2F;定义结构体 prv_num_t  _t代表类型 \n&#x2F;&#x2F;关键字只包含一部分数据项,就称为map\n&#x2F;&#x2F;关键字包含全部数据项,成为 \nstd::map&lt;oper, prv_num_t&gt; p_num&#x3D;&#123;\n\t&#123;&#39;+&#39;,&#123;81,82&#125;&#125;,\n\t&#123;&#39;-&#39;,&#123;81,82&#125;&#125;,\n\t&#123;&#39;*&#39;,&#123;41,42&#125;&#125;,\n\t&#123;&#39;&#x2F;&#39;,&#123;41,42&#125;&#125;,\n\t&#123;&#39;&#x3D;&#39;,&#123;100,100&#125;&#125;\n&#125;;\n\n\n&#x2F;*op1在左，op2在右*&#x2F;\n&#x2F;*返回值为负: op1优先级高于op2*&#x2F;\n&#x2F;*返回值为正: op2优先级高于op1*&#x2F;\n&#x2F;*返回值为0: op1优先级等于op2*&#x2F;\n\nint prior(oper op1, oper op2)&#123;\n\treturn p_num[op1].left - p_num[op2].right;\n&#125;\n\noperand solute()&#123;\n\toperand x, y;\n\toper op;\n\tstd::stack&lt;oper&gt; history;&#x2F;&#x2F;历史栈 \n\tstd::stack&lt;operand&gt; operands;\n\thistory.push(&#39;&#x3D;&#39;);&#x2F;&#x2F;输入等号，whach dog（士兵）进栈 \n\twhile(1)&#123;\n&#x2F;****************************************\n*2.  输入下一个运算符op;\n*3.  while（h.top()比op优先）&#123;\t栈顶元素出栈计算；&#125;\n*4.  if(h.top()&#x3D;&#x3D;&#39;&#x3D;&#39;&amp;&amp; op&#x3D;&#x3D;&#39;&#x3D;&#39;)&#123;结束&#125;\n*5.  h.push(op);\n*6.  转2。\n******************************************&#x2F;\n\t\tscanf(&quot;%f %c&quot;,&amp;x,&amp;op);\n\t\toperands.push(x);\n\t\twhile(prior(history.top(), op)&lt;0)&#123;\n\t\t\t\n\t\t\ty &#x3D; operands.top();\n\t\t\toperands.pop();\n\t\t\tx &#x3D; operands.top();\n\t\t\toperands.pop();\n\t\t\tswitch(history.top())&#123;\n\t\t\t\tcase &#39;+&#39;: operands.push(x + y) ; break;\n\t\t\t\tcase &#39;-&#39;: operands.push(x - y) ; break;\n\t\t\t\tcase &#39;*&#39;: operands.push(x * y) ; break;\n\t\t\t\tcase &#39;&#x2F;&#39;: operands.push(x &#x2F; y) ; break;\n\t\t\t&#125;\n\t\t\thistory.pop();\n\t\t&#125;\n\t\tif(prior(history.top(),op)&#x3D;&#x3D;0) break;\n\t\thistory.push(op);\n\t&#125;\n\treturn operands.top();\n&#125;\n\nint main()&#123;\n\tprintf(&quot;%g\\n&quot;,solute());\n\t\n\treturn 0;\n&#125;\n </code></pre>\n\n","text":"看了标题有人会问，运算符的运算实现？直接printf(“%d”,a+b*c);不就完了么？ 当然没有那么简单！ 本篇带读者走进如何用stack来实现加减乘除运算 [原则：没有解决方案之前绝不能试图开始编程]在我们拿到题目后，有些读者习惯于直接开始敲代码，我觉得这样不方便思路的养成...","link":"","photos":[],"count_time":{"symbolsCount":"8.1k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"运算符","slug":"运算符","count":3,"path":"api/tags/运算符.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%88%99%EF%BC%9A%E6%B2%A1%E6%9C%89%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E5%89%8D%E7%BB%9D%E4%B8%8D%E8%83%BD%E8%AF%95%E5%9B%BE%E5%BC%80%E5%A7%8B%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">[原则：没有解决方案之前绝不能试图开始编程]</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B8%80-%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E6%96%87%E6%B3%95\"><span class=\"toc-text\">[解决方案一:算符优先文法]</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E8%B7%B5%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">实践方案</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A6%96%E5%85%88%EF%BC%8C%E6%A0%B9%E6%8D%AE%E5%AE%9E%E8%B7%B5%E6%96%B9%E6%A1%88%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">首先，根据实践方案进行初始化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B6%E6%AC%A1%EF%BC%8C%E5%BB%BA%E7%AB%8B%E5%AE%9E%E8%B7%B5%E6%96%B9%E6%A1%88%E5%AF%B9%E5%BA%94%E7%9A%84%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">其次，建立实践方案对应的函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%B0%E5%AF%8C\"><span class=\"toc-text\">处理函数的丰富</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-h-push-%E2%80%98-x3D-%E2%80%99\"><span class=\"toc-text\">1.h.push(‘&#x3D;’);</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E6%AD%A5%E9%AA%A42-5%E5%BE%AA%E7%8E%AF%EF%BC%8C%E7%9B%B4%E5%88%B0%E8%8B%A5%E6%9C%89%E7%AD%89%E5%8F%B7%E5%8C%B9%E9%85%8D%EF%BC%8C%E5%88%99%E7%BB%93%E6%9D%9F%E5%BE%AA%E7%8E%AF%EF%BC%9B\"><span class=\"toc-text\">2.步骤2-5循环，直到若有等号匹配，则结束循环；</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E8%BE%93%E5%85%A5%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%95%B0%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6op\"><span class=\"toc-text\">3.输入下一个数和运算符op;</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0%E5%87%BA%E6%A0%88%E8%AE%A1%E7%AE%97%EF%BC%9B\"><span class=\"toc-text\">4.栈顶元素出栈计算；</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-h-push-op-%E5%8E%8B%E5%85%A5op\"><span class=\"toc-text\">5.h.push(op);压入op</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%8C%E5%96%84\"><span class=\"toc-text\">6.函数的完善</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3\"><span class=\"toc-text\">问题解决</span></a></li></ol>","author":{"name":"ACbug战队","slug":"blog-author","avatar":"https://img1.i-nmb.cn/ava.png","link":"/","description":"西北民族大学数学与计算机科学学院<br>系统与软件工作室网络安全组","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"【实例1の更新1】表达式求值——加入新的单目运算符","uid":"6c04c36ceec929560d9050b95673c3cf","slug":"example-optimization-1","date":"2022-05-23T22:38:52.000Z","updated":"2022-06-19T13:56:51.545Z","comments":true,"path":"api/articles/example-optimization-1.json","keywords":null,"cover":null,"text":"前段时间我们学习了利用stack实现五种运算符的运算：【实例】表达式求值——利用stack实现五种运算符的运算 | 《课程设计》笔记 (i-nmb.cn) 实际上我们的表达式求值中并不是只有这5种运算，他还包括了 指数、对数以及三角函数等等。 今天我们就在原基础上逐一的实现 指数...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[],"tags":[{"name":"运算符","slug":"运算符","count":3,"path":"api/tags/运算符.json"}],"author":{"name":"ACbug战队","slug":"blog-author","avatar":"https://img1.i-nmb.cn/ava.png","link":"/","description":"西北民族大学数学与计算机科学学院<br>系统与软件工作室网络安全组","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"STL 线性结构","uid":"85b9560fd5f89937d71ee469baf4d06b","slug":"STL-linear-structure","date":"2022-05-22T04:55:33.000Z","updated":"2022-06-19T13:56:20.443Z","comments":true,"path":"api/articles/STL-linear-structure.json","keywords":null,"cover":[],"text":"问题引入如何输出6的二进制数？ 分析问题问题-&gt;解决方案-&gt;实现方案-&gt;编写 即 从问题得到解决方案（解决方案（具体步骤（过程可以问专业专家））） 实现方案有哪几种方法，并进行优化 编写代码 解决方案整数十进制整数转换为二进制整数采用”除2取余，逆序排列”法。 ...","link":"","photos":[],"count_time":{"symbolsCount":"5.2k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"线性结构","slug":"线性结构","count":1,"path":"api/tags/线性结构.json"}],"author":{"name":"ACbug战队","slug":"blog-author","avatar":"https://img1.i-nmb.cn/ava.png","link":"/","description":"西北民族大学数学与计算机科学学院<br>系统与软件工作室网络安全组","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}