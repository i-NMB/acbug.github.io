[{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-09-03T16:40:30.701Z","categories_index":"","tags_index":"","author_index":"ACbug"},{"id":"9d7035fca2dd78eacb18cb9d3466fa8f","title":"rand随机函数——MATLAB函数","content":"我们有一串代码\nE &#x3D; zeros(10,5,3) ;\nE(:,:,1) &#x3D; rand(10,5);\nE(:,:,2) &#x3D; randi(99,10,5);\nE(:,:,3) &#x3D; randn(10,5);\n\n\n\n那么这串代码的具体含义是什么呢？\n1. E &#x3D; zeros(10,5,3) ;这串代码是一个赋值代码，zeros函数将赋予10行5列、维度为3的一个0矩阵；\n执行后结果为：\n\n\n2. rand函数rand函数分为3种，分别是rand、randn、randi，他们都用来制造伪随机数\n\n\n\n\n\n\n\n\n\n伪随机数伪随机数是用确定性的算法计算出来自[0,1]均匀分布的随机数序列。并不真正的随机，但具有类似于随机数的统计特征，如均匀性、独立性等。在计算伪随机数时，若使用的初值（种子）不变，那么伪随机数的数序也不变。\nrandrand生成均匀分布的伪随机数。分布在(0~1)之间\n使用方法：rand(行数,列数)\n\n\n\n\n\n\n\n\n\nrand(RandStream,m,n)利用指定的RandStream(我理解为种子)生成伪随机数\n运行代码\nE &#x3D; zeros(10,5,3) ;\nE(:,:,1) &#x3D; rand(10,5)\n\n结果如下\n\n\n\n\nrandirandi函数用来生成特定大小区间的均匀分布的伪随机数\n主要语法:randi (iMax)在开区间(0,iMax)生成均匀分布的伪随机整数                randi (iMax,m,n)在开区间(0,iMax)生成m行n列随机矩阵\n​\t\t\t\trandi([iMin,iMax],m,n)在开区间(iMin，iMax)生成m行n列型随机矩阵\n运行代码\nE &#x3D; zeros(10,5,3) ;\nE(:,:,2) &#x3D; randi(99,10,5)\n\n结果如下：\n\n\nrandnrandn函数生成标准正态分布的伪随机数（均值为0．方差为1)\n主要语法:和rand函数一样\n","slug":"MATLAB-rand","date":"2022-08-30T11:57:49.000Z","categories_index":"","tags_index":"MATLAB,数学建模","author_index":"ACbug"},{"id":"f6e40bab8f6950a622e72a274ec12c0e","title":"【实例2】24点游戏","content":"描述问题在确认程序编写之前我们需要思考如何描述，表达问题\n算法具有五个特性\n\n\n\n\n\n\n\n\n\n1.输入：在算法中可以有零个或者多个输入\n2.输出：在算法中至少有一个或者多个输出\n3.有穷行：在执行有限的步骤之后，自动结束不会出现无限循环并且每一个步骤在可接受的时间内完成\n4.确定性：算法的每一个步骤都具有确定的含义，不会出现二义性\n5.可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限的次数完成\n那么哪两个适用于描述问题呢？答案是输入和输出\n描述问题，我们只需要抓住输入和输出就够了。至于什么其他的问题背景，对于毫无意义。找到问题的输入和输出之后，我们进入抽象化的世界，\n所以描述任何问题最关键的是要找到问题的输入和输出。\n24点的输入是什么？四个整数，每个整数都在1~13之间\n输出呢？输出就是要找一个表达式，加减乘除算运算完成后等于24。如果找不到输出无解，找到就输出那个表达式\n有了输入和输出之后，24点问题就算是描述的非常清晰。\n计算机专业描述问题，只需要抓住啊两个特点：输入和输出\n不是说问题背景不需要，而是说，描述问题背景是为了找到输入与输出！与输入输出无关的背景可以酌情忽略。\n解决问题方法输入和输出找到之后需要找解决方案，解决方案找到之后，把解决方案变成算法。把解决方案变成算法的过程可能需要咨询领域专家。算法知道后，我们的路就好走了。\n解决方案举例子：\n24点游戏我们需要输入四个数字，最后要找一个表达式，加减乘除算运算完成后等于24。\n比如说有3，7，9，10四个数\n我们计算的时候，找到两个数直接通过加减乘除通过双目运算符直接进行计算【Ps：我们需最终要把问题落实在基本操作上，而24点游戏的基本操作就是加减乘除】\n双目运算符直接进行计算，需要两个数，所以第一步，我们先要从四个数中抽出两个数进行加减乘除\n四个数里面取两个数，六种取法：\n3，7，9，10四个数\n取两个数：3,7 \t3,9 \t3,10\t 7,9\t 7,10\t 9,10\n我们单拿3,7来看，结果为10,-4,4,21，(不能整除)\n由两个数可以算出4~5种可能：10,9,10；-4,9,10 ； 4,9,10；21,9,10，不能整除。\n四个变成三个数一共有2430（6 * 46 * 5）种可能。【6为四个数抽出两个数的可能性】\n…………以此类推…………\n4个变为1个数，一共有1152~2250种变法【(C_4^2 * 4 * C_3^2* 4 * C_2^2 * 4&#x3D;1152】\n然后我们从这些数中寻找24，并且将其溯源，寻找他的运算符号以及从哪些数变化而来\n到此，我们的基本流程几乎了解，也就是说我们对于这个问题的策略基本上可以掌握\n\n\n\n\n\n\n\n\n\n算法策略和算法是有区别的,它们是算法设计中的两个方面，算法策略是面向问题的,算法是面向实现的；但二者又是不可分的,首先是通过算法策略才找出解决问题的算法，其次对于用不同算法求解的问题算法策略是自然不同的。\n策略我们发现，这种流程颠覆了我们正常游戏的思维。它是用最基本的加减乘除操作，因为我们发现，不管4个数是如何变化，运算的时候都是抽取两个数进行计算。并且最多计算三轮，第一轮4个数变成3个数，第二轮3个数变成2个数，第三轮2个数变成1个数。\n算法我们由上可以找到一个动态数据结构去配合实现，我们发现，在上述流程中，四个数转三个数，将会生成多个数（4~5种可能），然后在每一种可能中又包含多种可能，这种连续一对多的情况下，我们不由的想到一种数据结构——树\n从策略可知，我们计算了三轮，所以很容易判断树的高度为4，并且这个高度为4的树的叶子结点最多为2250个、最少有1152个。\n\n\n\n\n\n\n\n\n\n分析问题的过程中可能有一系列的回答或者决策。\n所以这个数习惯上把它叫做分析树，也有时候把它叫做决策树\n他实际上和计算机与人类在做围棋博弈的时候的那个思维方法是一样的，所以他也叫博弈树\n（分析树是动态的）\n所以此类问题我们可以使用树来进行存储记录\n操作每个叶子结点都拥有一个int型的数据，而这些数据需要用一个int型容器进行存放，而最方便的int型容器是vector\nstruct element&#123;\n\tint number;\n\tstd::string trace;&#x2F;&#x2F;string即为字符串\n&#125;;\n\n\nstruct NODE&#123;\n\tstd::vector&lt;element&gt; data;\n\tstd::vector&lt;NODE&gt; children;&#x2F;&#x2F;子节点 \n&#125; ana_tree;\n&#x2F;&#x2F;定义分析（analyse）树；ADT抽象数据类型 vector&lt;NODE&gt;（类似于递归结构） \n\n对于分析树的根节点来说，里面拥有四个整数；而对于叶子结点来说，每个结点只有一个整数。\n\n\n\n\n\n\n\n\n\n抽象数据类型（Abstract Data Type，ADT）是将数据对象、数据对象之间的关系和数据对象的基本操作封装在一起的一种表达方式，它和工程中的应用是一致的。\n在工程项目中，开始编程之前，首先列出程序需要完成的功能任务，先不用管具体怎么实现，实现细节在项目后期完成，一开始只是抽象出有哪些基本操作。把这些操作项封装为抽象数据类型，等待后面具体实现这些操作。而其他对象如果想调用这些操作，只需要按照规定好的参数接口调用，并不需要知道具体是怎么实现的，从而实现了数据封装和信息隐藏。\n在 C++ 中可以用类的声明表示抽象数据类型，用类的实现来实现抽象数据类型的具体操作。\n\n抽象数据类型可以用以下的三元组来表示：\nADT抽象数据类型名{  数据对象：&lt;数据对象的定义&gt;  数据关系：&lt;数据关系的定义&gt;  基本操作：&lt;基本操作的定义&gt;} ADT抽象数据类型名、\n引用于：抽象数据类型（ADT）是什么？ (biancheng.net)\n定义好树之后，我们开始在main函数中初始化，先给ana_tree中存放两个值\nint main()&#123;\n\tana_tree.data &#x3D; &#123;3,6&#125;;\n\tstep(ana_tree);\n\tfor(auto child:ana_tree.children)&#123;\n\t\tfor(auto num:child.data)&#123;\n\t\t\tprintf(&quot;%d&quot;,num);\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;\n\n\n\nstep其中step中的需要的操作为：n个数中取出两个，然后这两个和剩下的哪些没有取出的数变成4~5个子节点。\nn个数中取出两个数实现代码如下\nvoid step(NODE&amp; tree)&#123;\n\tfor(auto i&#x3D;tree.data.begin();i!&#x3D;tree.data.end();++i)&#123;\n\t\tfor(auto j&#x3D;i+1;j!&#x3D;tree.data.end();++j)\n\t&#125;\n&#125;&#x2F;&#x2F;类似于冒泡排序循环\n\nn个数转换为n-1在前文介绍中，我们推断2个数合成1个数一共有4~5种可能，那么我们设定每个非叶子节点有5个子节点（如下代码中t1,t2,t3,t4,t5;）并且使用.data.push_back将加减乘除的得数赋予t1,t2,t3,t4,t5;，其次使用tree.children.push_back将t1,t2,t3,t4,t5;作为孩子结点，其中，在进行除法（t5）时需要进行判断除数是否为0以及是否能够整除\nvoid step(NODE&amp; tree)&#123;\n\tfor(auto i&#x3D;tree.data.begin();i!&#x3D;tree.data.end();++i)&#123;\n\t\tfor(auto j&#x3D;i+1;j!&#x3D;tree.data.end();++j)&#123;\n\t\t\tNODE t1,t2,t3,t4,t5;&#x2F;&#x2F;孩子结点 \n\t\t\tint x&#x3D;*i,y&#x3D;*j;\n\t\t\tt1.data.push_back(x+y); \n\t\t\tt2.data.push_back(x-y); \n\t\t\tt3.data.push_back(y-x); \n\t\t\tt4.data.push_back(x*y); \n\t\t\ttree.children.push_back(t1);\n\t\t\ttree.children.push_back(t2);\n\t\t\ttree.children.push_back(t3);\n\t\t\ttree.children.push_back(t4);\n\t\t\t\n\t\t\t\n\t\t\tif(x&amp;&amp;y&#x2F;*排除0*&#x2F;)\n\t\t\t\tif(x%y&#x3D;&#x3D;0)&#123;\n\t\t\t\t\tt5.data.push_back(x&#x2F;y); \n\t\t\t\t\ttree.children.push_back(t5);\n\t\t\t\t&#125;\n\t\t\t\t\t\n\t\t\t\telse if(y%x&#x3D;&#x3D;0)&#123;\n\t\t\t\t\tt5.data.push_back(y&#x2F;x); \n\t\t\t\t\ttree.children.push_back(t5);\n\t\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n\n此时我们的main函数中只在根节点中存放了两个数，为了验证step函数是否正确，我们需要一个输出\nint main()&#123;\n\tana_tree.data &#x3D; &#123;3,7&#125;;\n\tstep(ana_tree);\n\tfor(auto child:ana_tree.children)&#123;\n\t\tfor(auto num:child.data)&#123;\n\t\t\tprintf(&quot;%d\\t&quot;,num);\n\t\t&#125;\n\t\tprintf(&quot;\\n&quot;);\n\t&#125;\n\treturn 0;\n&#125; \n\n\n\n\n\n\n\n\n\n\nchild就是每个子节点，num是子节点中所有的数；然后把每个子节点的数进行输出\n将n-2个数加入到子节点此时我们的程序可以计算2个数，但是我们还剩下了n-2（设最初有n个数）个数还没有放入子节点，此时这个n是个变量（我们在编写程序的时候没有确定n的个数），所以我们需要加入一个for(auto k=tree.data.begin();k!=tree.data.end();++k)循环，其中if(k==i||k==j) continue;去除i,j,将剩下的存入t1-t5；\n将x记为i的数值，y记为j的数值int x=i-&gt;number,y=j-&gt;number;\n然后在t1~t5中储入格式为&#123;x+y,make_trace(i,&quot;+&quot;,j)&#125;来记录加减乘除的符号方便溯源\nvoid step(NODE&amp; tree)&#123;\n\tfor(auto i&#x3D;tree.data.begin();i!&#x3D;tree.data.end();++i)&#123;\n\t\tfor(auto j&#x3D;i+1;j!&#x3D;tree.data.end();++j)&#123;\n\t\t\tNODE t1,t2,t3,t4,t5;&#x2F;&#x2F;孩子结点 \n\t\t\tfor(auto k&#x3D;tree.data.begin();k!&#x3D;tree.data.end();++k)&#123;\n\t\t\t\tif(k&#x3D;&#x3D;i||k&#x3D;&#x3D;j) continue;\n\t\t\t\tt1.data.push_back(*k); \n\t\t\t\tt2.data.push_back(*k); \n\t\t\t\tt3.data.push_back(*k); \n\t\t\t\tt4.data.push_back(*k);\n\t\t\t\tt5.data.push_back(*k);\n\t\t\t&#125;\n            \n\t\t\tint x&#x3D;i-&gt;number,y&#x3D;j-&gt;number;\n\t\t\tt1.data.push_back(&#123;x+y,make_trace(i,&quot;+&quot;,j)&#125;); \n\t\t\tt2.data.push_back(&#123;x-y,make_trace(i,&quot;-&quot;,j)&#125;); \n\t\t\tt3.data.push_back(&#123;y-x,make_trace(j,&quot;-&quot;,i)&#125;); \n\t\t\tt4.data.push_back(&#123;x*y,make_trace(i,&quot;*&quot;,j)&#125;); \t\t\t\n\t\t\t\n\t\t\ttree.children.push_back(t1);\n\t\t\ttree.children.push_back(t2);\n\t\t\ttree.children.push_back(t3);\n\t\t\ttree.children.push_back(t4);\n\t\t\t\n\t\t\tif(x&amp;&amp;y&#x2F;*排除0*&#x2F;)\n\t\t\t\tif(x%y&#x3D;&#x3D;0)&#123;\n\t\t\t\t\tt5.data.push_back(&#123;x&#x2F;y,make_trace(i,&quot;&#x2F;&quot;,j)&#125;); \n\t\t\t\t\ttree.children.push_back(t5);\n\t\t\t\t&#125;\n\t\t\t\t\t\n\t\t\t\telse if(y%x&#x3D;&#x3D;0)&#123;\n\t\t\t\t\tt5.data.push_back(&#123;y&#x2F;x,make_trace(j,&quot;&#x2F;&quot;,i)&#125;); \n\t\t\t\t\ttree.children.push_back(t5);\n\t\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n\n在main函数中\nint main()&#123;\n\tprintf(&quot;请输入四个数：&quot;); \n\tfor(int i &#x3D; 0;i&lt;4;++i)&#123;\n\t\tint n;\n\t\tscanf(&quot;%d&quot;,&amp;n);\n\t\tana_tree.data.push_back(&#123;n,std::to_string(n)&#125;);\n\t&#125;\n\t\n\tstep(ana_tree);\n\tfor(NODE&amp; child2: ana_tree.children)&#123;\n\t\tstep(child2);\n\t&#125;\n\tfor(NODE&amp; child2: ana_tree.children)&#123;\n\t\tfor(NODE&amp; child3: child2.children)&#123;\n\t\t\tstep(child3);\n\t\t&#125;\n\t&#125;\n\t\n\t\n\t\n\tint count&#x3D;0,j&#x3D;0;\n\tfor(auto child2:ana_tree.children)&#123;\n\t\tfor(auto child3:child2.children)&#123;\n\t\t\tfor(auto child4:child3.children)&#123;\n\t\t\t\tif(child4.data.begin()-&gt;number!&#x3D;24) continue;\n\t\t\t\tprintf(&quot;第%d组解法：%s\\n&quot;,++count,child4.data.begin()-&gt;trace.c_str());\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\t\tif(count&#x3D;&#x3D;0)&#123;\n\t\t\tprintf(&quot;无解\\n&quot;); \n\t\t&#125;\n\t\t\n\treturn 0;\n&#125; \n\n\n\n\n\n完整代码#include&lt;stdio.h&gt;\n#include&lt;vector&gt;\n#include&lt;string&gt;\n\nstruct element&#123;\n\tint number;\n\tstd::string trace;\n&#125;;\n\n\nstruct NODE&#123;\n\tstd::vector&lt;element&gt; data;\n\tstd::vector&lt;NODE&gt; children;\n&#125; ana_tree;\n\nstd::string make_trace(\tstd::vector&lt;element&gt;::iterator i,std::string op,std::vector&lt;element&gt;::iterator j)&#123;\n\t\n\treturn &quot;(&quot;+i-&gt;trace+&quot;+&quot;+j-&gt;trace+&quot;)&quot;;\n&#125;\n\nvoid step(NODE&amp; tree)&#123;\n\tfor(auto i&#x3D;tree.data.begin();i!&#x3D;tree.data.end();++i)&#123;\n\t\tfor(auto j&#x3D;i+1;j!&#x3D;tree.data.end();++j)&#123;\n\t\t\tNODE t1,t2,t3,t4,t5;\n\t\t\tfor(auto k&#x3D;tree.data.begin();k!&#x3D;tree.data.end();++k)&#123;\n\t\t\t\tif(k&#x3D;&#x3D;i||k&#x3D;&#x3D;j) continue;\n\t\t\t\tt1.data.push_back(*k); \n\t\t\t\tt2.data.push_back(*k); \n\t\t\t\tt3.data.push_back(*k); \n\t\t\t\tt4.data.push_back(*k);\n\t\t\t\tt5.data.push_back(*k);\n\t\t\t\t\n\t\t\t&#125;\n\t\t\tint x&#x3D;i-&gt;number,y&#x3D;j-&gt;number;\n\t\t\tt1.data.push_back(&#123;x+y,make_trace(i,&quot;+&quot;,j)&#125;); \n\t\t\tt2.data.push_back(&#123;x-y,make_trace(i,&quot;-&quot;,j)&#125;); \n\t\t\tt3.data.push_back(&#123;y-x,make_trace(j,&quot;-&quot;,i)&#125;); \n\t\t\tt4.data.push_back(&#123;x*y,make_trace(i,&quot;*&quot;,j)&#125;); \t\t\t\n\t\t\t\n\n\t\t\ttree.children.push_back(t1);\n\t\t\ttree.children.push_back(t2);\n\t\t\ttree.children.push_back(t3);\n\t\t\ttree.children.push_back(t4);\n\t\t\t\n\t\t\t\n\t\t\tif(x&amp;&amp;y&#x2F;*排除0*&#x2F;)\n\t\t\t\tif(x%y&#x3D;&#x3D;0)&#123;\n\t\t\t\t\tt5.data.push_back(&#123;x&#x2F;y,make_trace(i,&quot;&#x2F;&quot;,j)&#125;); \n\t\t\t\t\ttree.children.push_back(t5);\n\t\t\t\t&#125;\n\t\t\t\t\t\n\t\t\t\telse if(y%x&#x3D;&#x3D;0)&#123;\n\t\t\t\t\tt5.data.push_back(&#123;y&#x2F;x,make_trace(j,&quot;&#x2F;&quot;,i)&#125;); \n\t\t\t\t\ttree.children.push_back(t5);\n\t\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\nint main()&#123;\n\tprintf(&quot;请输入四个数：&quot;); \n\tfor(int i &#x3D; 0;i&lt;4;++i)&#123;\n\t\tint n;\n\t\tscanf(&quot;%d&quot;,&amp;n);\n\t\tana_tree.data.push_back(&#123;n,std::to_string(n)&#125;);\n\t&#125;\n\t\n\tstep(ana_tree);\n\tfor(NODE&amp; child2: ana_tree.children)&#123;\n\t\tstep(child2);\n\t&#125;\n\tfor(NODE&amp; child2: ana_tree.children)&#123;\n\t\tfor(NODE&amp; child3: child2.children)&#123;\n\t\t\tstep(child3);\n\t\t&#125;\n\t&#125;\n\t\n\t\n\t\n\tint count&#x3D;0,j&#x3D;0;\n\tfor(auto child2:ana_tree.children)&#123;\n\t\tfor(auto child3:child2.children)&#123;\n\t\t\tfor(auto child4:child3.children)&#123;\n\t\t\t\tif(child4.data.begin()-&gt;number!&#x3D;24) continue;\n\t\t\t\tprintf(&quot;第%d组解法：%s\\n&quot;,++count,child4.data.begin()-&gt;trace.c_str());\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\t\tif(count&#x3D;&#x3D;0)&#123;\n\t\t\tprintf(&quot;无解\\n&quot;); \n\t\t&#125;\n\t\t\n\treturn 0;\n&#125; \n\n","slug":"Point-24-Game","date":"2022-06-09T03:06:24.000Z","categories_index":"","tags_index":"24点","author_index":"ACbug"},{"id":"fe68a41eeb4610b86a3bfb5b3b4407ee","title":"【实例1の更新2】表达式求值——加入括号运算","content":"前段时间我们制作了一个表达式求值的程序，\n我们赋予他基本框架与功能：【实例】表达式求值——利用stack实现五种运算符的运算 | 《课程设计》笔记 (i-nmb.cn)\n以及更新了一目运算符的支持：【实例更新】表达式求值——加入新的单目运算符 | 《课程设计》笔记 (i-nmb.cn)\n问题引入我们在经过这两个步骤之后，我们可以基本实现 表达式的求值操作 ，但是L 2 8 =没有括号就显得十分奇怪，并且我们在输入其他字符时报错方法还可以加以优化，让程序能够定位错误。\n所以目前我们需要解决的问题有两种，即：\n1.加入括号进行运算2.优化报错方法一、加入括号首先我们要进行加入括号的运算方法\n问题思考1.在前面的单目运算符以及双目运算符中，我们需要进行数的运算，那么加入括号，操作数又有什么变化？\n2.括号的特点是什么？他的左右运算符有没有什么特点？\n3.插入括号后，具体的算法（或者说 运算流程 ）是怎么样子的？\n4.如何“优雅地”添加括号并且不让程序做很大改动？\n这些问题我们需要思考与解决，以下为思考解决的部分过程\n加入括号，操作数又有什么变化？无论是单目运算符或者是双目运算符，其本质为运算符，是处理数的一种符号，只是运算过程中在处理 操作数的数目 的多少而划分。\n但是括号不是数学中的运算符号，他并没有处理操作数，没有改变操作数的数目和数值，他只是单纯的改变运算符之间的优先级、只是运算顺序的辅助符号。添加括号时 在栈顶的操作数 就在栈顶，没有任何变化。\n括号的特点是什么？1.因为括号不是数学中的运算符号，括号最直接的特点就是，加入左括号时，不改变在左括号（之前的其他符号的运算顺序，并且在右括号）之前，都正常运算（即括号内的正常运算），左括号需要等待右括号才进行出栈\n2.由1可以推断，无论左括号前面是什么，直接进栈；左括号后面的符号只要不是右括号，左括号始终不出栈，右括号始终不进栈。\n具体的算法（或者说 运算流程 ）比如3*(2+4)=\n首先等号入栈[history.top()]\n第一步，3入栈 operands\n第二步， * 与history.top()（&#x3D;）优先级比较， * 入栈。\n第三步，由上述问题，无论左括号前面是什么，直接进栈，所以(入栈\n第四步，2入栈\n第五步，左括号与+进行优先级比较，由上述括号的特点可知：左括号后面的符号只要不是右括号，左括号始终不出栈，所以开始计算\n第六步，输入4入栈，两次取出栈顶的元素（4和2）并进行＋运算，得数为6，压入 operands栈顶，弹出 + 号\n第七步，输入右括号，与栈顶history.top()的左括号匹配，所以弹出左括号，并且右括号始终不进栈。\n第八步，输入等号，等号优先级最小，先运算现在栈顶history.top()的 * 号，连续从栈顶取出两个元素相乘，得数18，弹出 * 号\n第九步，此时栈顶[history.top()]为“&#x3D;”，与输入的等号相等，程序结束，输出operands.top()【此时为得数】\n如何“优雅地”添加括号？根据以上括号的特点及运算流程\n我们可以知道：\n1.无论左括号前面是什么，直接进栈；\n2.左括号后面的符号只要不是右括号，左括号始终不出栈，并且将符号压入栈\n3.当等到右括号，则开始计算【等到右括号，“（）”内的数计算完毕】\n4.当等到右括号，则弹出左括号\n换成伪代码的形式将以上四点转换成伪代码的形式：\n\nif(op==&#39;(&#39;)&#123;push(op)&#125;\n\ntop==&#39;(&#39;&amp;&amp;op!=&#39;)&#39;:push(op)\n\nif(op==&#39;)&#39;):calc\n\ntop==&#39;(&#39;&amp;&amp;op==&#39;)&#39;:pop(&#39;(&#39;)\n\n\n将伪代码转换为现实以上的伪代码只是我们的“梦想”，要让其成为现实的道路并不容易。\n因为我们之前的程序大体以及框架已经确定，不能重新打乱和改变。\n那么我们如何“优雅地”添加括号并且不让程序做很大改动？\n答案是把括号作为一种特殊的“运算符”加入map\n我们需要用以下特性：\n\n\n\n\n\n\n\n\n\n1.无论左括号前面是什么，直接进栈\n2.只要不是右括号，左括号始终不出栈\n3.右括号始终不进栈\n得出以下结论\n1.（左括号的右优先级要非常大）\n2.（左括号的左优先级要非常小）\n3.（右括号的右优先级非常小）\n转为代码\nstd::map&lt;oper, prv_num_t&gt;  p_num&#x3D;&#123;\n…………\n​\t&#123;&#39;(&#39;,&#123;99,1&#125;&#125;,&#x2F;&#x2F;左边的优先数代表在栈顶的优先数\n​\t&#123;&#39;)&#39;,&#123;0,99&#125;&#125;,&#x2F;&#x2F;右边的优先数代表在op中的优先数，\n    &#x2F;&#x2F;因为)不可能在栈内，所以左优先数为0，代表错误\n…………\n&#125;\n\n我们重新审查代码，使用以上代码，可以实现以下目标：\n1.无论左括号前面是什么，直接进栈；if(op==&#39;(&#39;)&#123;push(op)&#125;\n2.左括号后面的符号只要不是右括号，左括号始终不出栈，并且将符号压入栈 top==&#39;(&#39;&amp;&amp;op!=&#39;)&#39;:push(op)\n3.当等到右括号，则开始计算 if(op==&#39;)&#39;):calc【等到右括号，“（）”内的数计算完毕】\n但是还有最后一点没有实现\n即：4.当等到右括号，则弹出左括号top==&#39;(&#39;&amp;&amp;op==&#39;)&#39;:pop(&#39;(&#39;)\n此时我们必须修改源代码，在之前的判断等号与哨兵相等之前（if(prior(history.top(),op)==0) break;）根据伪代码if(top==&#39;(&#39;&amp;&amp;op==&#39;)&#39;):pop(&#39;(&#39;)加入以下代码，\nif(op&#x3D;&#x3D;&quot;)&quot;)&#123;\n\t\t\thistory.pop();\n\t\t\tcontinue;\n\t\t&#125; \n\n因为左括号的左优先数&#x3D;&#x3D;右括号的右优先数，如果经过if(prior(history.top(),op)==0) break;那就跳出循环，运算就出错了，所以我们应该在此之前加入代码即可\nwhile(1)\n\t&#123;\n\t&#x2F;&#x2F;scanf(&quot;%f %c&quot;,&amp;x,&amp;op); 3+40&#x3D;;3+C0&#x3D;两个符号合起来，2L10&#x3D;，2 10 L&#x3D; ，L 2 10 &#x3D;；1 2 3 + *&#x3D; \n\tscanf(&quot; %c&quot;,&amp;op);&#x2F;&#x2F;预读下一位数 \n\tif(op&#x3D;&#x3D;&#39;,&#39;) continue;\n&#x2F;&#x2F;\tif(op是数字)\n\tif(isdigit(op)) &#123;&#x2F;&#x2F;isdigiy判断是否是数字 \n\t\tungetc(op, stdin);&#x2F;&#x2F;还回字符 ,还给stdin（键盘） \n\t\tscanf(&quot;%f&quot;,&amp;x);\n\t\toperands.push(x);\n\t\tcontinue; \n\t&#125;\t\n\twhile(prior(history.top(),op)&lt;0)&#123;\n\t\toperands.push(calc());\n\t\thistory.pop();\n\t&#125;\n+\t\tif(op&#x3D;&#x3D;&#39;)&#39;)&#123;\n+\t\t\thistory.pop();\n+\t\t\tcontinue;\n+\t\t&#125; \n\t\tif(prior(history.top(),op)&#x3D;&#x3D;0) break;\n\t\thistory.push(op);\n\t&#125;\n\n此时我们基本实现了加入括号的问题了\n二、优化报错方法解决了上面的问题，在输入右括号而不输入左括号，或者输入其他不识别的运算符时，报错代码来自\n\n\n这样不利于我们定位出错的位置，所以我们需要优化程序：优化报错方法\n若我们输入其他错误字符时，若需要报错，则需要正在通过map函数查找字符对应的优先数的函数中int prior(oper op1, oper op2)进行\n在其中加入以下代码\nint prior(oper op1, oper op2)\n&#123;\n+\tif(p_num.find(op1)&#x3D;&#x3D;p_num.end()||p_num[op1].left&#x3D;&#x3D;0)&#123; &#x2F;&#x2F;如果找不到运算符的优先数||左优先数&#x3D;0\n+\tprintf(&quot;错误的运算符：%c\\n【程序即将终止】&quot;,op1);\n+\texit (-1);\t&#x2F;&#x2F;异常退出，终止程序\n+\t&#125;\n+\tif(p_num.find(op2)&#x3D;&#x3D;p_num.end()||p_num[op1].right&#x3D;&#x3D;0)&#123; &#x2F;&#x2F;如果找不到运算符的优先数||右优先数&#x3D;0\n+\tprintf(&quot;错误的运算符：%c\\n【程序即将终止】&quot;,op2);\n+\texit (-1);\n+\t&#125;\n\treturn p_num[op1].left - p_num[op2].right;\n&#125;\n\n\n\n若我们在没有左括号的情况下输入右括号，报错，则需要在字符压入栈之前判断\noperand solve()\n&#x2F;*****************************************\n* 2. 输入下一个运算符op；\n* 3. while(prior(h.top(),op)&lt;0)\n*    栈顶元素出栈并计算；\n* 4. if(prior(h.top(),op)&#x3D;&#x3D;0)结束；\n* 5. if(prior(h.top(),op)&gt;0) h.push(op);\n*******************************************&#x2F;\n&#123;\n\toperand x, y;\n\toper op;\n\thistory.push(&#39;&#x3D;&#39;);\n\twhile(1)\n\t&#123;\n\t&#x2F;&#x2F;scanf(&quot;%f %c&quot;,&amp;x,&amp;op); 3+40&#x3D;;3+C0&#x3D;两个符号合起来，2L10&#x3D;，2 10 L&#x3D; ，L 2 10 &#x3D;；1 2 3 + *&#x3D; \n\tscanf(&quot; %c&quot;,&amp;op);&#x2F;&#x2F;预读下一位数 \n\tif(op&#x3D;&#x3D;&#39;,&#39;) continue;\n&#x2F;&#x2F;\tif(op是数字)\n\tif(isdigit(op)) &#123;&#x2F;&#x2F;isdigiy判断是否是数字 \n\t\tungetc(op, stdin);&#x2F;&#x2F;还回字符 ,还给stdin（键盘） \n\t\tscanf(&quot;%f&quot;,&amp;x);\n\t\toperands.push(x);\n\t\tcontinue; \n\t&#125;\t\n\twhile(prior(history.top(),op)&lt;0)&#123;\n\t\toperands.push(calc());\n\t\thistory.pop();\n\t&#125;\n+\t\tif(op&#x3D;&#x3D;&#39;)&#39;)&#123;\n+\t\t\tif(history.top()!&#x3D;&#39;(&#39;)&#123;\n+\t\t\t\tprintf(&quot;请检测：有没有成对括号\\n截止目前，计算&quot;); \n+\t\t\t\tbreak;\n+\t\t\t&#125;\n\t\t\thistory.pop();\n\t\t\tcontinue;\n\t\t&#125; \n\t\tif(prior(history.top(),op)&#x3D;&#x3D;0) break;\n\t\thistory.push(op);\n\t&#125;\n\treturn operands.top();\t\n&#125;\n\n\n\n三、问题解决完毕目前我们需要解决的问题有两种，即：\n1.加入括号进行运算2.优化报错方法而这两种在上面已经基本上解决了，至此完结~（撒花）\n下面附上更改后的代码\n#include&lt;stdio.h&gt;\n#include&lt;stack&gt;\n#include&lt;map&gt;\n#include&lt;math.h&gt;\ntypedef char oper;\ntypedef float operand;\nstd::stack&lt;oper&gt; history;\nstd::stack&lt;operand&gt; operands;\n\n&#x2F;*优先数表*&#x2F;\nstruct prv_num_t&#123;char left,right;&#125;;\nstd::map&lt;oper, prv_num_t&gt;  p_num&#x3D;&#123;\n\t&#123;&#39;+&#39;,&#123;81,82&#125;&#125;,\n\t&#123;&#39;-&#39;,&#123;81,82&#125;&#125;,\n\t&#123;&#39;*&#39;,&#123;41,42&#125;&#125;,\n\t&#123;&#39;&#x2F;&#39;,&#123;41,42&#125;&#125;,\n\t&#123;&#39;&#x3D;&#39;, &#123;100,100&#125;&#125;,\n\t&#123;&#39;^&#39;,&#123;32,31&#125;&#125;, \n\t&#123;&#39;L&#39;,&#123;22,21&#125;&#125;,&#x2F;&#x2F;对数运算符log(x,y) ；log (x,log(x,x)) ，右边优先 \n\t&#123;&#39;S&#39;,&#123;22,21&#125;&#125;,&#x2F;&#x2F;定义sin函数 \n\t&#123;&#39;C&#39;,&#123;22,21&#125;&#125;,&#x2F;&#x2F;定义cos函数; \n\t&#123;&#39;(&#39;,&#123;99,1&#125;&#125;,\n\t&#123;&#39;)&#39;,&#123;0,99&#125;&#125;,&#x2F;&#x2F;0作为错误标志 \n&#125;;\n&#x2F;&#x2F;&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;, &#x2F;* 0-9 *&#x2F;\n&#x2F;&#x2F;&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;, &#x2F;* 10-19 *&#x2F;\n&#x2F;&#x2F;&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;, &#x2F;* 20-29 *&#x2F;\n&#x2F;&#x2F;&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;, &#x2F;* 30-39 *&#x2F;\n&#x2F;&#x2F;&#123;0,0&#125;,&#123;0,0&#125;,&#123;41,42&#125;,&#123;81,82&#125;,&#123;0,0&#125;,&#123;81,82&#125;,&#123;0,0&#125;,&#123;41,42&#125;,&#123;0,0&#125;,&#123;0,0&#125;, &#x2F;* 40-49 *&#x2F;\n&#x2F;&#x2F;&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;, &#x2F;* 50-59 *&#x2F;\n&#x2F;&#x2F;&#123;0,0&#125;,&#123;100,100&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;, &#x2F;* 60-69 *&#x2F;\n&#x2F;&#x2F;&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;, &#x2F;* 70-79 *&#x2F;\n&#x2F;&#x2F;&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;, &#x2F;* 80-89 *&#x2F;\n&#x2F;&#x2F;&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;, &#x2F;* 90-99 *&#x2F;\n&#x2F;&#x2F;&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;, &#x2F;* 100-109 *&#x2F;\n&#x2F;&#x2F;&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;, &#x2F;* 110-119 *&#x2F;\n&#x2F;&#x2F;&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125; &#x2F;* 120-127 *&#x2F;\n&#x2F;&#x2F;&#125;;\n\n&#x2F;&#x2F;43 45 42 47 61\n\n\n&#x2F;*op1在左，op2在右*&#x2F; \n&#x2F;*返回值为负：op1优先级高于op2*&#x2F;\n&#x2F;*返回值为正：op2优先级高于op1*&#x2F;\n&#x2F;*返回值为0：op1优先级等于op2*&#x2F;\nint prior(oper op1, oper op2)\n&#123;\n\tif(p_num.find(op1)&#x3D;&#x3D;p_num.end()||p_num[op1].left&#x3D;&#x3D;0)&#123; &#x2F;&#x2F;如果找不到运算符\n\tprintf(&quot;错误的运算符：%c\\n【程序即将终止】&quot;,op1);\n\texit (-1);\n\t&#125;\n\tif(p_num.find(op2)&#x3D;&#x3D;p_num.end()||p_num[op1].right&#x3D;&#x3D;0)&#123; &#x2F;&#x2F;如果找不到运算符\n\tprintf(&quot;错误的运算符：%c\\n【程序即将终止】&quot;,op2);\n\texit (-1);\n\t&#125;\n\treturn p_num[op1].left - p_num[op2].right;\n&#125;\n#include&lt;ctype.h&gt;&#x2F;&#x2F;判断字符类型 \n#include&lt;string.h&gt; \noperand calc()&#123;\n\toperand x, y;\n&#x2F;&#x2F;\tif(history.top()是双目运算符)&#123;\n\tif(strchr(&quot;+-*&#x2F;^L&quot;,history.top()))&#123;&#x2F;&#x2F;strchr在 &quot;+-*&#x2F;^L&quot;找到 history.top()，如果找到返回位置，找不到返回空值【用来判断（整数和0）】 \n\t\ty &#x3D; operands.top();\n\t\toperands.pop();\n\t&#125;\n\n\tx &#x3D; operands.top();\n\toperands.pop();\n\tswitch(history.top())&#123;\n\t\tcase &#39;+&#39;: return x+y;\n\t\tcase &#39;-&#39;: return x-y;\n\t\tcase &#39;*&#39;: return x*y;\n\t\tcase &#39;&#x2F;&#39;: return x&#x2F;y;\n\t\tcase &#39;^&#39;: return pow(x,y);\n\t\tcase &#39;L&#39;: return log(y)&#x2F;log(x);&#x2F;&#x2F;log c库的对数换底公式 \n\t\tcase &#39;S&#39;: return sin(y); &#x2F;&#x2F;\t\tcase &#39;S&#39;: operands.push(x); return sin(y); \n\t\tcase &#39;C&#39;: return cos(y); &#x2F;&#x2F;\t\tcase &#39;C&#39;: operands.push(x); return cos(y);\n\t&#125;\n\tprintf(&quot;Err&quot;);\n\treturn -1;\n&#125;\noperand solve()\n&#x2F;*****************************************\n* 2. 输入下一个运算符op；\n* 3. while(prior(h.top(),op)&lt;0)\n*    栈顶元素出栈并计算；\n* 4. if(prior(h.top(),op)&#x3D;&#x3D;0)结束；\n* 5. if(prior(h.top(),op)&gt;0) h.push(op);\n*******************************************&#x2F;\n&#123;\n\toperand x, y;\n\toper op;\n\thistory.push(&#39;&#x3D;&#39;);\n\twhile(1)\n\t&#123;\n\t&#x2F;&#x2F;scanf(&quot;%f %c&quot;,&amp;x,&amp;op); 3+40&#x3D;;3+C0&#x3D;两个符号合起来，2L10&#x3D;，2 10 L&#x3D; ，L 2 10 &#x3D;；1 2 3 + *&#x3D; \n\tscanf(&quot; %c&quot;,&amp;op);&#x2F;&#x2F;预读下一位数 \n\tif(op&#x3D;&#x3D;&#39;,&#39;) continue;\n&#x2F;&#x2F;\tif(op是数字)\n\tif(isdigit(op)) &#123;&#x2F;&#x2F;isdigiy判断是否是数字 \n\t\tungetc(op, stdin);&#x2F;&#x2F;还回字符 ,还给stdin（键盘） \n\t\tscanf(&quot;%f&quot;,&amp;x);\n\t\toperands.push(x);\n\t\tcontinue; \n\t&#125;\t\n\twhile(prior(history.top(),op)&lt;0)&#123;\n\t\toperands.push(calc());\n\t\thistory.pop();\n\t&#125;\n\t\tif(op&#x3D;&#x3D;&#39;)&#39;)&#123;\n\t\t\tif(history.top()!&#x3D;&#39;(&#39;)&#123;\n\t\t\t\tprintf(&quot;请检测：有没有成对括号\\n截止目前，计算&quot;); \n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t\thistory.pop();\n\t\t\tcontinue;\n\t\t&#125; \n\t\tif(prior(history.top(),op)&#x3D;&#x3D;0) break;\n\t\thistory.push(op);\n\t&#125;\n\treturn operands.top();\t\n&#125;\n\nint main()\n&#123;\n&#x2F;&#x2F;\tprintf(&quot;%d %d %d %d %d&quot;, &#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;&#x2F;&#39;, &#39;&#x3D;&#39;);return 0;\n\tprintf(&quot;%g\\n&quot;, solve());\n\treturn 0;\n&#125;\n\n","slug":"example-optimization-2","date":"2022-05-24T11:20:52.000Z","categories_index":"","tags_index":"运算符","author_index":"ACbug"},{"id":"6c04c36ceec929560d9050b95673c3cf","title":"【实例1の更新1】表达式求值——加入新的单目运算符","content":"前段时间我们学习了利用stack实现五种运算符的运算：【实例】表达式求值——利用stack实现五种运算符的运算 | 《课程设计》笔记 (i-nmb.cn)\n实际上我们的表达式求值中并不是只有这5种运算，他还包括了 指数、对数以及三角函数等等。\n今天我们就在原基础上逐一的实现 指数、对数以及三角函数 的表达式求值\n写在前面之前，在【实例】表达式求值——利用stack实现五种运算符的运算 | 《课程设计》笔记 (i-nmb.cn)中，我们做出了一下代码\n#include&lt;stdio.h&gt;\n#include&lt;stack&gt;\n#include&lt;map&gt;\n\ntypedef char oper;&#x2F;&#x2F;运算符\ntypedef float operand;\n\n&#x2F;*优先数表*&#x2F;\nstruct prv_num_t&#123;char left,right;&#125;;&#x2F;&#x2F;定义结构体 prv_num_t  _t代表类型 \n&#x2F;&#x2F;关键字只包含一部分数据项,就称为map\n&#x2F;&#x2F;关键字包含全部数据项,成为 \nstd::map&lt;oper, prv_num_t&gt; p_num&#x3D;&#123;\n\t&#123;&#39;+&#39;,&#123;81,82&#125;&#125;,\n\t&#123;&#39;-&#39;,&#123;81,82&#125;&#125;,\n\t&#123;&#39;*&#39;,&#123;41,42&#125;&#125;,\n\t&#123;&#39;&#x2F;&#39;,&#123;41,42&#125;&#125;,\n\t&#123;&#39;&#x3D;&#39;,&#123;100,100&#125;&#125;\n&#125;;\n\n\n&#x2F;*op1在左，op2在右*&#x2F;\n&#x2F;*返回值为负: op1优先级高于op2*&#x2F;\n&#x2F;*返回值为正: op2优先级高于op1*&#x2F;\n&#x2F;*返回值为0: op1优先级等于op2*&#x2F;\n\nint prior(oper op1, oper op2)&#123;\n\treturn p_num[op1].left - p_num[op2].right;\n&#125;\n\noperand solve()&#123;\n\toperand x, y;\n\toper op;\n\tstd::stack&lt;oper&gt; history;&#x2F;&#x2F;历史栈 \n\tstd::stack&lt;operand&gt; operands;\n\thistory.push(&#39;&#x3D;&#39;);&#x2F;&#x2F;输入等号，whach dog（士兵）进栈 \n\twhile(1)&#123;\n&#x2F;****************************************\n*2.  输入下一个运算符op;\n*3.  while（h.top()比op优先）&#123;\t栈顶元素出栈计算；&#125;\n*4.  if(h.top()&#x3D;&#x3D;&#39;&#x3D;&#39;&amp;&amp; op&#x3D;&#x3D;&#39;&#x3D;&#39;)&#123;结束&#125;\n*5.  h.push(op);\n*6.  转2。\n******************************************&#x2F;\n\t\tscanf(&quot;%f %c&quot;,&amp;x,&amp;op);\n\t\toperands.push(x);\n\t\twhile(prior(history.top(), op)&lt;0)&#123;\n\t\t\t\n\t\t\ty &#x3D; operands.top();\n\t\t\toperands.pop();\n\t\t\tx &#x3D; operands.top();\n\t\t\toperands.pop();\n\t\t\tswitch(history.top())&#123;\n\t\t\t\tcase &#39;+&#39;: operands.push(x + y) ; break;\n\t\t\t\tcase &#39;-&#39;: operands.push(x - y) ; break;\n\t\t\t\tcase &#39;*&#39;: operands.push(x * y) ; break;\n\t\t\t\tcase &#39;&#x2F;&#39;: operands.push(x &#x2F; y) ; break;\n\t\t\t&#125;\n\t\t\thistory.pop();\n\t\t&#125;\n\t\tif(prior(history.top(),op)&#x3D;&#x3D;0) break;\n\t\thistory.push(op);\n\t&#125;\n\treturn operands.top();\n&#125;\n\nint main()&#123;\n\tprintf(&quot;%g\\n&quot;,solve());\n\t\n\treturn 0;\n&#125;\n \n\n\n\n今天的实例更新，是建立再此代码基础上的\n实现目标1、优化之前的代码\n2、逐一的实现 指数、对数以及三角函数 的表达式求值\n1.优化代码在加入新功能之前，我们先审视之前我们敲击的代码，我们在operand solve()&#123;&#125;函数中使用了以下循环\noperand solve()&#123;\n\twhile(1)&#123;\n\t……………………………………………………\n\t\twhile(prior(history.top(), op)&lt;0)&#123;\n\t\t\ty &#x3D; operands.top();\n\t\t\toperands.pop();\n\t\t\tx &#x3D; operands.top();\n\t\t\toperands.pop();\n\t\t\tswitch(history.top())&#123;\n\t\t\t\tcase &#39;+&#39;: operands.push(x + y) ; break;\n\t\t\t\tcase &#39;-&#39;: operands.push(x - y) ; break;\n\t\t\t\tcase &#39;*&#39;: operands.push(x * y) ; break;\n\t\t\t\tcase &#39;&#x2F;&#39;: operands.push(x &#x2F; y) ; break;\n\t\t&#125;\n\t\t……………………………………\n\t&#125;\n\t…………………………………………\n&#125;\n\n这个循环实质上是一个运算核心，放在循环中，总是不太合适。\n所以我们把他提取出来，改造成一个函数operand calc()&#123;&#125;，返回类型为之前定义的operand（操作数）\noperand calc()在循环while(prior(history.top(),op)&lt;0)返回运算结果，若输入出错，则输出Err，返回-1\noperand calc()&#123;\n\toperand x, y;\n\ty &#x3D; operands.top();\n\toperands.pop();\n\tx &#x3D; operands.top();\n\toperands.pop();\n\tswitch(history.top())&#123;\n\t\tcase &#39;+&#39;: return x+y;&#x2F;&#x2F;当运算符为+时，在循环while(prior(history.top(),op)&lt;0)返回x+y运算结果\n\t\tcase &#39;-&#39;: return x-y;&#x2F;&#x2F;当运算符为-时，在循环while(prior(history.top(),op)&lt;0)返回x-y运算结果\n\t\tcase &#39;*&#39;: return x*y;&#x2F;&#x2F;当运算符为*时，在循环while(prior(history.top(),op)&lt;0)返回x*y运算结果\n\t\tcase &#39;&#x2F;&#39;: return x&#x2F;y;&#x2F;&#x2F;当运算符为&#x2F;时，在循环while(prior(history.top(),op)&lt;0)返回x&#x2F;y运算结果\n\t&#125;\n\tprintf(&quot;Err&quot;);\n\treturn -1;\n&#125;\n\n\n\n而原\twhile(prior(history.top(), op)&lt;0)&#123;&#125;循环体中改为\nwhile(prior(history.top(),op)&lt;0)&#123;\n\toperands.push(calc());\n\thistory.pop();\n&#125;\n\n\n\n最后将以下代码设置为全局变量\nstd::stack&lt;oper&gt; history;&#x2F;&#x2F;历史栈 \nstd::stack&lt;operand&gt; operands;\n\n至此优化结束，优化后的总代码为：\n#include&lt;stdio.h&gt;\n#include&lt;stack&gt;\n#include&lt;map&gt;\n\ntypedef char oper;&#x2F;&#x2F;运算符\ntypedef float operand;\nstd::stack&lt;oper&gt; history;&#x2F;&#x2F;历史栈 \nstd::stack&lt;operand&gt; operands;\n\n&#x2F;*优先数表*&#x2F;\nstruct prv_num_t&#123;char left,right;&#125;;&#x2F;&#x2F;定义结构体 prv_num_t  _t代表类型 \n&#x2F;&#x2F;关键字只包含一部分数据项,就称为map\n&#x2F;&#x2F;关键字包含全部数据项,成为 \nstd::map&lt;oper, prv_num_t&gt; p_num&#x3D;&#123;\n\t&#123;&#39;+&#39;,&#123;81,82&#125;&#125;,\n\t&#123;&#39;-&#39;,&#123;81,82&#125;&#125;,\n\t&#123;&#39;*&#39;,&#123;41,42&#125;&#125;,\n\t&#123;&#39;&#x2F;&#39;,&#123;41,42&#125;&#125;,\n\t&#123;&#39;&#x3D;&#39;,&#123;100,100&#125;&#125;\n&#125;;\n\n\n&#x2F;*op1在左，op2在右*&#x2F;\n&#x2F;*返回值为负: op1优先级高于op2*&#x2F;\n&#x2F;*返回值为正: op2优先级高于op1*&#x2F;\n&#x2F;*返回值为0: op1优先级等于op2*&#x2F;\n\nint prior(oper op1, oper op2)&#123;\n\treturn p_num[op1].left - p_num[op2].right;\n&#125;\n\n\noperand calc()&#123;\n\toperand x, y;\n\ty &#x3D; operands.top();\n\toperands.pop();\n\tx &#x3D; operands.top();\n\toperands.pop();\n\tswitch(history.top())&#123;\n\t\tcase &#39;+&#39;: return x+y;\n\t\tcase &#39;-&#39;: return x-y;\n\t\tcase &#39;*&#39;: return x*y;\n\t\tcase &#39;&#x2F;&#39;: return x&#x2F;y;\n\t&#125;\n\tprintf(&quot;Err&quot;);\n\treturn -1;\n&#125;\n\n\noperand solve()&#123;\n\toperand x, y;\n\toper op;\n\n\thistory.push(&#39;&#x3D;&#39;);&#x2F;&#x2F;输入等号，whach dog（士兵）进栈 \n\twhile(1)&#123;\n&#x2F;****************************************\n*2.  输入下一个运算符op;\n*3.  while（h.top()比op优先）&#123;\t栈顶元素出栈计算；&#125;\n*4.  if(h.top()&#x3D;&#x3D;&#39;&#x3D;&#39;&amp;&amp; op&#x3D;&#x3D;&#39;&#x3D;&#39;)&#123;结束&#125;\n*5.  h.push(op);\n*6.  转2。\n******************************************&#x2F;\n\t\tscanf(&quot;%f %c&quot;,&amp;x,&amp;op);\n\t\toperands.push(x);\n\t\twhile(prior(history.top(), op)&lt;0)&#123;\n\t\t\toperands.push(calc());\n\t\t\thistory.pop();\n\t\t&#125;\n\t\tif(prior(history.top(),op)&#x3D;&#x3D;0) break;\n\t\thistory.push(op);\n\t&#125;\n\treturn operands.top();\n&#125;\n\nint main()&#123;\n\tprintf(&quot;%g\\n&quot;,solve());\n\t\n\treturn 0;\n&#125;\n \n\n\n\n2.增加指数运算和对数运算符增加指数运算符增加指数运算相对简单，在map（std::map&lt;oper, prv_num_t&gt; p_num）里面增加&#123;&quot;关键字&quot;,&#123;左优先数,右优先数&#125;&#125;，左优先级大于右优先（从左到右运算）【2^3^2&#x3D;&#x3D;64!&#x3D;2^(3^2)】\n即\nstd::map&lt;oper, prv_num_t&gt; p_num&#x3D;&#123;\n\t&#123;&#39;+&#39;,&#123;81,82&#125;&#125;,\n\t&#123;&#39;-&#39;,&#123;81,82&#125;&#125;,\n\t&#123;&#39;*&#39;,&#123;41,42&#125;&#125;,\n\t&#123;&#39;&#x2F;&#39;,&#123;41,42&#125;&#125;,\n\t&#123;&#39;&#x3D;&#39;,&#123;100,100&#125;&#125;,\n    \n+    &#123;&#39;^&#39;,&#123;32,31&#125;&#125;\n    \n&#125;;\n\n\n\n并且在运算函数calc()&#123;&#125;加入返回运算值\n即\n\tcase &#39;*&#39;: return x*y;\n\tcase &#39;&#x2F;&#39;: return x&#x2F;y;\n\n+\tcase &#39;^&#39;: return pow(x,y);\n\n&#125;\nprintf(&quot;Err&quot;);\n\n因为用到了pow函数，所以我们在头文件加入#include&lt;math.h&gt;\n至此，增加指数运算符操作结束\n增加对数运算符同理\n在map（std::map&lt;oper, prv_num_t&gt; p_num）里面增加&#123;&quot;关键字&quot;,&#123;左优先数,右优先数&#125;&#125;，左优先级小于右优先（从右到左运算）【log （2,log(2,8))&#x3D;3】\nstd::map&lt;oper, prv_num_t&gt;  p_num&#x3D;&#123;\n\t&#123;&#39;+&#39;,&#123;81,82&#125;&#125;,\n\t&#123;&#39;-&#39;,&#123;81,82&#125;&#125;,\n\t&#123;&#39;*&#39;,&#123;41,42&#125;&#125;,\n\t&#123;&#39;&#x2F;&#39;,&#123;41,42&#125;&#125;,\n\t&#123;&#39;&#x3D;&#39;, &#123;100,100&#125;&#125;,\n\t&#123;&#39;^&#39;,&#123;32,31&#125;&#125;, \n    \n+\t&#123;&#39;L&#39;,&#123;22,21&#125;&#125;&#x2F;&#x2F;对数运算符log(x,y) ；log (x,log(x,x)) ，右边优先 \n    \n&#125;\nprintf(&quot;Err&quot;);\n\n\n\n在运算函数calc()&#123;&#125;加入返回运算值\n\tcase &#39;*&#39;: return x*y;\n\tcase &#39;&#x2F;&#39;: return x&#x2F;y;\n\tcase &#39;^&#39;: return pow(x,y);\n\t\n+\tcase &#39;L&#39;: return log(y)&#x2F;log(x);&#x2F;&#x2F;对数换底公式 ,以x（先输入的数）为底数\n\n&#125;\nprintf(&quot;Err&quot;);\n\n\n至此，增加对数运算符操作结束\n试试2L8= 答案是3\n3.增加三角函数（单目运算符）在map添加关键字\nstd::map&lt;oper, prv_num_t&gt;  p_num&#x3D;&#123;\n\t&#123;&#39;+&#39;,&#123;81,82&#125;&#125;,\n\t&#123;&#39;-&#39;,&#123;81,82&#125;&#125;,\n\t&#123;&#39;*&#39;,&#123;41,42&#125;&#125;,\n\t&#123;&#39;&#x2F;&#39;,&#123;41,42&#125;&#125;,\n\t&#123;&#39;&#x3D;&#39;, &#123;100,100&#125;&#125;,\n\t&#123;&#39;^&#39;,&#123;32,31&#125;&#125;, \n    &#123;&#39;L&#39;,&#123;22,21&#125;&#125;,\t&#x2F;&#x2F;对数运算符log(x,y) ；log (x,log(x,x)) ，右边优先 \n    \n+    &#123;&#39;S&#39;,&#123;22,21&#125;&#125;,&#x2F;&#x2F;定义sin函数 \n+\t&#123;&#39;C&#39;,&#123;22,21&#125;&#125;,&#x2F;&#x2F;定义cos函数; \n&#125;\nprintf(&quot;Err&quot;);\n\n\n\n\n\n\n\n在运算函数calc()&#123;&#125;加入返回运算值\n\tcase &#39;*&#39;: return x*y;\n\tcase &#39;&#x2F;&#39;: return x&#x2F;y;\n\tcase &#39;^&#39;: return pow(x,y);\n\tcase &#39;L&#39;: return log(y)&#x2F;log(x);&#x2F;&#x2F;对数换底公式 ,以x（先输入的数）为底数\n\n+\tcase &#39;S&#39;: return sin(y); \t\t\n+\tcase &#39;C&#39;: return cos(y); \n\n&#125;\nprintf(&quot;Err&quot;);\n\n\n至此，增加三角函数符号\n冲突之前我们增加的是双目运算符，遵循着 &#39;操作数&#39; &#39;运算符&#39; &#39;操作数&#39;\n现在，我们的单目运算符，遵循 &#39;运算符&#39; &#39;操作数&#39;\n一、输入模式不同的解决办法二者输入模式不同，怎么办？难道之前辛苦搭建的程序崩塌了？\n其实我们输入表达式的时候已经将完整的表达式输入了，此时我们只需要判断下一位是不是运算符，而进行对应计算，也就是预读下一位数\n预读下一位数如果是数字，那么返还给键盘（模拟键盘重新输入）\n预读下一位数如果不是数字，那么作为op（运算符）\n所以在while(1)&#123;&#125;处，更改以下代码\nwhile(1)&#123;\n&#x2F;****************************************\n*2.  输入下一个运算符op;\n*3.  while（h.top()比op优先）&#123;\t栈顶元素出栈计算；&#125;\n*4.  if(h.top()&#x3D;&#x3D;&#39;&#x3D;&#39;&amp;&amp; op&#x3D;&#x3D;&#39;&#x3D;&#39;)&#123;结束&#125;\n*5.  h.push(op);\n*6.  转2。\n******************************************&#x2F;\n\n-\t\tscanf(&quot;%f %c&quot;,&amp;x,&amp;op);\t\t&#x2F;&#x2F;scanf(&quot;%f %c&quot;,&amp;x,&amp;op); 3+40&#x3D;;3+C0&#x3D;两个符号合起来\n-\t\toperands.push(x);\n\n\t\n+\tscanf(&quot; %c&quot;,&amp;op);&#x2F;&#x2F;预读下一位数 \n\n+\tif(isdigit(op)) &#123;\t\t\t&#x2F;&#x2F;isdigiy判断是否是数字 &#x2F;&#x2F;if(op是数字) #include&lt;ctype.h&gt;&#x2F;&#x2F;判断字符类型 \n+\t\tungetc(op, stdin);\t\t&#x2F;&#x2F;还回字符 ,还给stdin（键盘）\n+\t\tscanf(&quot;%f&quot;,&amp;x);\n+\t\toperands.push(x);\n+\t\tcontinue; \n+\t&#125;\t\n\n并且增加头文件#include&lt;ctype.h&gt; \n此时输入模式不同的问题得以解决\n二、运算模式不同的解决如果是双目运算符，那么我们操作数栈的操作如下\ny &#x3D; operands.top();\noperands.pop();\nx &#x3D; operands.top();\noperands.pop();\n\n由此可见，我们在运算双目运算符的时候，把y赋予栈顶值，然后弹出栈顶以获取下一个数来赋予x，之后再一次弹出栈顶\n相当于一个双目运算符运算过后，弹出两个数\n而如果用单目运算符运算，只需要运算一个数\n也就是说，单目运算符运算过后，弹出一个数\n解决办法我们需要判断运算符是单目运算符还是双目运算符\nif(history.top()是双目运算符)&#123;\n\ty &#x3D; operands.top();\n\toperands.pop();\n&#125;\n\n如果是双目运算符我们就弹多走1个栈顶\n​\tif(history.top()是双目运算符)我们使用if(strchr(&quot;+-*/^L&quot;,history.top()))实现\n也就是在operand calc()函数中做以下操作\noperand calc()&#123;\n\toperand x, y;\n\t\n-\ty &#x3D; operands.top();\n-\toperands.pop();\n\n+\tif(strchr(&quot;+-*&#x2F;^L&quot;,history.top()))&#123;\t&#x2F;&#x2F;strchr在 &quot;+-*&#x2F;^L&quot;找到 history.top()，如果找到返回位置，找不到返回空值【用来判断（整数和0）】 \n+\t\ty &#x3D; operands.top();\n+\t\toperands.pop();\n+\t&#125;\n\t\n\tx &#x3D; operands.top();\n\toperands.pop();\n\tswitch(history.top())&#123;\n\t\tcase &#39;+&#39;: return x+y;\n\t\tcase &#39;-&#39;: return x-y;\n\t\tcase &#39;*&#39;: return x*y;\n\t\tcase &#39;&#x2F;&#39;: return x&#x2F;y;\n\t\tcase &#39;^&#39;: return pow(x,y);\n\t\tcase &#39;L&#39;: return log(y)&#x2F;log(x);&#x2F;&#x2F;log c库的对数换底公式 \n        case &#39;S&#39;: return sin(y);\n\t\tcase &#39;C&#39;: return cos(y); \n\t&#125;\n\tprintf(&quot;Err&quot;);\n\treturn -1;\n&#125;\n\n\n\n我们引用了strchr(&quot;+-*/^L&quot;,history.top())因此需要加入#include&lt;string.h&gt; \n问题解决\n最终代码处理完毕后最终代码如下\n#include&lt;stdio.h&gt;\n#include&lt;stack&gt;\n#include&lt;map&gt;\n#include&lt;math.h&gt;\ntypedef char oper;&#x2F;&#x2F;运算符\ntypedef float operand;\nstd::stack&lt;oper&gt; history;&#x2F;&#x2F;历史栈 \nstd::stack&lt;operand&gt; operands;\n\n&#x2F;*优先数表*&#x2F;\nstruct prv_num_t&#123;char left,right;&#125;;&#x2F;&#x2F;定义结构体 prv_num_t  _t代表类型 \n&#x2F;&#x2F;关键字只包含一部分数据项,就称为map\n&#x2F;&#x2F;关键字包含全部数据项,成为 \nstd::map&lt;oper, prv_num_t&gt; p_num&#x3D;&#123;\n\t&#123;&#39;+&#39;,&#123;81,82&#125;&#125;,\n\t&#123;&#39;-&#39;,&#123;81,82&#125;&#125;,\n\t&#123;&#39;*&#39;,&#123;41,42&#125;&#125;,\n\t&#123;&#39;&#x2F;&#39;,&#123;41,42&#125;&#125;,\n\t&#123;&#39;&#x3D;&#39;,&#123;100,100&#125;&#125;,\n\t&#123;&#39;^&#39;,&#123;32,31&#125;&#125;, \n\t&#123;&#39;L&#39;,&#123;22,21&#125;&#125;,&#x2F;&#x2F;对数运算符log(x,y) ；log (x,log(x,x)) ，右边优先 \n\t&#123;&#39;S&#39;,&#123;22,21&#125;&#125;,&#x2F;&#x2F;定义sin函数 \n\t&#123;&#39;C&#39;,&#123;22,21&#125;&#125;,&#x2F;&#x2F;定义cos函数; \n&#125;;\n\n\n&#x2F;*op1在左，op2在右*&#x2F;\n&#x2F;*返回值为负: op1优先级高于op2*&#x2F;\n&#x2F;*返回值为正: op2优先级高于op1*&#x2F;\n&#x2F;*返回值为0: op1优先级等于op2*&#x2F;\n\nint prior(oper op1, oper op2)&#123;\n\treturn p_num[op1].left - p_num[op2].right;\n&#125;\n\n#include&lt;string.h&gt;\noperand calc()&#123;\n\toperand x, y;\n&#x2F;&#x2F;\tif(history.top()是双目运算符)&#123;\n\tif(strchr(&quot;+-*&#x2F;^L&quot;,history.top()))&#123;&#x2F;&#x2F;strchr在 &quot;+-*&#x2F;^L&quot;找到 history.top()，如果找到返回位置，找不到返回空值【用来判断（整数和0）】 \n\t\ty &#x3D; operands.top();\n\t\toperands.pop();\n\t&#125;\n\tx &#x3D; operands.top();\n\toperands.pop();\n\tswitch(history.top())&#123;\n\t\tcase &#39;+&#39;: return x+y;\n\t\tcase &#39;-&#39;: return x-y;\n\t\tcase &#39;*&#39;: return x*y;\n\t\tcase &#39;&#x2F;&#39;: return x&#x2F;y;\n\t\tcase &#39;^&#39;: return pow(x,y);\n\t\tcase &#39;L&#39;: return log(y)&#x2F;log(x);&#x2F;&#x2F;log c库的对数换底公式\n\t\tcase &#39;S&#39;: return sin(y); \n\t\tcase &#39;C&#39;: return cos(y); \n\t&#125;\n\tprintf(&quot;Err&quot;);\n\treturn -1;\n&#125;\n\n\noperand solve()&#123;\n\toperand x, y;\n\toper op;\n\n\thistory.push(&#39;&#x3D;&#39;);&#x2F;&#x2F;输入等号，whach dog（士兵）进栈 \n\twhile(1)&#123;\n&#x2F;****************************************\n*2.  输入下一个运算符op;\n*3.  while（h.top()比op优先）&#123;\t栈顶元素出栈计算；&#125;\n*4.  if(h.top()&#x3D;&#x3D;&#39;&#x3D;&#39;&amp;&amp; op&#x3D;&#x3D;&#39;&#x3D;&#39;)&#123;结束&#125;\n*5.  h.push(op);\n*6.  转2。\n******************************************&#x2F;\n\tscanf(&quot; %c&quot;,&amp;op);&#x2F;&#x2F;预读下一位数 \n&#x2F;&#x2F;\tif(op是数字)\n\tif(isdigit(op)) &#123;&#x2F;&#x2F;isdigiy判断是否是数字 \n\t\tungetc(op, stdin);&#x2F;&#x2F;还回字符 ,还给stdin（键盘） \n\t\tscanf(&quot;%f&quot;,&amp;x);\n\t\toperands.push(x);\n\t\tcontinue; \n\t&#125;\t\n\t\twhile(prior(history.top(), op)&lt;0)&#123;\n\t\t\toperands.push(calc());\n\t\t\thistory.pop();\n\t\t&#125;\n\t\tif(prior(history.top(),op)&#x3D;&#x3D;0) break;\n\t\thistory.push(op);\n\t&#125;\n\treturn operands.top();\n&#125;\n\nint main()&#123;\n\tprintf(&quot;%g\\n&quot;,solve());\n\t\n\treturn 0;\n&#125;\n \n\n","slug":"example-optimization-1","date":"2022-05-23T22:38:52.000Z","categories_index":"","tags_index":"运算符","author_index":"ACbug"},{"id":"2ee39bc7ef8592ef83ca72fba476f564","title":"【实例1】表达式求值——利用stack实现五种运算符的运算","content":"看了标题有人会问，运算符的运算实现？直接printf(“%d”,a+b*c);不就完了么？\n当然没有那么简单！\n本篇带读者走进如何用stack来实现加减乘除运算\n[原则：没有解决方案之前绝不能试图开始编程]在我们拿到题目后，有些读者习惯于直接开始敲代码，我觉得这样不方便思路的养成。所以 没有解决方案之前绝不能试图开始编程\n那么解决方案哪里来？！探索解决方案，可以从百度来，可以问专业学者等等。\n[解决方案一:算符优先文法]给不同运算符赋予“优先级”的概念优先级相同的运算符按照结合性的顺序计算（从左到右或从右到左）为了更简单地比较不同运算符的优先级给每个运算符定义一个称为“优先数”的整数（以下优先数越小，优先级越高）\n+：81，82\n-：81，82\n*：41，42\n&#x2F;：41，42\n&#x3D;：100，100\n3+4*5+2&#x3D;\n\n确定运算顺序:专家告诉我们：使用计算栈h（保存元素是运算符）{a1, a2,…, an, k} 此时，k是watch dog，也就是哨兵for (i&#x3D;1 ;ai !&#x3D;k ; ++k) ;\n实践方案\nh.push(‘&#x3D;’);\t&#x2F;&#x2F; 用于判断结束，例如：若输入6=(当栈顶的&#x3D;和输入的&#x3D;匹配，则结束)\n\n输入下一个运算符op;\n\nwhile（h.top()比op优先）{\t栈顶元素出栈计算；}\n\nif(h.top()&#x3D;&#x3D;’&#x3D;’&amp;&amp; op&#x3D;&#x3D;’&#x3D;’){结束}\n\nh.push(op);\n\n转2。（循环）\n\n\n首先，根据实践方案进行初始化根据上述实践方案，我们可以知道我们需要用到stack、stdio.h的头文件，并且需要用到oper（运算符）、和operand（操作数）,而运算符是char型，操作数为float型\n所以我们在文件头需要编写以下代码\n#include&lt;stdio.h&gt;\n#include&lt;stack&gt;\n\ntypedef char oper;\t&#x2F;&#x2F;运算符\ntypedef float operand;\n\n\n\n其次，建立实践方案对应的函数我们初始化完成后，如果要解决问题，则需要建立解决问题的函数\n于是我们建立一个名为solve的函数，因为是处理数据的，将要返回处理数据的数值，而数值的类型上述定义是operand类型\n需要加入operand solve()&#123;&#125;函数。\n我们在处理运算符时，需要判断运算符的优先级，我们需要一个函数判断左边和右边优先级大小，所以我们引入一个函数 根据定义的一个称为“优先数”的整数（优先数越小，优先级越高）来判断优先级大小。\n我们使用int prior(oper op1, oper op2)&#123;&#125;，根据优先数相减得到的int型的正负值判断，其中op1为左符号类型为定义的oper，op2为右符号（新符号）\n最后使用必须要有main函数main()&#123;&#125;\n所以构造完毕后，总代码如下\n#include&lt;stdio.h&gt;\n#include&lt;stack&gt;\n\ntypedef char oper;\t\t&#x2F;&#x2F;运算符\ntypedef float operand;\t&#x2F;&#x2F;运算数\n\n\nint prior(oper op1, oper op2)&#123;\n    return;\n&#125;\n\noperand solve()&#123;\n\treturn;\n&#125;\n\nmain()&#123;\n    \n&#125;\n\n\n\n处理函数的丰富我们主要的处理函数是operand solve()\n最简单的加减乘除运算是拥有两个数和一个运算符组成，所以我们要先定义两个数和运算符\n我们还需要两个栈（一个存放操作数，一个存放操作符）\n完善函数如下\noperand solute()&#123;\n\toperand x, y;\n\toper op;\n\tstd::stack&lt;oper&gt; history;\t\t&#x2F;&#x2F;历史栈 ,存放历史操作符号\n\tstd::stack&lt;operand&gt; operands;\t&#x2F;&#x2F;存放操作数\n&#125;\n\n\n\n我们根据实践方案（点击转到）\n\n\n\n\n\n\n\n\n\n\nh.push(‘&#x3D;’);\t&#x2F;&#x2F; 用于判断结束，例如：若输入6=(当栈顶的&#x3D;和输入的&#x3D;匹配，则结束)\n\n输入下一个运算符op;\n\nwhile（h.top()比op优先）{\n\n\n​\t栈顶元素出栈计算；\n}\n\nif(h.top()&#x3D;&#x3D;’&#x3D;’&amp;&amp; op&#x3D;&#x3D;’&#x3D;’){结束}（若有等号匹配，则结束循环）\n\nh.push(op);\n\n转2。（循环）\n\n\n1.h.push(‘&#x3D;’);那么我们添加history.push(&#39;=&#39;);输入等号，whach dog（士兵）进栈 \noperand solute()&#123;\n\toperand x, y;\n\toper op;\n\tstd::stack&lt;oper&gt; history;\t\t&#x2F;&#x2F;历史栈 ,存放历史操作符号\n\tstd::stack&lt;operand&gt; operands;\t&#x2F;&#x2F;存放操作数\n    history.push(&#39;&#x3D;&#39;);&#x2F;&#x2F;输入等号，whach dog（士兵）进栈 \n&#125;\n\n\n\n2.步骤2-5循环，直到若有等号匹配，则结束循环；所以我们加入循环条件\noperand solute()&#123;\n\toperand x, y;\n\toper op;\n\tstd::stack&lt;oper&gt; history;\t\t&#x2F;&#x2F;历史栈 ,存放历史操作符号\n\tstd::stack&lt;operand&gt; operands;\t&#x2F;&#x2F;存放操作数\n    history.push(&#39;&#x3D;&#39;);&#x2F;&#x2F;输入等号，whach dog（士兵）进栈 \n    \twhile(1)&#123;\n\t\t\n\t\tif(prior(history.top(),op)&#x3D;&#x3D;0) break;\n\t&#125;\n&#125;\n\n3.输入下一个数和运算符op;我们需要在循环体中持续不断的输入数和运算符\n观察式子：3+2+1*5=、5*8/7-4=、9*8/7-5=\n我们发现，我们输入的每个数字后面有且仅有一个运算符\n所以我们加入\nscanf(&quot;%f %c&quot;,&amp;x,&amp;op);\t\t&#x2F;&#x2F;输入一个数字和一个字符\n\t\toperands.push(x);\t&#x2F;&#x2F;将数字压入存放操作数的栈\n\n\n\n4.栈顶元素出栈计算；我们需要判断运算符的优先级，如果存放历史操作符号的栈顶比op优先，（优先数越小，优先级越高），那么直接计算历史操作数链接的两个数\n示意图如下\n\n\n\n\n所以我们根据\n\n\n\n\n\n\n\n\n\n\nwhile（h.top()比op优先）{\n\n​\t栈顶元素出栈计算；\n}\n进行栈顶元素出栈计算；\n所以写出以下循环\nwhile（h.top()比op优先）&#123;\n\ty &#x3D; operands.top();\t&#x2F;&#x2F;让y为最新的数（优先级高的历史操作符的右边的数）\n\toperands.pop();\t\t&#x2F;&#x2F;弹走最新的数（优先级高的历史操作符的右边的数）\n\tx &#x3D; operands.top();\t&#x2F;&#x2F;让x为优先级高的历史操作符的左边的数\n\toperands.pop();\t\t&#x2F;&#x2F;弹走历史操作符的左边的数\n\tswitch(history.top())&#123;\t&#x2F;&#x2F;判断优先级高的历史操作符\n\t\tcase &#39;+&#39;: operands.push(x + y) ; break;\n\t\tcase &#39;-&#39;: operands.push(x - y) ; break;\n\t\tcase &#39;*&#39;: operands.push(x * y) ; break;\n\t\tcase &#39;&#x2F;&#39;: operands.push(x &#x2F; y) ; break;\n\t&#125;\n\thistory.pop();&#x2F;&#x2F;弹走历史操作符的栈顶\n&#125;\n\n\n\n接下来我们需要对比history.top()【历史操作符（上一次的运算符号）】和op【即将压入history栈的符号】优先\n通过之前的函数int prior(oper op1, oper op2)进行丰富，\n又因为优先数越小，优先级越高，所以我们判断优先数的做差，判断差的正负性就可以判断优先级。\n我们完善函数int prior(oper op1, oper op2)\nint prior(oper op1, oper op2)&#123;\n\treturn p_num[op1].left - p_num[op2].right;\n&#125;\n\n从而完善循环判断\nwhile（prior(history.top(), op)&lt;0）&#123;\n\ty &#x3D; operands.top();\t&#x2F;&#x2F;让y为最新的数（优先级高的历史操作符的右边的数）\n\toperands.pop();\t\t&#x2F;&#x2F;弹走最新的数（优先级高的历史操作符的右边的数）\n\tx &#x3D; operands.top();\t&#x2F;&#x2F;让x为优先级高的历史操作符的左边的数\n    ………………………………………………\n\n\n\n5.h.push(op);压入op若优先级不大于栈顶的优先级，要将op压入history栈history.push(op);，此操作要在判断是否为等号之后\n即\noperand solve()&#123;\n\toperand x, y;\n\toper op;\n\tstd::stack&lt;oper&gt; history;&#x2F;&#x2F;历史栈 \n\tstd::stack&lt;operand&gt; operands;\n\thistory.push(&#39;&#x3D;&#39;);&#x2F;&#x2F;输入等号，whach dog（士兵）进栈 \n\twhile(1)&#123;\n&#x2F;*******************\n*2.  输入下一个运算符op;\n*3.  while（h.top()比op优先）&#123;\t栈顶元素出栈计算；&#125;\n*4.  if(h.top()&#x3D;&#x3D;&#39;&#x3D;&#39;&amp;&amp; op&#x3D;&#x3D;&#39;&#x3D;&#39;)&#123;结束&#125;\n*5.  h.push(op);\n*6.  转2。\n********************&#x2F;\n\t\tscanf(&quot;%f %c&quot;,&amp;x,&amp;op);\n\t\toperands.push(x);\n\t\twhile(prior(history.top(), op)&lt;0)&#123;\n\t\t\ty &#x3D; operands.top();\n\t\t\toperands.pop();\n\t\t\tx &#x3D; operands.top();\n\t\t\toperands.pop();\n\t\t\tswitch(history.top())&#123;\n\t\t\t\tcase &#39;+&#39;: operands.push(x + y) ; break;\n\t\t\t\tcase &#39;-&#39;: operands.push(x - y) ; break;\n\t\t\t\tcase &#39;*&#39;: operands.push(x * y) ; break;\n\t\t\t\tcase &#39;&#x2F;&#39;: operands.push(x &#x2F; y) ; break;\n\t\t\t&#125;\n\t\t\thistory.pop();\n\t\t&#125;\n\t\tif(prior(history.top(),op)&#x3D;&#x3D;0) break;\n\t\thistory.push(op);\n\t&#125;\n    return operands.top();\n&#125;\n\n\n\n6.函数的完善我们的解决函数operand solve()&#123;&#125;趋近完美，但是程序是由main()&#123;&#125;开始\n所以我们要完善main函数\nint main()&#123;\n\tprintf(&quot;%g\\n&quot;,solve());\n\treturn 0;\n&#125;\n\n\n\n在函数int prior(oper op1, oper op2)&#123;&#125;中，我们没有赋予p_num[op1].left（左符号、旧符号）和p_num[op2].right（右符号、新符号）的值（优先数）。所以我们在函数int prior(oper op1, oper op2)&#123;&#125;之前加入以下代码，并且加入#include&lt;map&gt;\nstruct prv_num_t&#123;char left,right;&#125;;&#x2F;&#x2F;定义结构体 prv_num_t  _t代表类型 \n&#x2F;&#x2F;关键字只包含一部分数据项,就称为map\nstd::map&lt;oper, prv_num_t&gt; p_num&#x3D;&#123;\n\t&#123;&#39;+&#39;,&#123;81,82&#125;&#125;,\n\t&#123;&#39;-&#39;,&#123;81,82&#125;&#125;,\n\t&#123;&#39;*&#39;,&#123;41,42&#125;&#125;,\n\t&#123;&#39;&#x2F;&#39;,&#123;41,42&#125;&#125;,\n\t&#123;&#39;&#x3D;&#39;,&#123;100,100&#125;&#125;\n&#125;;\n\n\n\n\n\n\n\n\n\n问题解决最终获得代码\n#include&lt;stdio.h&gt;\n#include&lt;stack&gt;\n#include&lt;map&gt;\n\ntypedef char oper;&#x2F;&#x2F;运算符\ntypedef float operand;\n\n&#x2F;*优先数表*&#x2F;\nstruct prv_num_t&#123;char left,right;&#125;;&#x2F;&#x2F;定义结构体 prv_num_t  _t代表类型 \n&#x2F;&#x2F;关键字只包含一部分数据项,就称为map\n&#x2F;&#x2F;关键字包含全部数据项,成为 \nstd::map&lt;oper, prv_num_t&gt; p_num&#x3D;&#123;\n\t&#123;&#39;+&#39;,&#123;81,82&#125;&#125;,\n\t&#123;&#39;-&#39;,&#123;81,82&#125;&#125;,\n\t&#123;&#39;*&#39;,&#123;41,42&#125;&#125;,\n\t&#123;&#39;&#x2F;&#39;,&#123;41,42&#125;&#125;,\n\t&#123;&#39;&#x3D;&#39;,&#123;100,100&#125;&#125;\n&#125;;\n\n\n&#x2F;*op1在左，op2在右*&#x2F;\n&#x2F;*返回值为负: op1优先级高于op2*&#x2F;\n&#x2F;*返回值为正: op2优先级高于op1*&#x2F;\n&#x2F;*返回值为0: op1优先级等于op2*&#x2F;\n\nint prior(oper op1, oper op2)&#123;\n\treturn p_num[op1].left - p_num[op2].right;\n&#125;\n\noperand solute()&#123;\n\toperand x, y;\n\toper op;\n\tstd::stack&lt;oper&gt; history;&#x2F;&#x2F;历史栈 \n\tstd::stack&lt;operand&gt; operands;\n\thistory.push(&#39;&#x3D;&#39;);&#x2F;&#x2F;输入等号，whach dog（士兵）进栈 \n\twhile(1)&#123;\n&#x2F;****************************************\n*2.  输入下一个运算符op;\n*3.  while（h.top()比op优先）&#123;\t栈顶元素出栈计算；&#125;\n*4.  if(h.top()&#x3D;&#x3D;&#39;&#x3D;&#39;&amp;&amp; op&#x3D;&#x3D;&#39;&#x3D;&#39;)&#123;结束&#125;\n*5.  h.push(op);\n*6.  转2。\n******************************************&#x2F;\n\t\tscanf(&quot;%f %c&quot;,&amp;x,&amp;op);\n\t\toperands.push(x);\n\t\twhile(prior(history.top(), op)&lt;0)&#123;\n\t\t\t\n\t\t\ty &#x3D; operands.top();\n\t\t\toperands.pop();\n\t\t\tx &#x3D; operands.top();\n\t\t\toperands.pop();\n\t\t\tswitch(history.top())&#123;\n\t\t\t\tcase &#39;+&#39;: operands.push(x + y) ; break;\n\t\t\t\tcase &#39;-&#39;: operands.push(x - y) ; break;\n\t\t\t\tcase &#39;*&#39;: operands.push(x * y) ; break;\n\t\t\t\tcase &#39;&#x2F;&#39;: operands.push(x &#x2F; y) ; break;\n\t\t\t&#125;\n\t\t\thistory.pop();\n\t\t&#125;\n\t\tif(prior(history.top(),op)&#x3D;&#x3D;0) break;\n\t\thistory.push(op);\n\t&#125;\n\treturn operands.top();\n&#125;\n\nint main()&#123;\n\tprintf(&quot;%g\\n&quot;,solute());\n\t\n\treturn 0;\n&#125;\n \n\n","slug":"example","date":"2022-05-22T15:38:33.000Z","categories_index":"","tags_index":"运算符","author_index":"ACbug"},{"id":"85b9560fd5f89937d71ee469baf4d06b","title":"STL 线性结构","content":"问题引入如何输出6的二进制数？\n分析问题问题-&gt;解决方案-&gt;实现方案-&gt;编写\n即\n从问题得到解决方案（解决方案（具体步骤（过程可以问专业专家）））\n实现方案有哪几种方法，并进行优化\n编写代码\n解决方案整数十进制整数转换为二进制整数采用”除2取余，逆序排列”法。\n具体做法是：用2整除十进制整数，可以得到一个商和余数；再用2去除商，又会得到一个商和余数，如此进行，直到商为小于1时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。\n实现方案一、使用stack【栈】输出因为 将得到的余数作为二进制数的高位有效位依次排列起来 的过程需要后进先出，所以我们使用栈进行输出\n老师给出代码如下\n#include&lt;cstdio&gt;\n#include&lt;list&gt;\n#include&lt;stack&gt;\nmain()&#123;\n\tstd::list&lt;int&gt; q; &#x2F;&#x2F;定义（双向）链表（被除数q） \t\t\t#include&lt;list&gt;\n\tstd::stack&lt;int&gt; r;&#x2F;&#x2F;定义栈（余数r）\t\t\t\t\t#include&lt;stack&gt;\n\tint n;\n\tscanf(&quot;%d&quot;,&amp;n);\n\twhile(n!&#x3D;0)&#123;\n\t\tq.push_back(n&#x2F;2);\t&#x2F;&#x2F;push_back链表的后面插入  \n\t\tr.push(n%2); \t\t&#x2F;&#x2F;push余数压入栈 \n\t\tn&#x3D;n&#x2F;2;\n\t&#125; \n\twhile(!r.empty())&#123;\t&#x2F;&#x2F; empty()只返回真假值，栈空返回1，否则返回0 \n\tprintf(&quot;%d&quot;,r.top());&#x2F;&#x2F;top有返回值，而pop没有返回值 ，&#x2F;&#x2F;用stack倒叙输出 \n\tr.pop();\t\t\n\t&#125;\n\treturn 0;\n&#125;\n\n\n\n其中std::list&lt;int&gt; q; 定义（双向）链表 来记录商q；std::stack&lt;int&gt; r 定义 栈 来记录余数r，定义n来表示操作数（要变为2进制的数）\n利用循环1来“压进”处理的数据：将商压进 链表的后面（q.push_back(n/2)）；将余数 压入栈 r.push(n%2); ；随后将n&#x2F;2向下取整（int型）\nwhile(n!&#x3D;0)&#123;\n\t\tq.push_back(n&#x2F;2);\t&#x2F;&#x2F;push_back链表的后面插入  \n\t\tr.push(n%2); \t\t&#x2F;&#x2F;push余数压入栈 \n\t\tn&#x3D;n&#x2F;2;\n&#125; \n\n\n\n\n\n利用循环2来输出：将 压入栈 r.push(n%2);  的元素从栈顶输出printf(&quot;%d&quot;,r.top());随后销毁栈顶元素[目的是为了让下一个元素输出]r.pop();\nwhile(!r.empty())&#123;\t&#x2F;&#x2F; empty()只返回真假值，栈空返回1，否则返回0 \n\tprintf(&quot;%d&quot;,r.top());&#x2F;&#x2F;top有返回值，而pop没有返回值 ，&#x2F;&#x2F;用stack倒叙输出 \n\tr.pop();\t\t\n&#125;\n\n\n\n优化我们发现，在输出时候，我们并没有输出双向链表std::list&lt;int&gt; q;，\n所以我们可以判断，双向链表是多余的，需要优化（但是思考实现方案的时候不能不考虑到双向链表）\n我们把list相关代码删除（或注释）\n得到\n#include&lt;cstdio&gt;\n&#x2F;&#x2F;#include&lt;list&gt;\n#include&lt;stack&gt;\nmain()&#123;\n&#x2F;&#x2F;\tstd::list&lt;int&gt; q; &#x2F;&#x2F;定义（双向）链表（被除数q） \t#include&lt;list&gt;\n\tstd::stack&lt;int&gt; r;&#x2F;&#x2F;定义栈（余数r）\t\t\t\t\t#include&lt;stack&gt;\n\tint n;\n\tscanf(&quot;%d&quot;,&amp;n);\n\twhile(n!&#x3D;0)&#123;\n\t&#x2F;&#x2F;\tq.push_back(n&#x2F;2);商（不用输出）\t&#x2F;&#x2F;push_back链表的后面插入  \n\t\tr.push(n%2); \t\t&#x2F;&#x2F;push余数压入栈 \n\t\tn&#x3D;n&#x2F;2;\n\t&#125; \n\twhile(!r.empty())&#123;\t&#x2F;&#x2F; empty()只返回真假值，栈空返回1，否则返回0 \n\tprintf(&quot;%d&quot;,r.top());&#x2F;&#x2F;top有返回值，而pop没有返回值 ，&#x2F;&#x2F;用stack倒叙输出 \n\tr.pop();\t\t\n\t&#125;\n\treturn 0;\n&#125;\n\n\n\n\n\n二、使用list【链式存储】输出具有三种实现list输出方案：\n1）使用r.push_back(n%2);加上reverse因为 将得到的余数作为二进制数的高位有效位依次排列起来 的过程需要后进先出，若我们需要使用list【链式存储】输出，要先将链式存储的顺序进行交换\n那么我们需要用到的是reverse函数，具体代码如下\n#include&lt;cstdio&gt;\n#include&lt;list&gt;\nmain()&#123;\n\tstd::list&lt;int&gt; r;\n\tint n;\n\tscanf(&quot;%d&quot;,&amp;n);\n\twhile(n!&#x3D;0)&#123;\t \n\t\tr.push_back(n%2);\n\t\tn&#x3D;n&#x2F;2;\n\t&#125; \n\t\n\n\treverse(r.begin(),r.end());&#x2F;&#x2F;【或者】r.reverse;\n    &#x2F;&#x2F;auto *i;auto:自动类型推倒&#x2F;&#x2F;std::list&lt;int&gt;::iterator ;\n\tfor(auto i&#x3D;r.begin();i!&#x3D;r.end();++i)\n\t\tprintf(&quot;%d&quot;,*i) ;\n\treturn 0;\n\n&#125;\n\n其中reverse(r.begin(),r.end());为交换顺序函数，将链表排序颠倒（1,2,3-&gt;3,2,1）\n在输出时，我们要用到类似指针的i，但是它的类型我们并不知道（或者不想写），那么我们使用auto i，让编译器自动识别\n\n\n\n\n\n\n\n\n\n不过在使用时需要如下配置\n\n2）使用r.push_back(n%2);利用属性改为rbigin，rend利用双向链表的属性，我们可以重后往前输出\n注意：双向链表不是数列，不能将上述for(auto i=r.begin();i!=r.end();++i)用for(auto i=r.end();i!=r.begin();i--)，而是要将r.begin()改为r.rbegin，r.end改为r.rend,即改为for(auto i=r.rbegin();i!=r.rend();++i)\n具体代码如下\n#include&lt;cstdio&gt;\n#include&lt;list&gt;\nmain()&#123;\n\tstd::list&lt;int&gt; r;\n\tint n;\n\tscanf(&quot;%d&quot;,&amp;n);\n\twhile(n!&#x3D;0)&#123;\t \n\t\tr.push_back(n%2); \t\t\n\t\tn&#x3D;n&#x2F;2;\n\t&#125; \n\n\t&#x2F;&#x2F;auto *i;auto:自动类型推倒&#x2F;&#x2F;std::list&lt;int&gt;::iterator ;\n\n\tfor(auto i&#x3D;r.rbegin();i!&#x3D;r.rend();++i)&#x2F;&#x2F; begin变成rbegin， end改为rend，双向链表从后向前读取 \n\tprintf(&quot;%d&quot;,*i) ;\n\treturn 0;\n\n&#125;\n\n\n\n3）使用r.push_front(n%2);将得到的余数作为二进制数的高位有效位依次排列起来 的过程需要后进先出，我们还可以在插入时从链表头插入r.push_front(n%2)\n#include&lt;cstdio&gt;\n#include&lt;list&gt;\nmain()&#123;\n\tstd::list&lt;int&gt; r;\n\tint n;\n\tscanf(&quot;%d&quot;,&amp;n);\n\twhile(n!&#x3D;0)&#123;\t \n\t\tpush_front(n%2);\t\t&#x2F;&#x2F; push_front(n%2)（从前插入）顺序等于reverse(r.begin(),r.end())【或者】;数序颠倒，1,2,3-&gt;3,2,1 ,\n\t\tn&#x3D;n&#x2F;2;\n\t&#125; \n\tfor(auto i&#x3D;r.begin();i!&#x3D;r.end();++i)\n\tprintf(&quot;%d&quot;,*i) ;\n\treturn 0;\n\n&#125;\n\n\n\n三、vector【顺序存储，数组】输出同使用list【链式存储】输出一样，我们可以\n1）使用r.push_back(n%2);加上reverse\n方法同list，只不过将list替换为vector\n2）使用r.push_back(n%2);利用属性改为rbigin，rend\n方法同list，只不过将list替换为vector\n但是我们不能使用r.push_front(n%2); ，因为vector作为顺序存储（数组），不能从头输入，只能从尾输入。即没有r.push_front()\nvector具有数组特性，我们可以使用数组的方法进行输出 （不建议）\n即使用\nfor(int i&#x3D;r.size();i&gt;0;--i)\n\t\tprintf(&quot;%d&quot;,r[i]) ;\n\n\n\n得到：\n#include&lt;cstdio&gt;\n#include&lt;vector&gt;\nmain()&#123;\n\tstd::vector&lt;int&gt; r;\n\tint n;\n\tscanf(&quot;%d&quot;,&amp;n);\n\twhile(n!&#x3D;0)&#123;\t \n\t\tr.push_back(n%2); \t\t\n\t\tn&#x3D;n&#x2F;2;\n\t&#125;\n\n\tfor(int i&#x3D;r.size();i&gt;0;--i)\n\t\tprintf(&quot;%d&quot;,r[i]) ;\t\t\t&#x2F;&#x2F;数组从r[max]输出到r[1](r[0]为空)\n\treturn 0;\n\n&#125;\n\n\n\n\n\n四、双端队列deque【deque 是 double-ended queue 的缩写，又称双端队列容器。】和 vector 不同的是，deque 还擅长在序列头部添加或删除元素\ndeque的内存模型相比于vector与list要复杂许多，它不像vector 把所有的对象保存在一块连续的内存块，而是采用多个连续的存储块，并且在一个映射结构中保存对这些块及其顺序的跟踪。向deque 两端添加或删除元素的开销很小，它不需要重新分配空间。\n具体模型见下图：\n\n他能支持上述所有方式：\n1）使用r.push_back(n%2);加上reverse\n2）使用r.push_back(n%2);利用属性改为rbigin，rend\n3）使用r.push_front(n%2); \n4）具有数组特性，可以使用数组的方法进行输出 （不建议）\n","slug":"STL-linear-structure","date":"2022-05-22T04:55:33.000Z","categories_index":"","tags_index":"线性结构","author_index":"ACbug"},{"id":"1b543e84ac41cc09af328e6f7689b488","title":"《数据结构》知识总结","content":"参考视频：速成数据结构与算法-【期末不挂科】_哔哩哔哩_bilibili\n数据结构和算法1.数据结构1）数据:\t\t\t\t对客观事物的符号表示\t\t图像、声音等\n2）数据元素:\t\t数据的基本单位\t\t\t\t\t学生的信息记录\n3）数据项:\t\t\t构成数据元素的不可分割的最小单位\n​\t\t\t\t\t\t\t\t一个数据元素可由若干个数据项组成\t\t学号、姓名、性别等\n(4）数据对象:\t\t具有相同性质的数据元素的集合(5）数据结构:\t\t相互之间存在一种或多种特定关系的数据元素的集合\n​\t\t\t\t\t\t\t\t逻辑结构、存储结构和数据的运算​\t\t\t\t\t\t\t\tData_ Structure&#x3D;(D,S)\n自我理解如图\n\n例题如下\n\n\n\n\n逻辑结构逻辑结构分为线性结构和非线性结构，其中非线性结构还分有集合、树形结构、图形结构或网状结构\n\n\n\n\n例题：\n\n\n\n\n\n\n存储结构存储结构【区别于存取】大致有：顺序存储、链式存储、索引存储、散列存储\n\n\n\n\n在顺序存储、链式存储、索引存储和散列存储这4种存储方式中，最基本、最常用的两种存储结构是顺序结构、链式结构\n算法算法是对特定问题求解步骤的一种描述\n特性算法应该具有的以下特性\n(1）有穷性\t\t有穷步骤有穷时间\n(2）确定性\n(3）可行性\n(4）输入\t\t\t一个算法有零个或多个输入\n(5）输出\t\t\t一个算法有一个或多个输出\n【例题】\n以下不属于算法特性的是（)\n\n A.可行性\t\t\t\t\n B.输入\t\t\t\t\n C.确定性\t\t\t\t\n D.健壮性\n\n通常设计一个“好”的算法应考虑达到以下目标:\n(1）正确性\n(2）可读性\n(3）健壮性\n(4）效率与低存储量需求\n复杂度算法效率的度量是通过时间复杂度和空间复杂度来描述的频度该语句在算法中被重复执行的次数\n算法中所有语句的频度之和T(n)&#x3D;O(fn))\n若一个算法中的语句频度之和为T(n)&#x3D;n＋4n log2n，则算法的时间复杂度为O(nlog2n)加法规则:$$T(n)&#x3D;T(n)＋T,(n)&#x3D;O(f(n))+O(g(n))&#x3D;O(max (f(n),g(m)))$$乘法规则:$$T(n)&#x3D;T (n)×T,(n)&#x3D;O(f(n))×O(g(n))&#x3D;O(f(n)×g(n))$$常见的渐近时间复杂度为$$O(1)&lt;O(log2n)&lt;O(n)&lt;O(nlog2n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)$$【例题】\n\n\n\n\n\n\n\n\n线性表定义线性表：具有相同数据类型的n(n≥0)个数据元素的**有限序列**$$L&#x3D;(a,a₂,…,a，aᵢ₊₁，…，aₙ)$$除第一个元素外，每个元素有且仅有一个直接前驱\n除最后一个元素外，每个元素有且仅有一个直接后继\n线性表的基本操作线性表的基本操作:\nInitList(&amp;L);\t\t\t&#x2F;&#x2F;初始化表\nLength(L);\t\t\t\t&#x2F;&#x2F;求表长\nLocateElem(L,e);\t\t&#x2F;&#x2F;按值查找操作\nGetElem(L,i);\t\t\t&#x2F;&#x2F;按位查找操作\nListInsert(&amp;L,i,e);\t\t&#x2F;&#x2F;插入操作\nListDelete(&amp;L,i,&amp;e);\t&#x2F;&#x2F;删除操作\nPrintList(L);\t\t\t&#x2F;&#x2F;输出操作\nEmpty(L);\t\t\t\t&#x2F;&#x2F;判空操作\nDestroyList(&amp;L);\t\t&#x2F;&#x2F;销毁操作\n\n\n\n线性表的结构线性表采用顺序存储结构表示时,必须占用一片连续的存储单元\n顺序表是由一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻\n如果一个顺序表中第一个元素的存储地址为1000,每个元素占4个地址单元，那么第6个元素的存储地址应是（)\n\n \nA.1020\n\n \nB.1010\n\n \nC.1016\n\n \nD.1024\n$$LOC(A)+sizeof (ElemType)*(i-1)$$\n1000＋(6—1)*4&#x3D;1020\n\n顺序表的特点顺序表的特点:(1)顺序表最主要的特点是随机存取，即通过首地址和元素序号可在时间O(1)内找到指定的元素\n(2)顺序表的存储密度高，每个结点只存储数据元素\n(3)顺序表逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量元素\n顺序表的实现\n\n\n\n【例题】在长度为n的顺序表的第i个位置上插入一个元素(1≤i≤n＋i)，元素的移动次数为（  )\n\n A. n - i＋1\n B. n - i\n C. i\n D. i - 1\n\n\n\n【例题】设顺序线性表中有n个数据元素，则删除表中第i个元素需要移动（）个元素\n\n A. n - i\n B. n - i - 1\n C. n - i＋1\n D. i\n\n【例题】题3.对于顺序存储的线性表，访问结点和增加、删除结点的时间复杂度为（ )\n\n \nA. O(n),O(n)\n\n \nB. O(n),O(1)\n\n \nC. O(1),O(n)\n\n \nD. O(1),0(1)\n顺序表最主要的特点是随机存取，即通过首地址和元素序号可在时间O(1)内找到指定的元素\n增加、删除结点的时间复杂度为O(n)\n\n\n链表单链表的结构单链表:链式存储的线性表\n\n\n不带头结点\n\n\n带头结点\n\n\n【例题】\n\n\n\n\n单链表的实现（操作）\n\n\n\n实现代码如下\nLNode *GetElem(LinkList L,int i)&#123;\t\t&#x2F;&#x2F;LNode结点类型，函数名为GetElem，单链表L,查找第几位数（要求返回第ai位的值）\n\tint j&#x3D;1;\t\t\t\t\t\t\t&#x2F;&#x2F;计数用\n\tLNode *p&#x3D;L-&gt;next;\t\t\t\t\t&#x2F;&#x2F;设置指针p为第一个结点（L头结点的下一个结点是a1）\n    if(i&#x3D;&#x3D;0)\treturn L;\t\t\t\t&#x2F;&#x2F;如果i&#x3D;0，返回L值\n\tif(i&lt;0)\t\treturn NULL;\t\t\t&#x2F;&#x2F;如果i&lt;0，返回错误\n\twhile(p&amp;&amp;j&lt;i)&#123;\t\t\t\t\t\t&#x2F;&#x2F;p的值为是否为空&amp;&amp;j是否超过i\n\tp&#x3D;p-&gt;next;\tj＋+;\t\t\t\t\t&#x2F;&#x2F;指针往下\n\t&#125;\n\treturn p;\t\t\t\t\t\t\t&#x2F;&#x2F;p的值为为空（i定义过大）或 j等于i（找到），返回p所指的ai位记录的值\n&#125;\n\n时间复杂度为O(n)\n【例题】\n\n\n\n\n插入结点\n\n\n\n实现插入结点的代码如下:\np&#x3D;GetElem(L,i-1);\ns一&gt;next&#x3D;p一&gt;next;\np-&gt;next &#x3D;s;\n\n【例题】\n\n\n按照一步一步操作，选B，\n删除结点\n\n实现删除结点的代码片段如下:\np&#x3D;GetElem (L,i—1);\nq&#x3D;p-&gt;next;\t\t\t&#x2F;&#x2F;定义q为p的下一个\np-&gt;next&#x3D;q-&gt;next;\t&#x2F;&#x2F;把q的下一个（c）作为p的下一个\nfree(q);\t\t\t&#x2F;&#x2F;释放q\n\n\n\n双链表\n\n双链表比单链表多了前驱（prior）指针，指向前面一个元素\n插入操作\n\ns-&gt;next &#x3D; p-&gt;next;\t&#x2F;&#x2F;让x的下一个给b（p-&gt;next）\np-&gt;next-&gt;prior &#x3D; s;\t&#x2F;&#x2F;让b（p-&gt;next）的前驱为x\ns-&gt;prior &#x3D; p;\t\t&#x2F;&#x2F;让x的前驱为a\np-&gt;next &#x3D; s;\t\t&#x2F;&#x2F;让p的后续为x\n\n上述代码不唯一，但是第一行代码和第二行代码必须在第四行之前\n删除操作\n\n代码如下\np-&gt;next&#x3D;q-&gt;next;\t&#x2F;&#x2F;让p的后续等于c（q-&gt;next）\nq-&gt;next—&gt;prior&#x3D;p;\t&#x2F;&#x2F;让c的前驱（q-&gt;next—&gt;prior）指向p\nfree(q);\t\t\t&#x2F;&#x2F;释放q\n\n\n\n循环列表\n\n【例题】\n\n\n由于\n\n所以本题选C\n\n\n\n\n栈和队列栈\n\n栈:只允许在一端进行插入或删除操作的线性表    栈顶\t\t栈底\n初始化\nStatus lnitStack(SqStack &amp;s ,int MAXSIZE )&#123;\n\nS. base &#x3D;new SElemType[MAXSIZE];\n\nif( !S. base ) return OVERFLOW;\n\nS.top &#x3D; S. base;\n\nS.stacksize &#x3D; MAXSIZE;\n\nreturn OK;\n&#125;\n\n\n\n空栈:不含任何元素的空表\n特性:先进后出\n\n\n\n\n\n\n限定仅在表尾进行插入和删除操作的线性表称为 栈 ,它的修改是按先进后出的原则进行的\n【例题】若进栈序列为a,b,c，则通过入栈操作可能得到的a,b,c出栈的不同排列个数（)                A.4\t\t\tB.5\t\t\tC.6\t\t\tD.7\nn个不同元素进栈,出栈元素不同排列的个数为\n\n\n所以选B.5\n栈的存储结构顺序栈的实现\n栈的顺序存储类型可描述为:\n#define MaxSize 50\ntypedef struct &#123;\n  ElemType data[MaxSize];\n  int top;\n&#125; SqStack;\n\n顺序栈的基本运算1.初始化\nvoid InitStack (SqStack &amp;S)&#123;\nS.top &#x3D; -1;\n&#125;\n\n2.判栈空\nbool StackEmpty (SqStack &amp;S)&#123;\nif(S.top &#x3D;&#x3D; -1)\n  return true;\nelse\n  return false;\n&#125;\n\n3.进栈：栈不满时，栈顶指针先加1，再送值到栈顶元素\nbool Push(SqStack &amp;S, ElemType x)&#123;\n  if(S.top &#x3D;&#x3D; MaxSize-1)\n    return false;\n  S.data[++S.top]&#x3D;x;\n  return true;\n&#125;\n\n或\nStatus Push( SqStack &amp;s, SElemType e)\n\n&#123; \n  if( S.top - S.base&#x3D;&#x3D; S.stacksize )\n    return ERROR;\n  *S.top++&#x3D;e;\n  return OK;\n&#125;\n\n4.取栈顶元素:\nStatus Pop(SqStack &amp;S,SElemType &amp;e)\n&#123;\n  if( S.top &#x3D;&#x3D; S.base ) &#x2F;&#x2F;栈空\n  return ERROR;\n  e&#x3D;*--S.top;\t\t\t&#x2F;&#x2F;e为原指针下一个，并且原指针--\n  return OK;&#125;\n\n\n5.求栈长度:\nint StackLength( SqStack S )&#123;\n  return(S.top - S. base) ;\n&#125;\n\n\n\n\n\n链栈\n\n\n\n\n\n\n\n\n\n\n\n队列的基本概念队列:\t\t队，只允许在表的一端进行插入，而在表的另一端进行删除入队或进队出队或离队特性:\t\t先进先出\n\n\n题1.队列是一种操作受限的线性表,它与栈不向的是,队列中所有的插入操作均限制在表的一段进行，而所有的删除操作都限制在表的另一端进行,允许插入的一端称为队尾，允许删除的一端称为对头（对首），队列具有先进先出的特点\n","slug":"Structures","date":"2022-05-13T15:03:29.000Z","categories_index":"","tags_index":"-数据结构","author_index":"ACbug"},{"id":"fbf2013fd372815138afff9263093bc8","title":"懒加载(lazyload/lozad)和Valine评论系统的头像、表情冲突","content":"问题现象在使用lozad.js的情况下，同时使用了Valine评论系统，就会出现头像、表情不显示的问题。百度也一直找不到问题所在。\n如图\n\n\n\n\n问题分析在F12开发者工具下，看到所有的src变成了data-src，导致了src没有数据\n\n查看代码，发现他把src一律转换成了data-src。\n&#x2F;*! lozad.js - v1.16.0 - 2020-09-06\n* https:&#x2F;&#x2F;github.com&#x2F;ApoorvSaxena&#x2F;lozad.js\n* Copyright (c) 2020 Apoorv Saxena; Licensed MIT *&#x2F;\n!function(t,e)&#123;&quot;object&quot;&#x3D;&#x3D;typeof exports&amp;&amp;&quot;undefined&quot;!&#x3D;typeof module?module.exports&#x3D;e():&quot;function&quot;&#x3D;&#x3D;typeof define&amp;&amp;define.amd?define(e):t.lozad&#x3D;e()&#125;(this,function()&#123;&quot;use strict&quot;;\n&#x2F;**\n   * Detect IE browser\n   * @const &#123;boolean&#125;\n   * @private\n   *&#x2F;var g&#x3D;&quot;undefined&quot;!&#x3D;typeof document&amp;&amp;document.documentMode,f&#x3D;&#123;rootMargin:&quot;0px&quot;,threshold:0,load:function(t)&#123;if(&quot;picture&quot;&#x3D;&#x3D;&#x3D;t.nodeName.toLowerCase())&#123;var e&#x3D;t.querySelector(&quot;img&quot;),r&#x3D;!1;null&#x3D;&#x3D;&#x3D;e&amp;&amp;(e&#x3D;document.createElement(&quot;img&quot;),r&#x3D;!0),g&amp;&amp;t.getAttribute(&quot;data-iesrc&quot;)&amp;&amp;(e.src&#x3D;t.getAttribute(&quot;data-iesrc&quot;)),t.getAttribute(&quot;data-alt&quot;)&amp;&amp;(e.alt&#x3D;t.getAttribute(&quot;data-alt&quot;)),r&amp;&amp;t.append(e)&#125;if(&quot;video&quot;&#x3D;&#x3D;&#x3D;t.nodeName.toLowerCase()&amp;&amp;!t.getAttribute(&quot;data-src&quot;)&amp;&amp;t.children)&#123;for(var a&#x3D;t.children,o&#x3D;void 0,i&#x3D;0;i&lt;&#x3D;a.length-1;i++)(o&#x3D;a[i].getAttribute(&quot;data-src&quot;))&amp;&amp;(a[i].src&#x3D;o);t.load()&#125;t.getAttribute(&quot;data-poster&quot;)&amp;&amp;(t.poster&#x3D;t.getAttribute(&quot;data-poster&quot;)),t.getAttribute(&quot;data-src&quot;)&amp;&amp;(t.src&#x3D;t.getAttribute(&quot;data-src&quot;)),t.getAttribute(&quot;data-srcset&quot;)&amp;&amp;t.setAttribute(&quot;srcset&quot;,t.getAttribute(&quot;data-srcset&quot;));var n&#x3D;&quot;,&quot;;if(t.getAttribute(&quot;data-background-delimiter&quot;)&amp;&amp;(n&#x3D;t.getAttribute(&quot;data-background-delimiter&quot;)),t.getAttribute(&quot;data-background-image&quot;))t.style.backgroundImage&#x3D;&quot;url(&#39;&quot;+t.getAttribute(&quot;data-background-image&quot;).split(n).join(&quot;&#39;),url(&#39;&quot;)+&quot;&#39;)&quot;;else if(t.getAttribute(&quot;data-background-image-set&quot;))&#123;var d&#x3D;t.getAttribute(&quot;data-background-image-set&quot;).split(n),u&#x3D;d[0].substr(0,d[0].indexOf(&quot; &quot;))||d[0];&#x2F;&#x2F; Substring before ... 1x\nu&#x3D;-1&#x3D;&#x3D;&#x3D;u.indexOf(&quot;url(&quot;)?&quot;url(&quot;+u+&quot;)&quot;:u,1&#x3D;&#x3D;&#x3D;d.length?t.style.backgroundImage&#x3D;u:t.setAttribute(&quot;style&quot;,(t.getAttribute(&quot;style&quot;)||&quot;&quot;)+&quot;background-image: &quot;+u+&quot;; background-image: -webkit-image-set(&quot;+d+&quot;); background-image: image-set(&quot;+d+&quot;)&quot;)&#125;t.getAttribute(&quot;data-toggle-class&quot;)&amp;&amp;t.classList.toggle(t.getAttribute(&quot;data-toggle-class&quot;))&#125;,loaded:function()&#123;&#125;&#125;;function A(t)&#123;t.setAttribute(&quot;data-loaded&quot;,!0)&#125;var m&#x3D;function(t)&#123;return&quot;true&quot;&#x3D;&#x3D;&#x3D;t.getAttribute(&quot;data-loaded&quot;)&#125;,v&#x3D;function(t)&#123;var e&#x3D;1&lt;arguments.length&amp;&amp;void 0!&#x3D;&#x3D;arguments[1]?arguments[1]:document;return t instanceof Element?[t]:t instanceof NodeList?t:e.querySelectorAll(t)&#125;;return function()&#123;var r,a,o&#x3D;0&lt;arguments.length&amp;&amp;void 0!&#x3D;&#x3D;arguments[0]?arguments[0]:&quot;.lozad&quot;,t&#x3D;1&lt;arguments.length&amp;&amp;void 0!&#x3D;&#x3D;arguments[1]?arguments[1]:&#123;&#125;,e&#x3D;Object.assign(&#123;&#125;,f,t),i&#x3D;e.root,n&#x3D;e.rootMargin,d&#x3D;e.threshold,u&#x3D;e.load,g&#x3D;e.loaded,s&#x3D;void 0;&quot;undefined&quot;!&#x3D;typeof window&amp;&amp;window.IntersectionObserver&amp;&amp;(s&#x3D;new IntersectionObserver((r&#x3D;u,a&#x3D;g,function(t,e)&#123;t.forEach(function(t)&#123;(0&lt;t.intersectionRatio||t.isIntersecting)&amp;&amp;(e.unobserve(t.target),m(t.target)||(r(t.target),A(t.target),a(t.target)))&#125;)&#125;),&#123;root:i,rootMargin:n,threshold:d&#125;));for(var c,l&#x3D;v(o,i),b&#x3D;0;b&lt;l.length;b++)(c&#x3D;l[b]).getAttribute(&quot;data-placeholder-background&quot;)&amp;&amp;(c.style.background&#x3D;c.getAttribute(&quot;data-placeholder-background&quot;));return&#123;observe:function()&#123;for(var t&#x3D;v(o,i),e&#x3D;0;e&lt;t.length;e++)m(t[e])||(s?s.observe(t[e]):(u(t[e]),A(t[e]),g(t[e])))&#125;,triggerLoad:function(t)&#123;m(t)||(u(t),A(t),g(t))&#125;,observer:s&#125;&#125;&#125;);\n\n\n\n所以我们使用srcset代替Valine.min.js中的src\n具体解决方法使用srcset代替Valine.min.js中的src\n首先我们先下载js文件到本地：下载地址\n搜索&lt;img\n\n然后在&lt;img后面的src替换为srcset\n并将更改好的js放在Blog\\source中的某个地方\n接下来在CDN引用的地方，修改路径为/js1/Valine.min.js【笔者放在Blog&#x2F;source&#x2F;js1&#x2F;Valine.min.js】\n\n然后保存，最后hexo cl &amp;&amp; hexo g &amp;&amp; hexo s\n问题解决看结果，\n\n","slug":"lazyload-bug","date":"2022-05-12T13:49:09.000Z","categories_index":"","tags_index":"hexo,NexT,lozad,Valine","author_index":"ACbug"},{"id":"476613efa9f6b315a06dafe6bc2ebd45","title":"Java对象和类—JAVA语言基础","content":"\n对象：对象是类的一个实例（对象不是找个女朋友），有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。\n类：类是一个模板，它描述一类对象的行为和状态。\n\n\n\n\n\n下面我们大致具体了解一下在Java中类和面向对象\n面向对象概述对象对象是事物存在的实体，如人、书桌、计算机、高楼大厦等。\n人类解决问题的方式总是将复杂的事物简单化，于是就会思考这些对象都是由哪些部分组成的。通常都会将对象划分为两个部分，即静态部分与动态部分。\n\n\n\n\n\n\n\n\n\n静态部分：被称为“属性”。属性包括高矮、胖瘦、性别、年龄等\n动态部分：个人具备的行为（动态部分）。哭泣、微笑、说话、行走\n例如，现在面临一只大雁要从北方飞往南方这样一个实际问题\n1.识别这个对象的属性。对象具备的属性都是静态属性， 如大雁有一对翅膀、黑色的羽毛等\n2.接着识别这个对象的动态行为，即这只大雁可以进行的动作，如飞行、觅食等，这些行为都是这个对象基于其属性而具有的动作。\n3.识别出这个对象的属性和行为后，这个对象就被定义完成了。\n所有的大雁都具有以上的属性和行为，可以将这些属性和行为封装起来，以描述大雁这类动物。\n类实质上就是封装对象属性和行为的载体，而对象则是类抽象出来的一个实例\n\n\n\n\n类类就是同一类事物的统称，如鸟类、家禽类、人类等\n类是构造对象时所依赖的规范，如一只鸟有一对翅膀，它可以用这对翅膀飞行，而基本上所有的鸟都具有有翅膀这个特性和飞行的技能，这样具有相同特性和行为的一类事物就称为类。\n类的思想就是这样产生的\n类是封装对象的属性和行为的载体，反过来说，具有相同属性和行为的一类实体被称为类。\n类中对象的行为是以方法的形式定义的，对象的属性是以成员变量的形式定义的，所以类包括对象的属性和方法。\n封装面向对象程序设计具有以下特点：\n\n \n封装性\n\n \n继承性\n\n \n多态性\n\n\n封装是面向对象编程的核心思想。将对象的属性和行为封装起来， 其载体就是类\n采用封装的思想保证了类内部数据结构的完整性，应用该类的用户不能轻易地直接操作此数据结构，只能执行类允许公开的数据。这样就避免了外部操作对内部数据的影响，提高了程序的可维护性。\n  \n\n继承类与类之间同样具有关系，这种关系被称为关联。\n例如，一个百货公司类与销售员类就是一个关联，学生类与教师类也是一个关联。两个类之间的关系有很多种，继承是关联中的一种。\n当处理一个问题时，可以将一些有用的类保留下来，在遇到同样问题时拿来复用。\n\n\n\n\n\n\n\n\n\n由于鸽子属于鸟类，具有与鸟类相同的属性和行为，便可以在创建信鸽类时将鸟类拿来复用\n此外还需要再添加一些信鸽具有的独特属性及行为\n鸽子类保留了鸟类的属性和行为，这样就节省了定义鸟和鸽子共同具有的属性和行为的时间，这就是继承的基本思想\n继承性主要利用特定对象之间的共有属性\n这里可以将平行四边形类看作是从四边形类中继承的。在Java语言中将类似于平行四边形的类称为子类，将类似于四边形的类称为父类或超类。\n\n多态将父类对象应用于子类的特征就是多态\n如果将子类的对象统一看作是父类的实例对象，这样当绘制图形时，简单地调用父类也就是图形类绘制图形的方法即可绘制任何图形，这就是多态最基本的思想。\n其优点是：由于整个事件的处理都只依赖于父类的方法， 所以日后只要维护和调整父类的方法即可，这样就降低了维护的难度， 节省了时间。\n多态的实现并不依赖于具体类，而是依赖于抽象类和接口\n图形类作为所有图形的父类，具有绘制图形的能力，这个方法可以称为“绘制图形”，但如果要执行这个“绘制图形”的命令，没有人知道应该画什么样的图形，并且如果要在图形类中抽象出一个图形对象，没有人能说清这个图形究竟是什么图形，所以使用“抽象”这个词来描述图形类比较恰当。在Java语言中称这样的类为抽象类，抽象类不能实例化对象。在多态的机制中，父类通常会被定义为抽象类，在抽象类中给出一个方法的标准，而不给出实现的具体流程。实质上这个方法也是抽象的，如图形类中的“绘制图形”方法只提供一个可以绘制图形的标准，并没有提供具体绘制图形的流程，因为没有人知道究竟需要绘制什么形状的图形。\n也就是说，父类只给出绘制图形的方法，但是不给出如何准确的画一个准确的三角形或四边形等特定图形\n比抽象类更方便的方式是将抽象类定义为接口。由抽象方法组成的集合就是接口。\n可能螺丝帽和螺丝钉的厂家不同，但这两个物品可以轻易地组合在一起，这是因为生产螺丝帽和螺丝钉的厂家都遵循着一个标准，这个标准在Java中就是接口。\n类类是封装对象的属性和行为的载体\n成员变量在Java中对象的属性也称为成员变量。\n首先定义一个图书类，成员变量对应于类对象的属性，在Book类中设置3个成员变量，分别为id、name和category，分别对应于图书编号、图书名称和图书类别3个图书属性。\n\n\n根据以上代码，读者可以看到在Java中使用class关键字来定义类， Book是类的名称。同时在Book类中定义了3个成员变量，成员变量的类型可以设置为Java中合法的数据类型，其实成员变量就是普通的变量， 可以为它设置初始值，也可以不设置初始值。如果不设置初始值，则会有默认值。读者应该注意到在3个成员变量前面的private关键字，它用来定义一个私有成员（文章后面会介绍）\n成员方法在Java语言中使用成员方法对应于类对象的行为。以Book类为例， 它包含getName()和setName()两个方法，这两个成员方法分别为获取图书名称和设置图书名称的方法。\n定义成员方法的语法格式如下：\n\n一个个成员方法可以有参数，这个参数可以是对象，也可以是基本数据类型的变量，同时成员方法有返回值和不返回任何值的选择，如果方法需要返回值，可以在方法体中使用return关键字，使用这个关键字后，方法的执行将被终止。\n\n\n\n\n\n\n\n\n\nJava中的成员方法无返回值，可以使用void关键字表示。\n权限修饰符\n\n\n\n\n\n\n\n\n\n当声明类时不使用public、protected和private修饰符设置类的权限，则这个类预设为包存取范围，即只有一个包中的类可以调用这个类的成员变量或成员方法。\n\n由于类的修饰符为默认修饰符，即只有一个包内的其他类和子类可以对该类进行访问，而AnyClass类中的doString()方法却又被设置为public访问权限，即使这样，doString()方法的访问权限依然与AnyClass类的访问权限相同，因为Java语言规定，类的权限设定会约束类成员的权限设定\n\n\n本实例等同于\n\n局部变量\n\n定义的Book类中，getName()方法的id变量即为局部变量。实际上方法中的形参也可作为一个局部变量，如在定义setName(String name)方法时，String name这个形参就被看作是局部变量。\n局部变量是在方法被执行时创建，在方法执行结束时被销毁。\n使用时必须进行赋值操作或被初始化，否则会出现编译错误\n\n如果将id这个局部变量的初始值去掉，编译器将出现错误\n局部变量的有效范围可以将局部变量的有效范围称为变量的作用域，局部变量的有效范围从该变量的声明开始到该变量的结束为止。\n\n\n在相互不嵌套的作用域中可以同时声明两个名称和类型相同的局部变量\n\n\n但是在相互嵌套的区域中不可以这样声明，如果将局部变量id在方法体的for循环中再次定义，编译器将会报错\n\n\n\n\nthis关键字在项目中创建一个类文件，该类中定义了setName()，并将方法的参数值赋予类中的成员变量\n\n在Java语言中规定使用this关键字来代表本类对象的引用嘛，this.name指的就是Book类中的name成员变量，而this.name&#x3D;name语句中的第二个name则指的是形参name。\nthis可以调用成员变量和成员方法，但Java语言中最常规的调用方式是使用“对象.成员变量”或“对象.成员方法”进行调用\n事实上，this引用的就是本类的一个对象。在局部变量或方法参数覆盖了成员变量时，如上面代码的情况，就要添加this关键字明确引用的是类成员还是局部变量或方法参数。\n如果省略this关键字直接写成name &#x3D; name，那只是把参数name赋值给参数变量本身而已，成员变量name的值没有改变，因为参数name在方法的作用域中覆盖了成员变量name。\nthis除了可以调用成员变量或成员方法之外，还可以作为方法的返回值。\n\n","slug":"Class-and-object","date":"2022-05-09T12:32:46.000Z","categories_index":"","tags_index":"Eclipse,Java","author_index":"ACbug"},{"id":"c5b29c51d4e2d58a38adb96d31b1d4ab","title":"在NexT的侧边栏添加近期文章板块","content":"最近听说内链可以改善SEO，于是乎，我想在NexT的侧边栏添加近期文章板块\n在网络上查找的方案大致如下\n第一种方法&#123;% if theme.recent_posts %&#125;\n    &lt;div class&#x3D;&quot;links-of-blogroll motion-element &#123;&#123; &quot;links-of-blogroll-&quot; + theme.recent_posts_layout  &#125;&#125;&quot;&gt;\n      &lt;div class&#x3D;&quot;links-of-blogroll-title&quot;&gt;\n        &lt;!-- modify icon to fire by szw --&gt;\n        &lt;i class&#x3D;&quot;fa fa-history fa-&#123;&#123; theme.recent_posts_icon | lower &#125;&#125;&quot; aria-hidden&#x3D;&quot;true&quot;&gt;&lt;&#x2F;i&gt;\n        &#123;&#123; theme.recent_posts_title &#125;&#125;\n      &lt;&#x2F;div&gt;\n      &lt;ul class&#x3D;&quot;links-of-blogroll-list&quot;&gt;\n        &#123;% set posts &#x3D; site.posts.sort(&#39;-date&#39;) %&#125;\n        &#123;% for post in posts.slice(&#39;0&#39;, &#39;5&#39;) %&#125;\n          &lt;li&gt;\n            &lt;a href&#x3D;&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot; title&#x3D;&quot;&#123;&#123; post.title &#125;&#125;&quot; target&#x3D;&quot;_blank&quot;&gt;&#123;&#123; post.title &#125;&#125;&lt;&#x2F;a&gt;\n          &lt;&#x2F;li&gt;\n        &#123;% endfor %&#125;\n      &lt;&#x2F;ul&gt;\n    &lt;&#x2F;div&gt;\n&#123;% endif %&#125;\n\n将此代码贴在next/layout/macro/sidebar.swig中的if theme.links对应的endif后面为了配置方便，在主题的config.yml中添加了几个变量，如下：\nrecent_posts_title: 近期文章\nrecent_posts_layout: block\nrecent_posts: true\n\n\n\n以上操作之后NexT 7.8.0在侧边栏有“近期文章”的文字标志。但是没有链接。\n于是我换了另外一种办法，基于NexT 8.X\n第二种办法\n新建 source&#x2F;_data&#x2F;sidebar.njk 文件，内容如下：\n\n&#123;# RecentPosts #&#125;\n&#123;%- if theme.recent_posts %&#125;\n  &lt;div class&#x3D;&quot;links-of-recent-posts motion-element&quot;&gt;\n    &lt;div class&#x3D;&quot;links-of-recent-posts-title&quot;&gt;\n      &#123;%- if theme.recent_posts.icon %&#125;\n      &lt;i class&#x3D;&quot;&#123;&#123; theme.recent_posts.icon &#125;&#125; fa-fw&quot;&gt;&lt;&#x2F;i&gt;\n      &#123;%- endif %&#125;\n      &#123;&#123; theme.recent_posts.title &#125;&#125;\n    &lt;&#x2F;div&gt;\n    &lt;ul class&#x3D;&quot;links-of-recent-posts-list&quot;&gt;\n      &#123;%- set posts &#x3D; site.posts.sort(&#39;date&#39;, &#39;desc&#39;).toArray() %&#125;\n      &#123;%- for post in posts.slice(&#39;0&#39;, theme.recent_posts.max_count) %&#125;\n        &lt;li class&#x3D;&quot;links-of-recent-posts-item&quot;&gt;\n          &#123;&#123; next_url(post.path, post.title, &#123;title: post.path&#125;) &#125;&#125;\n        &lt;&#x2F;li&gt;\n      &#123;%- endfor %&#125;\n    &lt;&#x2F;ul&gt;\n  &lt;&#x2F;div&gt;\n&#123;%- endif %&#125;\n\n2.修改config.next.yml，取消 custom_file_path 中的 sidebar 和 style 两个注释，并新增 recent_posts 内容。\ncustom_file_path:\n  #head: source&#x2F;_data&#x2F;head.swig\n  #header: source&#x2F;_data&#x2F;header.swig\n  sidebar: source&#x2F;_data&#x2F;sidebar.njk\n  #postMeta: source&#x2F;_data&#x2F;post-meta.swig\n  #postBodyEnd: source&#x2F;_data&#x2F;post-body-end.swig\n  #footer: source&#x2F;_data&#x2F;footer.swig\n  #bodyEnd: source&#x2F;_data&#x2F;body-end.swig\n  #variable: source&#x2F;_data&#x2F;variables.styl\n  #mixin: source&#x2F;_data&#x2F;mixins.styl\n  style: source&#x2F;_data&#x2F;styles.styl\n\nrecent_posts:\n# 块标题\n  title: 最近文章\n# 图标\n  icon: fa fa-history\n# 最多多少文章链接\n  max_count: 5\n\n3.修改 source&#x2F;_data&#x2F;styles.styl 文件，文件不存在新建即可。添加如下代码：\n&#x2F;&#x2F; 近期文章\n.links-of-recent-posts\n  font-size: 0.8125em\n  margin-top: 10px\n\n.links-of-recent-posts-title\n  font-size: 1.03em\n  font-weight: 600\n  margin-top: 0\n\n.links-of-recent-posts-list\n  list-style: none\n  margin: 0\n  padding: 0\n\n\n\n然后发现这个只在站点概括中，在文章目录中不存在\n\n\n\n\n因为大多数访客是不会主动点击站点概括的，那么如何把近期文章板块加入到文章目录的侧边栏中去呢？\n我结合了第一种方法\n因为第一种办法，能够在目录中显示近期文章四个字，那么说明第一种方法可行，但是可能已经过时或者是笔者配置不正确。\n解决办法把上面新建的sidebar.njk代码复制在next/layout/_macro/sidebar.swig中的适应位置，如果没有修改添加过其他板块，可以在&#123;%- if theme.back2top.enable and theme.back2top.sidebar %&#125;的前面粘贴\n因为本博客添加了tag云，所以笔者放在了&#96;\n","slug":"Recent-articles","date":"2022-05-03T02:33:52.000Z","categories_index":"","tags_index":"hexo,NexT","author_index":"ACbug"},{"id":"d7143db213c9893f242cc9211977e79b","title":"添加友链踩坑记录","content":"新增links页面$ hexo new page links\n\n配置menu主题配置文件_config.yml中menu下添加：\nlinks: &#x2F;links&#x2F; || fa fa-link\n\n/themes/next/languages/zh-Hans.yml文件中menu下增加中文描述：\nlinks: 友链\n\n做完这些工作，接下来就是要增加友链页面的样式了\n新增links.swig页在/themes/next/layout/新建links.swig，内容如下：\n&#123;% block content %&#125;\n  &#123;######################&#125;\n  &#123;### LINKS BLOCK ###&#125;\n  &#123;######################&#125;\n\n    &lt;div id&#x3D;&quot;links&quot;&gt;\n        &lt;style&gt;\n\n            #links&#123;\n               margin-top: 5rem;\n            &#125;\n\n            .links-content&#123;\n                margin-top:1rem;\n            &#125;\n\n            .link-navigation::after &#123;\n                content: &quot; &quot;;\n                display: block;\n                clear: both;\n            &#125;\n\n            .card &#123;\n                width: 300px;\n                font-size: 1rem;\n                padding: 10px 20px;\n                border-radius: 4px;\n                transition-duration: 0.15s;\n                margin-bottom: 1rem;\n                display:flex;\n            &#125;\n            .card:nth-child(odd) &#123;\n                float: left;\n            &#125;\n            .card:nth-child(even) &#123;\n                float: right;\n            &#125;\n            .card:hover &#123;\n                transform: scale(1.1);\n                box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04);\n            &#125;\n            .card a &#123;\n                border:none;\n            &#125;\n            .card .ava &#123;\n                width: 3rem!important;\n                height: 3rem!important;\n                margin:0!important;\n                margin-right: 1em!important;\n                border-radius:4px;\n\n            &#125;\n            .card .card-header &#123;\n                font-style: italic;\n                overflow: hidden;\n                width: 236px;\n            &#125;\n            .card .card-header a &#123;\n                font-style: normal;\n                color: #2bbc8a;\n                font-weight: bold;\n                text-decoration: none;\n            &#125;\n            .card .card-header a:hover &#123;\n                color: #d480aa;\n                text-decoration: none;\n            &#125;\n            .card .card-header .info &#123;\n                font-style:normal;\n                color:#a3a3a3;\n                font-size:14px;\n                min-width: 0;\n                text-overflow: ellipsis;\n                overflow: hidden;\n                white-space: nowrap;\n            &#125;\n        &lt;&#x2F;style&gt;\n        &lt;div class&#x3D;&quot;links-content&quot;&gt;\n            &lt;div class&#x3D;&quot;link-navigation&quot;&gt;\n\n                &#123;% for link in theme.friendlinks %&#125;\n\n                    &lt;div class&#x3D;&quot;card&quot;&gt;\n                        &lt;img class&#x3D;&quot;ava&quot; src&#x3D;&quot;&#123;&#123; link.avatar &#125;&#125;&quot;&#x2F;&gt;\n                        &lt;div class&#x3D;&quot;card-header&quot;&gt;\n                        &lt;div&gt;&lt;a href&#x3D;&quot;&#123;&#123; link.site &#125;&#125;&quot; target&#x3D;&quot;_blank&quot;&gt;@ &#123;&#123; link.nickname &#125;&#125;&lt;&#x2F;a&gt;&lt;&#x2F;div&gt;\n                        &lt;div class&#x3D;&quot;info&quot;&gt;&#123;&#123; link.info &#125;&#125;&lt;&#x2F;div&gt;\n                        &lt;&#x2F;div&gt;\n                    &lt;&#x2F;div&gt;\n\n                &#123;% endfor %&#125;\n\n            &lt;&#x2F;div&gt;\n            &#123;&#123; page.content &#125;&#125;\n            &lt;&#x2F;div&gt;\n        &lt;&#x2F;div&gt;\n\n  &#123;##########################&#125;\n  &#123;### END LINKS BLOCK ###&#125;\n  &#123;##########################&#125;\n&#123;% endblock %&#125;\n\n修改page.swig修改/themes/next/layout/page.swig文件，在\n&#123;%- elif page.type &#x3D;&#x3D;&#x3D; &#39;schedule&#39; and not page.title %&#125;\n    &#123;&#123;- __(&#39;title.schedule&#39;) + page_title_suffix &#125;&#125;\n\n下面添加：\n&#123;%- elif page.type &#x3D;&#x3D;&#x3D; &#39;links&#39; and not page.title %&#125;\n  &#123;&#123;- __(&#39;title.links&#39;) + page_title_suffix &#125;&#125;\n\n引入links.swig关键在于所有的教程中给了引入代码，但没有说具体在哪里插入\n在/themes/next/layout/page.swig中的\n&#123;% elif page.type &#x3D;&#x3D;&#x3D; &#39;schedule&#39; %&#125;\n  &lt;div class&#x3D;&quot;event-list&quot;&gt;\n  &lt;&#x2F;div&gt;\n\n  &#123;% include &#39;_scripts&#x2F;pages&#x2F;schedule.swig&#39; %&#125;\n\n插入\n&#123;% elif page.type &#x3D;&#x3D;&#x3D; &#39;links&#39; %&#125;\n  &#123;% include &#39;links.swig&#39; %&#125;\n\n得到\n&#123;% elif page.type &#x3D;&#x3D;&#x3D; &#39;schedule&#39; %&#125;\n  &lt;div class&#x3D;&quot;event-list&quot;&gt;\n  &lt;&#x2F;div&gt;\n&#123;% elif page.type &#x3D;&#x3D;&#x3D; &#39;links&#39; %&#125;\n  &#123;% include &#39;links.swig&#39; %&#125;\n  &#123;% include &#39;_scripts&#x2F;pages&#x2F;schedule.swig&#39; %&#125;\n\n主题配置添加在主题配置文件_config.yml末尾处添加友链：\nmylinks:\n  - nickname:  #友链名称\n    avatar:   #友链头像\n    site:   #友链地址\n    info:   #友链说明\n  - nickname:  #友链名称\n    avatar:   #友链头像\n    site:   #友链地址\n    info:   #友链说明\n","slug":"Add-links","date":"2022-05-02T19:11:54.000Z","categories_index":"","tags_index":"hexo,NexT","author_index":"ACbug"},{"id":"29dc150f2713e4a77f5b3367a0e5cd4a","title":"信息安全保障概述","content":"本章概述了信息安全保障的相关内容。“信息安全保障背景”部分介绍了信息技术发展的各个阶段及其对社会产生的影响；“信息安全保障基础”部分讲述了信息安全发展阶段以及信息安全的含义、问题根源及其在社会中的地位和作用；“信息安全保障体系”部分讲解了信息安全保障基本体系框架，并详细阐述了典型的P2DR安全模型和IATF框架的基本原理；“信息安全保障基本实践”部分讲述了国内外实践概况和信息安全保障的基本工作内容\n大纲要求1.信息安全保障的内涵和意义 \n２.信息安全保障的总体思路和基本实践方法 \n目标：1）了解信息技术发展各阶段的影响\n2）了解信息安全发展各阶段的特征\n3）理解信息安全的含义、问题根源及其所在国家和信息社会中的地位和作用\n4）理解信息安全保障体系\n5）理解P2DR模型的基本原理及其数学公式的含义\n6）理解IATF纵深防御思想及其对信息系统技术4个方面的安全要求划分\n7）了解国内外信息安全保障工作概况\n8）理解信息安全保障工作的各部分内容及其主要原则\n信息安全保障背景信息技术及其发展阶段什么是“信息”？香农认为：信息是用来减少不确定性的东西。\n我国信息论专家钟义信把信息定义为：事物运动状态和状态变化的方式。\n下面比较分析信息与信息相关且容易混淆的概念：信息与消息：信息是消息的外壳，消息则是信息的内核\n消息与信号：信号是信息的载体，信息则是信号的承载内容\n信息与数据：数据是记录信息的一种形式\n数据和情报：情报是秘密的专门的一类信息，所有的情报都是信息，但信息并不一定是情报\n信息与知识：知识是从信息中抽象出的产物，是信息的特殊子集\n他们的关系如图所示\n\n信息技术的定义笼统的讲，信息技术是能够延伸或拓展人的信息能力的手段和方法\n信息技术包括生产和应用两个方面。\n信息技术的生产主要体现在信息技术产业，包括计算机软硬件、电信设备、电子生产等；\n信息技术的应用则体现在信息技术的扩散上，包括信息服务、管理信息系统等。\n在信息技术系统中，微电子技术、通信技术、计算机技术和网络技术可以称为信息技术的核心它们的发展进程体现了信息技术的发展过程。\n\n信息技术的产生和发展：信息技术的产生与发展，大致经历了如下3个阶段\n第一阶段，电讯技术的发明。（可以追溯19世纪30年代电报电话的发明）\n电讯技术的出现为信息技术的出现与发展奠定了基础。\n第二阶段，计算机技术的发展。\n\n\n\n\n\n\n\n\n\n1945年，现计算机之父冯·诺依曼等提出了“存储程序通用电子计算机方案”——EDVAC。1946年2月1日，世界上第一台现代电子计算机“埃尼阿克(ENIAC)”诞生于美国宾夕法尼亚大学。现代计算机一直沿用着冯·诺依曼体系结构，可见其对计算机技术发展的影响。\n计算机技术的发展和应用，加快了人类奔向信息时代的步伐。\n第三阶段，互联网技术的发展。\n前两个阶段只有局部意义，影响有限。\n20世纪60年代末，美国出现了第一个用于军事目的计算机网络ARPAnet。ARPAnet研究产生的一项非常重要的成果就是TCP&#x2F;IP协议(Transmission Control Protocol&#x2F;Internet Protocol)，即传输控制协议&#x2F;互联协议，使得连接到网络上的所有算机能够相互交流信息。\n20世纪90年代，计算机网络发展成为全球性网络——因特网(Intnet)，计算机网络技术和网络应用得到了迅猛的发展，这时段才把电信、电话、电视、计算机、互联网络等连接起来，实现多媒体传输。\n\n\n信息技术的影响积极影响1）对社会发展的影响科学是第一生产力\n信息技术的广泛应用，引发了社会的深刻变革，加速了社会生产力的发展和人们生活质量的提高\n信息资源继物质和能源之后将成信息化社会最主要的支柱之一。\n减少地域差别和经济发展造成的差异\n2）对科技进步的影响极大地推动了科学技术的发展。\n计算机技术的应用，帮助人门攻克了一个又一个科学难题。\n便于验证各种科学假设。\n带动了一批尖端技术的发展。\n信息技术在基础学科中的应用及与其他学科的融合促进了新学科(如计算物理、计算化学等)和交叉学科(如人工智能、电子商务、大数据技术等)的产生发展。\n消极影响1）信息泛滥信息量急剧增长，并且人们消耗大量的时间却找不到有用的信息\n2）信息污染一些错误信息、虚假信息、污秽信息等混杂在各种信息资源中，人们如果不加以分析，容易深受其害\n3）信息犯罪人们对信息技术的依赖程度越来越高，一些不法分子利用信息技术手段以及信息系统本身的安全漏洞进行犯罪活动，危害着正常的社会秩序。\n信息安全保障基础信息安全发展阶段信息安全的发展大致经历了三个阶段：\n信息保密阶段&gt;计算机安全阶段&gt;信息安全保障阶段\n通信保密阶段当代信息安全学起源于20世纪40年代的通信保密\n香农以概率统计的方法对消息源、密钥源、接收和截获的消息进行数学描述和分析，用不确定性来度量密码体制的保密性阐明了密码系统、完善保密性、纯密码、理论保密性和实际保密性等重要概念，从而大大深化了人们对于信息保密和密码学的理解。\n计算机安全阶段1965年，美国率先提出了计算机安全(COMPUSEC)。人们对信息安全的关注扩大为“密性、访问控制与认证”。\n在这一阶段，计算机主要的用途是军事和科研。访问制关注信息的机密性，这一时期提出了强制访问控制策略和自主访问控制策略。\n其间进行的重要工作包括：1969年B.W.Lampson提出的访问控制矩阵，70年代 Harrison、Ruzzo和Ullman提出的HRU模型，1976年David Bell和Leonard LaPadula提出的BLP模型，以及1977年Biba提出的BIBA模型。其中，BLP模型是影响深远的强制访问控制模型；BIBA模型是提出较早的面向完整性的访问控制模型；HRU模型给出了形式化的访问控制矩阵的描述\n在这一时期、密码学仍然得到了快速发展，最有影响的有两件大事件。\n第一件是Diffie和Hellman首次证明了在发送者和接收者之间无密钥交换的保密通信是可能的，从而开创了公钥密码学的新纪元。\n第二件是美国于1977年制定的数据加密标准 DES(Data Encryption Standard)，它为加密算法的标准化奠定了基础。\n信息安全保障阶段20世纪90年代以后，开始倡导信息保障(Information Assurance，IA)。\n1995年，在研究信息安全及网络战防御理论过程中，美国国防部提出了“信息安全保障体系”(IA)概念，并给出了“保护(Protection)—监测(Detection)一响应(Response)”三环节动态模型，即PDR模型。后来增加了恢复(Restore)，变为PDRR模型。\nBS 7799标准是由英国标准协会制定的信息安全管理标准，是国际上具有代表性的信息安全管理体系标准。该信息安全管理标准包括两个部分，即BS 7799-1:1999《信息安全管理实田则》和BS 7799-2:1999《信息安全管理体系规范》。其中 BS 7799-1标准已经于2000年正式换为ISO国际标准，即ISO 17799信息安全管理体系实施指南。2005年，修订后的ISO&#x2F;IE 7799被集成到ISO 27000系列标淮中，标准号为ISO&#x2F;IEC 27002，它综合了信息安全管理方面委的控制措施，可为各类组织和机构在信息安全方面提供建议性指南。BS 7799&#x2F;ISO 17799主要章节包括范围、术语和定义、控制细则。BS 7799-2还包括了信！安全管理体系(Information Security Management System，ISMS)的概念，基本内容涉及信息安全\n信息安全的定义","slug":"Overview-of-information-security","date":"2022-04-30T11:57:49.000Z","categories_index":"","tags_index":"信息安全技术,计算机三级","author_index":"ACbug"},{"id":"3739ff3484591b06542a91d4fe82419f","title":"计算机等级考试计算机三级信息安全技术总汇","content":"考试大纲基本要求１． 了解信息安全保障工作的总体思路和基本实践方法 \n２． 掌握信息安全技术的基本概念、原理、方法和技术 \n３． 熟练掌握计算机网络安全、系统软件安全和应用软件安全的基本知识和实践技能 \n４． 掌握信息安全设备的安装、配置和使用的基本方法 \n５． 了解信息系统安全设施部署与管理基本技术 \n６． 了解信息安全风险评估和等级保护原理与方法 \n７． 了解信息安全相关的标准、法律法规和道德规范\n考试内容一、信息安全保障概述快速链接：https://i-nmb.cn/Overview-of-information-security.html\n１． 信息安全保障的内涵和意义&lt;!--概念：人们对事物本质的认识,逻辑思维的最基本单元和形式.概念是反映事物本质属性的思维产物.内涵：一个概念所反映的事物的本质属性的总和,也就是概念的内容--&gt;\n\n２． 信息安全保障的总体思路和基本实践方法二、信息安全基础技术与原理１． 密码技术（１）对称密码与非对称密码 \n（２）哈希函数 \n（３）数字签名 \n（４）密钥管理 \n２． 认证技术（１）消息认证 \n（２）身份认证 \n３． 访问控制技术（１）访问控制模型 \n（２）访问控制技术 \n４． 审计和监控技术（１）审计和监控基础 \n（２）审计和监控技术 \n三、系统安全１． 操作系统安全（１）操作系统安全基础 \n（２）操作系统安全实践 \n２． 数据库安全（１）数据库安全基础 \n（２）数据库安全实践 \n四、网络安全１． 网络安全基础２． 网络安全威胁技术３． 网络安全防护技术（１）防火墙 \n（２）入侵检测系统与入侵防御系统 \n（３）ＰＫＩ \n（４）Ｖ什么N \n（５）网络安全协议 \n五、应用安全１． 软件漏洞概念与原理２． 软件安全开发３． 软件安全检测４． 软件安全保护５． 恶意程序６． Ｗｅｂ 应用系统安全六、信息安全管理１． 信息安全管理体系２． 信息安全风险评估３． 信息安全管理措施七、信息安全标准与法规１． 信息安全标准２． 信息安全法律法规与国家政策３． 信息安全从业人员道德规范","slug":"Information-Security-Technology","date":"2022-04-30T11:55:45.000Z","categories_index":"","tags_index":"信息安全技术,计算机三级","author_index":"ACbug"},{"id":"9917f10b4cf6a70c778dc683ddd22f00","title":"NexT主题修改侧边滚动条","content":"NexT主题修改侧边栏在(root)\\themes\\next\\source\\css找到_other.styl，没有就自建。\n增添以下代码：\n::-webkit-scrollbar-thumb &#123;\n    background-color: #FF2A68;\n    background-image: -webkit-linear-gradient(45deg,rgba(255,255,255,.4) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.4) 50%,rgba(255,255,255,.4) 75%,transparent 75%,transparent);\n    border-radius: 3em;\n&#125;\n::-webkit-scrollbar-track &#123;\n    background-color: #ffcacaff;\n    border-radius: 3em;\n&#125;\n::-webkit-scrollbar &#123;\n    width: 8px;\n    height: 15px;\n&#125;\n\n\n若发现配色不适合网页，例如：\n\n可以去：在线调色助手配色参考(rockhwhuang.com)，挑选自己喜欢的颜色，然后在::-webkit-scrollbar-thumb&#123;background-color:&#125;更改滚条颜色，在::-webkit-scrollbar-track 中的background-color:修改背景颜色\n","slug":"scrollbar","date":"2022-04-29T02:02:57.000Z","categories_index":"","tags_index":"hexo,NexT","author_index":"ACbug"},{"id":"0094475e0b5cfff6e0abbc30d0b5b22d","title":"JAVA学习知识总汇—JAVA语言基础","content":"（以下文章大多参考《Java从入门到精通 第5版 明日科技》。故以下文章不采用 BY-NC-SA 许可协议）\nJAVA语言基础要掌握并熟练应用Java语言，就需要对Java语言的基础进行充分的了解。\nJAVA语言基础 | 一些笔记-i囡漫笔 (i-nmb.cn)\n流程控制流程控制对于任何一门编程语言来说都是至关重要的，它提供了控制程序步骤的基本手段。\n流程控制 | 一些笔记-i囡漫笔 (i-nmb.cn)\n字符串字符串是Java程序中经常处理的对象，如果字符串运用得不好，将影响到程序运行的效率。\n字符串 | 一些笔记-i囡漫笔 (i-nmb.cn)\n数组数组是最为常见的一种数据结构，是相同类型的用一个标识符封装到一起的基本类型数据序列或对象序列。\n数组 | 一些笔记-i囡漫笔 (i-nmb.cn)\n","slug":"JAVA","date":"2022-04-28T02:06:52.000Z","categories_index":"","tags_index":"Eclipse,Java","author_index":"ACbug"},{"id":"4f0f7aced0ab37b53159f295f5420300","title":"Java 数组—JAVA语言基础","content":"通过阅读本篇，您可以：\n掌握一维数组的创建和使用方法\n掌握二维数组的创建和使用方法\n了解如何遍历数组\n了解如何填充替换数组中的元素\n了解如何对数组进行排序\n了解如何复制数组\n了解查询数组的方法\n数组概述数组是具有相同数据类型的一组数据的集合。数组中的每个元素具有相同的数据类型。\n在Java中同样将数组看作一个对象，虽然基本数据类型不是对象，但由基本数据类型组成的数组却是对象。\n一维数组的创建及使用一维数组实质上是一组相同类型数据的线性集合，当在程序中需要处理一组数据，或者传递一组数据时，可以应用这种类型的数组。\n创建一维数组数组作为对象允许使用new关键字进行内存分配。在使用数组之前，必须首先定义数组变量所属的类型。一维数组的创建有两种形式。\n先声明，再用new运算符进行内存分配声明一维数组有下列两种方式：\n\n数组元素类型决定了数组的数据类型。\n它可以是Java中任意的数据类型，包括简单类型和组合类型。数组名字为一个合法的标识符，符号“[ ]”指明该变量是一个数组类型变量。单个“[ ]”表示要创建的数组是一个一维数组。\n声明一维数组，实例代码\n\n声明数组后，还不能立即访问它的任何元素，因为声明数组只是给出了数组名字和元素的数据类型\n要想真正使用数组，还要为它分配内存空间。在为数组分配内存空间时必须指明数组的长度。\n数组名字 &#x3D; new 数组元素的类型[数组元素的个数];\n\narr &#x3D; new int[5];\n\n声明的同时为数组分配内存这种创建数组的方法是将数组的声明和内存的分配合在一起执行。\n\n\n\n\n\n\n\n\n\n数组元素的类型 数组名 &#x3D; new数组元素的类型[数组元素的个数];\nint month[ ] &#x3D; new int[12]\n\n上面的代码创建数组month，并指定了数组长度为12。这种创建数组的方法也是Java程序编写过程中普遍的做法。\n初始化一维数组数组与基本数据类型一样可以进行初始化操作。\n数组的初始化可分别初始化数组中的每个元素。\n数组的初始化有以下两种形式：\n\n从中可以看出，数组的初始化就是包括在大括号之内用逗号分开的表达式列表。\n使用一维数组在Java集合中一维数组是常见的一种数据结构。下面的实例是使用一维数组将1～12月各月的天数输出。\n\n\n二维数组的创建及使用如果一维数组中的各个元素仍然是一个数组，那么它就是一个二维数组。\n二维数组的创建二维数组可以看作是特殊的一维数组，因此，二维数组的创建同样有两种方式。\n先声明，再用new运算符进行内存分配声明二维数组的语法如下：\n数组元素的类型 数组名字[ ][ ];\n\n数组元素的类型[ ][ ] 数组名字;\n\n例如：int myarr[][];\n同一维数组一样，二维数组在声明时也没有分配内存空间，同样要使用new关键字来分配内存，然后才可以访问每个元素。\n对于高维数组，有两种为数组分配内存的方式：\n（1） 直接为每一维分配内存空间为每一维数组分配内存，实例代码如下\na &#x3D; new int[2][4]\n\n上述代码创建了二维数组a，二维数组a中包括两个长度为4的一维数组\n（2） 分别为每一维分配内存分别为每一维分配内存，实例代码如下\na &#x3D; new int[2][];\n\na[0] &#x3D; new int[2];\n\na[1] &#x3D; new int[3];\n\n声明的同时为数组分配内存第二种方式同第一种实现的功能相同。使用这种方式为二维数组分配内存时，首先指定最左边维数的内存，然后单独地给余下的维数分配内存。\n\n二维数组初始化二维数组的初始化与一维数组初始化类似，同样可以使用大括号完成。\n语法如下：\ntype arrayname[][] &#x3D; &#123;value1,value2…valuen&#125;;\n\ntype：数组数据类型。\narrayname：数组名称，一个合法的标识符。\nvalue：数组中各元素的值。\n初始化二维数组，实例代码如下：\nint myarr[][] &#x3D; &#123;&#123;12,0&#125;,&#123;45,10&#125;&#125;;\n\n初始化二维数组后，要明确数组的下标都是从0开始。例如，上面的代码中myarr[1] [1]的值为10。\nint型二维数组是以int a [][]来定义的，所以可以直接给a[x] [y]赋值。例如，给a[1]的第2个元素赋值的语句如下\na[1][1] &#x3D; 20\n\n使用二维数组二维数组在实际应用中用得非常广泛。\n下面的实例就是使用二维数组输出一个3行4列且所有元素都是0的矩阵。\n\n运行结果如图\n\n数组的基本操作java.util包的Arrays类包含了用来操作数组（如排序和搜索）的各种方法，本节就将介绍数组的基本操作。\n遍历数组遍历数组就是获取数组中的每个元素。通常遍历数组都是使用for循环来实现。遍历一维数组很简单，也很好理解，下面详细介绍遍历二维数组的方法。\n遍历二维数组需使用双层for循环，通过数组的length属性可获得数组的长度。\npublic class Trap&#123;\n    public static void main(String[] args)&#123;\n        int b[][] &#x3D; new int[][]&#123;&#123;1&#125;,&#123;2,3&#125;,&#123;4,5,6&#125;&#125;;\n        for(int k&#x3D;0;k&lt;b.length;k++)&#123;\n            for(int c&#x3D;0;c&lt;b[k].length;c++)&#123;\n                System.out.println(b[k][c]);\n            &#125;\n            System.out.println();\n        &#125;\n    &#125;\n&#125;\n\n运行结果如图\n\n在遍历数组时，使用foreach语句可能会更简单。下面的实例就是通过foreach语句遍历二维数组。\n在项目中创建类Tautog，在主方法中定义二维数组，使用foreach语句遍历二维数组代码如下:\npublic class Tautog&#123;\t\t\t\t\t\t\t\t\n    public static void main(String[] args)&#123;\n        int arr2[][] &#x3D; &#123;&#123;4,3&#125;,&#123;1,2&#125;&#125;;\n        System.out.println(&quot;数组中的元素是：&quot;);\n        int i &#x3D; 0;\n        for(int x[]:arr2)&#123;\t\t&#x2F;&#x2F;外层循环变量为一维数组\n            i++;\t\t\t\t&#x2F;&#x2F;外层计数器递增\n            int j &#x3D; 0;\n            for(int e:x)&#123;\t\t&#x2F;&#x2F;循环遍历每一个数组元素\n                j++;\t\t\t&#x2F;&#x2F;内层计数器递增\n                if(i &#x3D;&#x3D; arr2.length &amp;&amp; j &#x3D;&#x3D; x.length)&#123;\t\t&#x2F;&#x2F;判断变量是二维数组的最后一个元素\n                    System.out.print(e);\t\t\t\t\t&#x2F;&#x2F;输出二维数组最后一个元素\n                &#125;else\n                    System.out.print(e + &quot;、&quot;)\t\t\t\t&#x2F;&#x2F;如果不是最后个元素则输出e、\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n运行结果：\n\n填充替换数组元素数组中的元素定义完成后，可通过Arrays类的静态方法fill()来对数组中的元素进行替换。\n该方法通过各种重载形式可完成对任意类型的数组元素的替换。fill()方法有两种参数类型，下面以int型数组为例介绍fill()方法的使用方法。\n（1） fill(int[] a,int value)该方法可将指定的int值分配给int型数组的每个元素。\n语法如下\nfill(int[] a,int value)\n\na：要进行元素替换的数组。\nvalue：要存储数组中所有元素的值。\n在项目中创建类Swap，在主方法中创建一维数组，并实现通过fill()方法填充数组元素，最后将数组中的各个元素输出。\nimport java.util.Arrays;\npublic class Swap&#123;\n    public static void main(String[] atgs)&#123;\n        int arr[] &#x3D; new int[5];\t\t\t\t&#x2F;&#x2F;新建int型数组\n        Arrays.fill(arr,8);\t\t\t\t\t&#x2F;&#x2F;使用同一个值对数组进行填充\n        for(int i &#x3D; 0;i &lt; arr.length;i++)&#123;\t&#x2F;&#x2F;循环遍历数组中的元素\n            &#x2F;&#x2F;将数组中的元素依次输出\n            System.out.println(&quot;第&quot; + i + &quot;个元素是：&quot; + arr[i]);\n        &#125;\n    &#125;\n&#125;\n\n\n（2） fill(int[] a,int fromIndex,int toIndex,int value)该方法将指定的int值分配给int型数组指定范围中的每个元素。填充的范围从索引fromIndex（包括）一直到索引toIndex（不包括）。如果fromIndex &#x3D;&#x3D; toIndex，则填充范围为空。\n语法如下：\nfill(int[] a,int fromIndex,int toIndex,int value)\n\na：要进行填充的数组。\nfromIndex：要使用指定值填充的第一个元素的索引（包括）。\ntoIndex：要使用指定值填充的最后一个元素的索引（不包括）。\nvalue：要存储在数组所有元素中的值。\n下实例我们通过 Java Util 类的 Arrays.fill(arrayname,value) 方法和Arrays.fill(arrayname ,starting index ,ending index ,value) 方法向数组中填充元素：\nimport java.util.*;\npublic class FillTest &#123;\n    public static void main(String args[]) &#123;\n        int array[] &#x3D; new int[6];\n        Arrays.fill(array, 100);\n        for (int i&#x3D;0, n&#x3D;array.length; i &lt; n; i++) &#123;\n            System.out.println(array[i]);\n        &#125;\n        System.out.println();\n        Arrays.fill(array, 3, 6, 50);\n        for (int i&#x3D;0, n&#x3D;array.length; i&lt; n; i++) &#123;\n            System.out.println(array[i]);\n        &#125;\n    &#125;\n&#125;\n\n以上代码运行输出结果为：\n100\n100\n100\n100\n100\n100\n\n100\n100\n100\n50\n50\n50\n\n对数组进行排序通过Arrays类的静态sort()方法可以实现对数组的排序。sort()方法提供了多种重载形式，可对任意类型的数组进行升序排序。\n语法如下\nArrays.sort(object)\n\n其中，object是指进行排序的数组名称\n\n运行结果如图\n\n上述实例是对整型数组进行排序。Java中的String类型数组的排序算法是根据字典编排顺序排序的，因此数字排在字母前面，大写字母排在小写字母前面。\n复制数组Arrays类的copyOf()方法与copyOfRange()方法可以实现对数组的复制。copyOf()方法是复制数组至指定长度，copyOfRange()方法则将指定数组的指定长度复制到一个新数组中。\n（1） copyOf()方法该方法提供了多种重载形式，用于满足不同类型数组的复制。语法如下\n  \narr：要进行复制的数组。\nnewlength：int型常量，指复制后的新数组的长度。\nint[] a &#x3D; &#123;1,2,3,4&#125;;\nint[] a1 &#x3D; Arrays.copyOf(a,2);&#x2F;&#x2F;复制指定的数组长度\nint[] a2 &#x3D; Arrays.copyOf(a,3);\nint[] a3 &#x3D; Arrays.copyOf(a,5);\nSystem.out.println(Arrays.toString(a1));\nSystem.out.println(Arrays.toString(a2));\nSystem.out.println(Arrays.toString(a3));\n\n\n运行结果\n[1, 2] [1, 2, 3] [1, 2, 3, 4, 0]\n\n\n\n（2） copyOfRange()方法该方法同样提供了多种重载形式\ncopyOfRange(arr,int formIndex,int toIndex)\n\narr：要进行复制的数组对象。 \nformIndex：指定开始复制数组的索引位置。formIndex必须在0至整个数组的长度之间。新数组包括索引是formIndex的元素。\ntoIndex：要复制范围的最后索引位置。可大于数组arr的长度。新数组不包括索引是toIndex的元素。\n\n运行结果如图\n\n数组查询Arrays类的binarySearch()方法，可使用二分搜索法来搜索指定数 组，以获得指定对象。该方法返回要搜索元素的索引值。binarySearch() 方法提供了多种重载形式，用于满足各种类型数组的查找需要。binarySearch()方法有两种参数类型。\n（1） binarySearch(Object[],Object key)binarySearch(Object[] a, Object key)\n\na: 要搜索的数组\nkey：要搜索的值\n如果key在数组中，则返回搜索值的索引；否则返回-1或“-”（插入点）。插入点是索引键将要插入数组的那一点，即第一个大于该键的元素的索引。\n技巧：\n[1] 搜索值不是数组元素，且在数组范围内，从1开始计数，得“ - 插入点索引值”；\n[2] 搜索值是数组元素，从0开始计数，得搜索值的索引值；\n[3] 搜索值不是数组元素，且小于数组内元素，索引值为 – 1；\n[4] 搜索值不是数组元素，且大于数组内元素，索引值为 – (length + 1);\nimport java.util.Arrays;\n \npublic class ArraysBinarySearch &#123;\n    public static void main(String[] args) &#123;\n        int arr[] &#x3D; new int[]&#123;3, 5, 7, 9, 11, 13&#125;;\n \n        Arrays.sort(arr);\n \n        for (int i &#x3D; 0; i &lt; 17; i++) &#123;\n            System.out.println(&quot;数字【&quot; + i + &quot;】：&quot; + Arrays.binarySearch(arr, i));\n        &#125;\n    &#125;\n&#125;\n\n结果\n数字【0】：-1\n数字【1】：-1\n数字【2】：-1\n数字【3】：0\n数字【4】：-2\n数字【5】：1\n数字【6】：-3\n数字【7】：2\n数字【8】：-4\n数字【9】：3\n数字【10】：-5\n数字【11】：4\n数字【12】：-6\n数字【13】：5\n数字【14】：-7\n数字【15】：-7\n数字【16】：-7\n\n\n\n（2） binarySearch(Object[],int fromIndex,int toIndex,Object key)该方法在指定的范围内检索某一元素。\n\na：要进行检索的数组。\nfromIndex：指定范围的开始处索引（包含）。\ntoIndex：指定范围的结束处索引（不包含）。\nkey：要搜索的元素。\n\n\n","slug":"array","date":"2022-04-24T02:45:43.000Z","categories_index":"","tags_index":"Eclipse,Java","author_index":"ACbug"},{"id":"a0b788c0a9c8204476e0b9b4b152450c","title":"Java 字符串—JAVA语言基础","content":"本篇从创建字符串开始向读者介绍字符串本身的特性，以及字符串上可用的几个操作等。\n通过阅读本章，您可以：\n​\t掌握字符串的创建方式\n​\t理解字符串连接的方式\n​\t掌握获取字符串信息的方式\n​\t掌握字符串的常用操作 \n​\t掌握字符串的格式化方法\n​\t理解正则表达式\n​\t掌握字符串生成器的用法\nString类前面的章节中介绍了char类型，它只能表示单个字符，不能表示由多个字符连接而成的字符串。\n在Java语言中将字符串作为对象来处理， 可以通过java.lang包中的String类来创建字符串对象\n声明字符串在Java语言中字符串必须包含在一对双引号（” “）之内。\n如：&quot;23.23&quot;、&quot;ABCDE&quot;、&quot;你好&quot;\n可以通过以下语法格式来声明字符串变量：\nString str ;\n\nString：指定该变量为字符串类型。\nstr：任意有效的标识符，表示字符串变量的名称。\n\n\n\n\n\n\n\n\n\n声明字符串变量必须经过初始化才能使用，否则编译器会报出“变量未被初始化错误”。\n创建字符串String类的常用构造方法如下：\n（1） String(char a[])\n用一个字符数组a创建String对象，实例代码如下：\n\n（2） String(char a[], int offset, int length)\n提取字符数组a中的一部分创建一个字符串对象。参数offset表示开始截取字符串的位置，length表示截取字符串的长度。\n\n除通过以上几种使用String类的构造方法来创建字符串变量外，还可通过字符串常量的引用赋值给一个字符串变量。\n引用字符串常量来创建字符串变量，实例代码如下\nString str1,str2;\nstr1 &#x3D; &quot;We are students&quot; srt2 &#x3D; &quot;We are students&quot;\n\n连接字符串对于已声明的字符串，可以对其进行相应的操作。连接字符串就是字符操作中较简单的一种。\n连接多个字符串使用“+”运算符可实现连接多个字符串的功能。“+”运算符可以连接多个运算符并产生一个String对象。\n\n\n\n\n\n\n\n\n\n\n\n\nJava中一句相连的字符串不能分开在两行中写。例如，下列语句的写法就是错误的。\nSystem.out.println(“I like Java”)\n如果一个字符串太长，为了便于阅读，必须将这个字符串分在两行上书写。则需要使用“+”将两个字符串连起来，之后在加号处换行。因此，上面的语句可以修改为：\nSystem.out.println(“I like”+ “Java”);\n连接其他数据类型字符串也可同其他基本数据类型进行连接。字符串同这些数据类型数据进行连接，会将这些数据直接转换成字符串\n\n\n本实例实现的是将字符串常量与整型变量booktime和浮点型变量practice相连后的结果输出。在这里booktime和practice都不是字符串，当它们与字符串相连时会自动调用toString()方法，将其转换成字符串形 式，然后参与连接。\n\n获取字符串信息字符串作为对象，可通过相应方法获取字符串的有效信息，如获取某字符串的长度、某个索引位置的字符等。\n获取字符串长度使用String类的length()方法可获取声明的字符串对象的长度。\n语法：\nstr.length();\n\n其中，str为字符串对象\n例如：\nString str &#x3D; &quot;We are students&quot;;\nint size &#x3D; str.length();\n\n字符串查找String类提供了两种查找字符串的方法，即indexOf()与lastIndexOf()\n（1） indexOf(String s)\n该方法用于返回参数字符串s在指定字符串中首次出现的索引位\n置。当调用字符串的indexOf()方法时，会从当前字符串的开始位置搜索\ns的位置；如果没有检索到字符串s，该方法的返回值是-1。\n语法如下：str.indexOf(substr)\nstr：任意字符串对象。\nsubstr：要搜索的字符串。\n例如：\nString str &#x3D; &quot;We are students&quot;;\nint size &#x3D; str.indexOf(&quot;a&quot;)\n\n代码查找到a在字符串的位置（从0开始，直到3，所以size变量是3）\n（1） lastIndexOf(String str)\n该方法用于返回指定字符串最后一次出现的索引位置。当调用字符串的lastIndexOf()方法时，会从当前字符串的开始位置检索参数字符串str，并将最后一次出现str的索引位置返回。如果没有检索到字符串str，该方法返回-1。\n语法如下：\nstr. lastIndexOf(substr)\n\n在项目中创建类Text，在主方法中创建String对象，使用lastIndexOf()方法查看字符串str中空字符串的位置，然后输出字符串的长度，看它们是否相同。\n\n\n结果：\n\n获取指定索引位置的字符使用charAt()方法可将指定索引处的字符返回。语法如下：\n\nstr：任意字符串\nindex：整型值，用于指定要返回字符的下标\n\n\n\n字符串操作String类中包含了很多方法，允许程序员对字符串进行操作来满足实际编程中的需要。\n获取子字符串通过String类的substring()方法可对字符串进行截取。这些方法的共同点就是都利用字符串的下标进行截取，且应明确字符串下标是从0开始的。\nsubstring()方法被两种不同的方法重载，来满足不同的需要。\n（1） substring(int beginIndex)该方法返回的是从指定的索引位置开始截取直到该字符串结尾的子串。\n语法如下：\nstr.substring(int beginIndex)\n\n其中，beginIndex指定从某一索引处开始截取字符串\n例如\n\n\n\n\n\n\nubstring() 方法返回字符串的子字符串。\n语法public String substring(int beginIndex)\n\n或\n\npublic String substring(int beginIndex, int endIndex)\n\n参数\nbeginIndex – 起始索引（包括）, 索引从 0 开始。\nendIndex – 结束索引（不包括）。\n\n\n返回值子字符串。\n实例public class RunoobTest &#123;\n    public static void main(String args[]) &#123;\n        String Str &#x3D; new String(&quot;This is text&quot;);\n \n        System.out.print(&quot;返回值 :&quot; );\n        System.out.println(Str.substring(4) );\n \n        System.out.print(&quot;返回值 :&quot; );\n        System.out.println(Str.substring(4, 10) );\n    &#125;\n&#125;\n\n\n\n返回值 : is text\n返回值 : is te\n\n\n\n\n\n（2） substring(int beginIndex, int endIndex)该方法返回的是从字符串某一索引位置开始截取至某一索引位置结束的子串。\n语法如下：\nsubstring(int beginIndex, int endIndex)\n\n\n\n\n\n\n去除空格trim()方法返回字符串的副本，忽略前导空格和尾部空格\nstr.trim()\n\n\n\n\n字符串替换语法如下：\nstr.replace(char oldChar,char newChar)\n\noldChar：要替换的字符或字符串\nnewChar：用于替换原来字符串的内容\nreplace()方法返回的结果是一个新的字符串。如果字符串oldChar没有出现在该对象表达式中的字符串序列中，则将原字符串返回。\n\n\n\n判断字符串的开始与结尾startsWith()方法与endsWith()方法分别用于判断字符串是否以指定的内容开始或结束。这两个方法的返回值都为boolean类型。\n（1） startsWith()方法该方法用于判断当前字符串对象的前缀是否为参数指定的字符串。\n语法如下：\n\n（2） endsWith()方法该方法用于判断当前字符串是否为以给定的子字符串结束。\n语法如下：\n\n\n\n\n判断字符串是否相等对字符串对象进行比较不能简单地使用比较运算符“&#x3D;&#x3D;”，因为比较运算符比较的是两个字符串的地址是否相同。即使两个字符串的内容相同，两个对象的内存地址也是不同的，使用比较运算符仍然会返回 false。\n使用比较运算符比较两个字符串，实例代码如下：\nString tom &#x3D; new String(&quot;I am a student&quot;);\nString jerry &#x3D; new String(&quot;I am a student&quot;);\nboolean b &#x3D; (tom &#x3D;&#x3D; jerry);\n\n此时，布尔型变量b的值为false，因为字符串是对象，tom、jerry是引用。\n\n因此，要比较两个字符串内容是否相等，应使用equals()方法和\nequalsIgnoreCase()方法。\n（1） equals()方法如果两个字符串具有相同的字符和长度，则使用equals()方法进行比较时，返回true。\n语法如下\nstr.equals(String otherstr)\n\n其中，str、otherstr是要比较的两个字符串对象。\n（2） equalsIgnoreCase()方法使用equals()方法对字符串进行比较时是区分大小写的，而使用equalsIgnoreCase()方法是在忽略了大小写的情况下比较两个字符串是否相等，返回结果仍为boolean类型。\n语法如下\nstr.equalsIgnoreCase(String otherstr)\n\n其中，str、otherstr是要比较的两个字符串对象。\n\n\n\n按字典顺序比较两个字符串compareTo()方法为按字典顺序比较两个字符串，该比较基于字符串中各个字符的Unicode值，按字典顺序将此String对象表示的字符序列与参数字符串所表示的字符序列进行比较。\n如果按字典顺序此String对象位于参数字符串之前，则比较结果为一个负整数；如果按字典顺序此String对象位于参数字符串之后，则比较结果为一个正整数；如果这两个字符串相等，则结果为0。\n语法如下：\nstr.compareTo(String otherstr)\n\n其中，str、otherstr是要比较的两个字符串对象。\n\n\n\n\n\ncompareTo() 方法用于将 Number 对象与方法的参数进行比较。可用于比较 Byte, Long, Integer等。\n该方法用于两个相同数据类型的比较，两个不同类型的数据不能用此方法来比较。\n参数referenceName – 可以是一个 Byte, Double, Integer, Float, Long 或 Short 类型的参数。\n返回值\n如果指定的数与参数相等返回 0。\n如果指定的数小于参数返回 -1。\n如果指定的数大于参数返回 1。\n\n实例public class Test&#123;\n\tpublic static void main(String args[])&#123;\n\tInteger x &#x3D; 5;\n\tSystem.out.println(x.compareTo(3));\n\tSystem.out.println(x.compareTo(5));\n\tSystem.out.println(x.compareTo(8));\n\t&#125;\n&#125;\n\n编译以上程序，输出结果为：\n1\n0\n-1\n\n字母大小写转换字符串的toLowerCase()方法可将字符串中的所有字符从大写字母改写为小写字母，而toUpperCase()方法可将字符串中的小写字母改写为大写字母。\n（1） toLowerCase()方法该方法将String转换为小写。如果字符串中没有应该被转换的字符，则将原字符串返回；否则将返回一个新的字符串，将原字符串中每个该进行小写转换的字符都转换成等价的小写字符。字符长度与原字符长度相同。\nstr.toLowerCase()\n\n其中，str是要进行转换的字符串。\n返回值转换为小写的字符串。\n实例public class Test &#123;\n    public static void main(String args[]) &#123;\n        String Str &#x3D; new String(&quot;WWW.I-NMB.COM&quot;);\n        System.out.print(&quot;返回值 :&quot; );\n        System.out.println( Str.toLowerCase() );\n    &#125;\n&#125;\n\n以上程序执行结果为：\n返回值 :www.i-nmb.com\n\n（2） toUpperCase()方法该方法将String转换为大写。如果字符串中没有应该被转换的字符，则将原字符串返回；否则返回一个新字符串，将原字符串中每个该进行大写转换的字符都转换成等价的大写字符。新字符长度与原字符长度相同。\nstr.toUpperCase()\n\n\n\n\n\n\n\n\n\n\n使用toLowerCase()方法和toUpperCase()方法进行大小写转换时， 数字或非字符不受影响\n返回值字符转换为大写后的字符串。\n实例public class Test &#123;\n    public static void main(String args[]) &#123;\n        String Str &#x3D; new String(&quot;www.i-nmb.com&quot;);\n        System.out.print(&quot;返回值 :&quot; );\n        System.out.println( Str.toUpperCase() );\n    &#125;\n&#125;\n\n以上程序执行结果为：\n返回值 :WWW.I-NMB.COM\n\n\n\n字符串分割使用split()方法可以使字符串按指定的分割字符或字符串对内容进行分割，并将分割后的结果存放在字符串数组中。split()方法提供了以下两种字符串分割形式。\n（1） split(String sign)该方法可根据给定的分割符对字符串进行拆分。\n语法str.split(String sign)\n\nsign为分割字符串的分割符，也可以使用正则表达式\n\n\n\n\n\n\n\n\n\n没有统一的对字符进行分割的符号。如果想定义多个分割符，可使用符号“|”。例如，“,|&#x3D;”表示分割符分别为“,”和“&#x3D;”。\n（2） split(String sign,int limit)该方法可根据给定的分割符对字符串进行拆分，并限定拆分的次数。\n语法str.split(String sign,int limit)\n\nsign：分割字符串的分割符，也可以使用正则表达式\nlimit：限制的分割次数\n例 1使用 split() 方法对字符串进行分割的实例如下：\npublic static void main(String[] args)\n&#123;\n    String Colors&#x3D;&quot;Red,Black,White,Yellow,Blue&quot;;\n    String[] arr1&#x3D;Colors.split(&quot;,&quot;);    &#x2F;&#x2F;不限制元素个数\n    String[] arr2&#x3D;Colors.split(&quot;,&quot;,3);    &#x2F;&#x2F;限制元素个数为3\n    System.out.println(&quot;所有颜色为：&quot;);\n    for(int i&#x3D;0;i&lt;arr1.length;i++)\n    &#123;\n        System.out.println(arr1[i]);\n    &#125;\n    System.out.println(&quot;前三个颜色为：&quot;);\n    for(int j&#x3D;0;j&lt;arr2.length;j++)\n    &#123;\n        System.out.println(arr2[j]);\n    &#125;\n&#125;\n\n输出结果如下：\n所有颜色为：\nRed\nBlack\nWhite\nYellow\nBlue\n前三个颜色为：\nRed\nBlack\nWhite,Yellow,Blue\n\n格式化字符串String类的静态format()方法用于创建格式化的字符串。format()方法有两种重载形式。\n（1） format(String format,Object…args)该方法使用指定的格式字符串和参数返回一个格式化字符串，格式化后的新字符串使用本地默认的语言环境。\n语法str.format(String format,Object…args)\n\nformat：格式字符串\nargs：格式字符串中由格式说明符引用的参数。如果还有格式说明符以外的参数，则忽略这些额外的参数。此参数的数目是可变的，可以为0\n（2） format(Local l,String format,Object…args)l ：格式化过程中要应用的语言环境。如果l为null，则不进行本地化。\n日期和时间字符串格式化在应用程序设计中，经常需要显示时间和日期。如果想输出满意的日期和时间格式，一般需要编写大量的代码经过各种算法才能实现。format()方法通过给定的特殊转换符作为参数来实现对日期和时间的格式化。\n1. 日期格式化\n\n上述代码中变量s的值是当前日期中的天数，如今天是15号，则s的值为15；%te是转换符。常用的日期格式化转换符如表\n\n\n\n2. 时间格式化使用format()方法不仅可以完成日期的格式化，也可以实现时间的格式化。时间格式化转换符要比日期转换符更多、更精确，它可以将时间格式化为时、分、秒、毫秒。\n常规类型格式化常规类型的格式化可应用于任何参数类型，可通过如表5.4所示的转换符来实现。\n\n\n\n\n使用正则表达式正则表达式通常被用于判断语句中，用来检查某一字符串是否满足某一格式。正则表达式是含有一些具有特殊意义字符的字符串，这些特殊字符称为正则表达式的元字符。例如，“\\d”表示数字0~9中的任何一个，“\\d”就是元字符。\n\n","slug":"character-string","date":"2022-04-23T15:44:03.000Z","categories_index":"","tags_index":"Eclipse,Java","author_index":"ACbug"},{"id":"df5c047b2c921ac68be6d4ab3ee5a04d","title":"流程控制—JAVA语言基础","content":"通过阅读本章，您可以：\n\n\n\n\n\n\n\n\n\n理解Java语言中复合语句的使用方法\n掌握if条件语句的使用方法\n了解if语句与switch语句的区别\n掌握while循环语句的使用方法\n掌握do…while循环语句的使用方法\n了解while语句与do…while语句的区别\n掌握for语句的使用方法\n了解foreach语句的使用方法\n复合语句与C语言及其他语言相同，Java语言的复合语句是以整个块区为单位的语句，所以又称块语句。复合语句由开括号“{”开始，闭括号“}”结束。\n在前面的学习中已经接触到了这种复合语句，例如，在定义一个类或方法时，类体就是以“{ }”作为开始与结束的标记，方法体同样也是以“{ }”作为标记。\n在项目中创建类Compound，在主方法中定义复合语句块，其中包含另一复合语句块。\n\n运行结果\n\n在使用复合语句时要注意，复合语句为局部变量创建了一个作用 域，该作用域为程序的一部分，在该作用域中某个变量被创建并能够被使用。如果在某个变量的作用域外使用该变量，则会发生错误，例如，在本实例中，如果在复合语句外使用变量y、z、b将会出现错误，而变量x可在整个方法体中使用。\n条件语句条件语句可根据不同的条件执行不同的语句。条件语句包括if条件语句与switch多分支语句。\nif条件语句\n布尔表达式：必要参数，表示最后返回的结果必须是一个布尔值。它可以是一个单纯的布尔变量或常量，也可以是使用关系或布尔运算符的表达式。\n语句序列：可选参数。可以是一条或多条语句，当表达式的值为true时执行这些语句。若语句序列中仅有一条语句，则可以省略条件语句中的“{ }”。\n例4.2】语句序列中只有一条语句，实例代码如下：\n\n \n条件语句后的语句序列省略时，则可以保留外面的大括号，也可以省略大括号。然后在末尾添加“;”。如下所示的两种情况都是正确的。\n省略了if条件表达式中的语句序列，实例代码如下：\nboolean b &#x3D; false; if(b);\n\nboolean b &#x3D; false; if(b)&#123;&#125;\n\n在项目中创建类Getif，在主方法中定义整型变量。使用条件语句判断两个变量的大小来决定输出结果。\n\n\n运行结果\n\nif…else语句if…else语句是条件语句中最常用的一种形式，它会针对某种条件有选择地做出处理。通常表现为“如果满足某种条件，就进行某种处理，否则就进行另一种处理”。\nif(表达式)&#123;\n    若干语句\n&#125;\nelse&#123;\n    若干语句\n&#125;\n\nif后面“()”内的表达式的值必须是boolean型的\n如果表达式的值为true，则执行紧跟if语句的复合语句；如果表达式的值为false，则执行else后面的复合语句。\n&#x2F;&#x2F;if…else语句可以使用三元运算符进行简化。如下面的代码：\nif(a &gt; 0)\n    b &#x3D; a;\nelse\n    b &#x3D; -a;\n&#x2F;&#x2F;可以简写成：\nb &#x3D; a &gt; 0?a:-a;\n\nif…else if多分支语句\nswitch多分支语句在Java中，可以用switch语句将动作组织起来，以一个较简单明了的方式来实现“多选一”的选择。\n\nswitch语句中表达式的值必须是整型、字符型或字符串类型，常量值1~n必须也是整型、字符型或字符串类型。\nswitch语句首先计算表达式的值，如果表达式的值和某个case后面的常量值相同，则执行该case语句后的若干个语句直到遇到break语句为止。\n在项目中创建类GetSwitch，在主方法中应用switch语句将周一到周三的英文单词打印出来。\n\n结果如下\n\n循环语句循环语句就是在满足一定条件的情况下反复执行某一个操作。在Java中提供了3种常用的循环语句，分别是while循环语句、do…while循环语句和for循环语句\nwhile循环语句while语句也称条件判断语句，它的循环方式为利用一个条件来控制是否要继续反复执行这个语句。\n语法如下\n\n当条件表达式的返回值为真时，则执行“{}”中的语句，当执行完“{}”中的语句后，重新判断条件表达式的返回值，直到表达式返回的结果为假时，退出循环。\n\ndo…while循环语句\n先做do，后判断。也就是说，do…while循环语句中“{}”中的程序段至少要被执行一次。\ndo…while语句在结尾处多了一个分号（;）\nfor循环语句for语句\n表达式1为初始化变量，只执行一次；\n表达式2为循环条件，值为boolean型的表达式，boolean型值为false，则跳出循环\n表达式3为循环后操作表达式，每一次循环后都会执行一次\nforeach语句foreach语句是for语句的特殊简化版本，不能完全取代for语句，但任何foreach语句都可以改写为for语句版本。foreach语句在遍历数组等方面为程序员提供了很大的方便\n\n\noreach语句中的元素变量x，不必对其进行初始化。下面通过简单的例子来介绍foreach语句是如何遍历一维数组的。\n\n运行结果如图所示\n\n","slug":"Process-control","date":"2022-04-23T15:04:09.000Z","categories_index":"","tags_index":"Eclipse,Java","author_index":"ACbug"},{"id":"776335ad07aa1b3bbc04ba130dffe2bc","title":"JAVA语言基础","content":"通过阅读本篇，您可以：　了解Java主类结构\n　了解Java语言中的基本数据类型\n　理解Java语言中的常量与变量\n　掌握Java语言运算符的使用\n　理解Java语言数据类型的转换\n　了解Java语言中的代码注释与编码规范\nJava主类结构Java语言是面向对象的程序设计语言，Java程序的基本组成单元是类，类体中又包括属性与方法两部分。每一个应用程序都必须包含一个main()方法，含有main()方法的类称为主类。\n在Eclipse下依次创建项目item、包Number和类Frist。创建完成后，即可得到以下代码：\npackage Number;\n\npublic class Frist &#123;\n\n&#125;\n\n\n在类体中输入以下代码，实现在控制台上输出“你好Java”\npackage Number;\npublic class Frist &#123;\n\tstatic String s1 &#x3D;&quot;你好&quot;;\n\tpublic static void main(String[] args)&#123;\n\t\tString s2 &#x3D; &quot;Java&quot;;\n\t\tSystem.out.println(s1);\n\t\tSystem.out.println(s2);\n\t&#125;\n&#125;\n\n\n\n\n\n文件名必须和类名Frist同名，即Frist.java。还要注意大小写，Java 是区分大小写的。 \n包声明一个Java应用程序是由若干个类组成的,上述例子的包声明就是“package Number; ”，因为package就是包声明\n\n\n\n\n\n\n类声明通常将类的属性称为类的全局变量（成员变量），将方法中的属性称为局部变量。\n上例的s1为成员变量而s2属于局部变量，因为s1在类中声明并没有任何方法中，而s2在方法public static void main(String[] args)中\n编写主方法main()方法是类体中的主方法。该方法从“{”开始，至“}”结束。\n其中main()方法中的权限修饰符为public，静态修饰符为static、返回值修饰符为void。Java程序中的main()方法必须声明为public static void。\nmain()方法是程序开始执行的位置。\n导入API类库在Java语言中可以通过import关键字导入相关的类。在JDK的API中（应用程序接口）提供了如java.awt、java.io等130多个包。\n\n\n\n\n\n\n\n\n\n可以通过 JDK的API文档来查看这些类，其中主要包括类的继承结构、类的应用、成员变量表、构造方法表等，并对每个变量的使用目的作了详细的描述，API文档是程序开发人员不可或缺的工具。 \n基本数据类型在Java中有8种基本数据类型来存储数值、字符和布尔值\n\n\n\n\n整数类型整数类型用来存储整数数值，即没有小数部分的数值。可以是正数，也可以是负数。\n十进制：除了数字0，不能以0作为其他十进制数的开头\n八进制：八进制：如0123（转换成十进制数为83）、-0123（转换成十进制数为-83），八进制数必须以0开头。 \n十六进制十六进制：如0x25（转换成十进制数为37）、0Xb01e（转换成十进制数为45086）。十六进制以 0X或者0x 开头\n其中整数类型可分为byte、short、int和 long 4种类型，\n\n浮点类型浮点类型表示有小数部分的数字。Java语言中浮点类型分为单精度浮点类型（float）和双精度浮点类型（double）。\n\n在默认情况下，小数都被看作double型，若使用float型小数，则需要在小数后面添加F或f\n可以使用后缀d或D来明确表明这是一个double类型数据，不加d不会出错，但声明float型变量时如果不加f，系统会认为变量是double类型，从而出错。\nfloat f1 &#x3D; 13.23f;\ndouble d1 &#x3D; 4562.12d;\ndouble d2 &#x3D; 45678.1564;\n\n\n\n字符类型char型字符类型（char）用于存储单个字符，占用16位（两个字节）内存\nchar x &#x3D; &#39;a&#39;;\n&#x2F;&#x2F;char x &#x3D; 97;\n\n同C和C++语言一样，Java语言也可以把字符作为整数对待。由于 unicode编码采用无符号编码，可以存储65536个字符(0x0000~0xffff）\n转义字符\n\n\n\nchar c1 &#x3D; &#39;&#39;;\t\t\t\t&#x2F;&#x2F;将转义字符叶’赋值给变量c1\nchar char1 &#x3D; &#39;lu2605&#39;;\t\t&#x2F;&#x2F;将转义字符lu2605’赋值给变量char1\nSystem.out.println(c1);\t\t&#x2F;&#x2F;输出结果\\\nSystem.out.println(char1);\t&#x2F;&#x2F;输出结果★\n\n\n\n布尔类型布尔类型又称逻辑类型，通过关键字boolean来定义布尔类型变量， 只有true和false两个值别代表布尔逻辑中的“真”和“假”。\nboolean b;\t\t\t&#x2F;&#x2F;定义布尔型变量b\nboolean b1,b2;\t\t&#x2F;&#x2F;定义布尔型变量b1、b2\nboolean b &#x3D; true;\t&#x2F;&#x2F;定义布尔型变量b，并赋给初值true\n\n\n\n变量与常量标识符和关键字标识符标识符就好似一个名字来标识类名、变量名、方法名、数组名、文件名\nJava语言规定标识符由任意顺序的字母、下画线（_）、美元符号（$）和数字组成，并且第一个字符不能是数字。标识符不能是Java中的保留关键字。\n合法标识符：\nname\nuser_age\n$page\n\n\n\n非法标识符：\n4word\nString\nUser name\n\n\n\n\n\n\n\n\n\n\n\n\n在Java语言中标识符中的字母是严格区分大小写的，如good和Good 是不同的两个标识符。\nJava语言中的字母不仅包括通常的拉丁文字a、 b、c等，还包括汉字、日文以及其他许多语言中的文字。\n关键字关键字是Java语言中已经被赋予特定意义的一些单词\n\n声明变量定义变量就是要告诉编译器（compiler）这个变量的数据类型，这样，编译器就会分配对应的空间给它，并且让编译器知道他能存放的数据。\n在程序运行过程中，空间内的值是变化的，这个内存空间就称为变量。为了便于操作，给这个空间取个名字，称为变量名。变量的命名必须是合法的标识符。\n在声明变量时可以是没有赋值，也可以是直接赋给初值。\nint a;\t\t&#x2F;&#x2F;声明一个名称为a的 int 型变量\nchar b&#x3D;&#39;r&#39;\t&#x2F;&#x2F;声明一个名称叫b的 char型变量并且将字母&#39;r&#39;赋值给b\n\n对于变量的命名并不是随意的，应遵循以下几条规则： \n\n\n\n\n\n\n\n\n\n变量名必须是一个有效的标识符。\n变量名不可以使用Java中的关键字。\n变量名不能重复。\n应选择有意义的单词作为变量名。\n声明常量在程序运行过程中一直不会改变的量称为常量（constant），常量在整个程序中只能被赋值一次。\n在Java语言中声明一个常量，除了要指定数据类型外，还需要通过 final关键字进行限定。声明常量的标准语法如下：\nfinal 数据类型    常量名称[&#x3D;值]\n\n常量名通常使用大写字母，但这并不是必需的。大写字母表示常量，是为了清楚地表明正在使用常量。\nfinal double Pl&#x3D;3.1415926D;\t\t&#x2F;&#x2F;声明double 型常量PI并赋值\nfinal boolean BOOL &#x3D; true;\t\t&#x2F;&#x2F;声明boolean型常量BOOL并赋值\n\n当常量属于“成员变量”时，必须在定义时就设定它的初值，否则将会产生编译错误。\n\n\n\n\n变量的有效范围在程序中，一般会根据变量的“有效范围”将变量分为“成员变量”和“局部变量”。\n\n成员变量在类体中所定义的变量被称为成员变量，成员变量在整个类中都有效。类的成员变量又可分为两种，即静态变量和实例变量。\nclass var&#123;\n\tint x &#x3D; 45; \n\tstatic int y &#x3D; 90\n&#125;\n\n在上面的代码中：x为实例变量，y为静态变量（也称类变量）\n就是说，如果在成员变量的类型前面加上关键字static，这样的成员变量称为静态变量。静态变量的有效范围可以跨类，甚至可达到整个应用程序之内，还能直接以“类名.静态变量”的方式在其他类内使用。\n局部变量在类的方法体中定义的变量（方法内部定义，“{”与“}”之间的代码中声明的变量）称为局部变量。局部变量只在当前代码块中有效。在类的方法中声明的变量，包括方法的参数，都属于局部变量\n局部变量只在当前定义的方法内有效，不能用于类的其他方法中。\n局部变量可与成员变量的名字相同，此时成员变量将被隐藏，即这个（同名）成员变量在此方法中暂时失效。\npublic class Val&#123;\n    static int times &#x3D; 3;\n    public static void main(String[] args)&#123;\n        int times &#x3D; 4;\n        System.out.println(&quot;times的值为：&quot;+times);\n    &#125;\n&#125;\n\n\n\n运算符Java中提供了丰富的运算符，如赋值运算符、算术运算符、比较运算符等。\n赋值运算符赋值运算符以符号“&#x3D;”表示，它是一个二元运算符（对两个操作数作处理），其功能是将右方操作数所含的值赋给左方的操作数。\nint a &#x3D; 100;\n\n该表达式是将100赋值给变量a。左方的操作数必须是一个变量，而右边的操作数则可以是任何表达式，包括变量（如a、number）、常量（如123、’book’）、有效的表达式（如45*12）\nint a &#x3D; 10;\t&#x2F;&#x2F;声明int型变量a\nint b &#x3D; 5;\t&#x2F;&#x2F;声明int型变量b\nint c &#x3D; a+b;&#x2F;&#x2F;将变量a与b运算后的结果赋值给c\n\n遵循赋值运算符的运算规则，可知系统将先计算a+b的值，结果为15，然后将15赋值给变量c，因此c&#x3D;15。\n由于赋值运算符“&#x3D;”处理时会先取得右方表达式处理后的结果，因此一个表达式中若含有两个以上的“&#x3D;”运算符，会从最右方的“&#x3D;”开始处理。\npublic class Eval&#123;\n    public static void main(String[] args)&#123;\n        int a,b,c;\n        a &#x3D; 15;\n        c &#x3D; b &#x3D; a + 4;\n        System.out.println(&quot;c的值为：&quot; + c);\n        System.out.println(&quot;b的值为：&quot; + b);\n    &#125;\n&#125;\n\n运行结果\n\n\n\n\n\n\n\n\n\n\n\n在Java中可以把赋值运算符连在一起使用。如：\nx &#x3D; y &#x3D; z &#x3D; 5;\n在这个语句中，变量x、y、z都得到同样的值5。但在实际开发中不建议使用这种赋值语句。\n算术运算符Java中的算术运算符主要有+（加）、-（减）、*（乘）、&#x2F;（除）、%（求余），它们都是二元运算符。Java中算术运算符的功能及使用方式如表\n\n其中，“+”和“-”运算符还可以作为数据的正负符号，如+5、-7\n在项目中创建类Arith，在主方法中定义变量，使用算术运算符将变量的计算结果输出。\npublic class Arith &#123;\t\t\t\t\t\t\t\t&#x2F;&#x2F;创建类\npublic static void main(String[] args) &#123;\t\t\t&#x2F;&#x2F;主方法\n    float number1 &#x3D; 45.56f;\t\t\t\t\t\t\t&#x2F;&#x2F;声明float型变量并赋值\n    int number2 &#x3D; 152;\t\t\t\t\t\t\t\t&#x2F;&#x2F;声明int型变量并赋值\n    System.out.println(&quot;和为:&quot;+( number1 + number2));\t&#x2F;&#x2F;将变量相加之和输出\n    System.out.println(&quot;差为:&quot;+(number2 - number1));\t&#x2F;&#x2F;将变量相减之差输出\n    System.out.println(&quot;积为:&quot;+number1 * number2);\t&#x2F;&#x2F;将变量相乘的积输出\n    System.out.println(&quot;商为:&quot;+number1 &#x2F; number2);\t&#x2F;&#x2F;将变量相除的商输出\n&#125;\n&#125;\n\n运行结果\n\n\n自增和自减运算符操作元必须是一个整型或浮点型变量。自增、自减运算符的作用是使变量的值增1或减1。\n当运算符在前时，先进行运算，后操作。当运算符在后时，先操作，后进行运算。\n\n粗略地分析，++a与a++的作用都相当于a &#x3D; a+1。假设a &#x3D; 4，则：\n\n再看另一个语法，同样假设a &#x3D; 4，则：\n\n比较运算符比较运算符属于二元运算符，用于程序中的变量之间、变量和自变量之间以及其他类型的信息之间的比较。比较运算符的运算结果是boolean型。当运算符对应的关系成立时，运算结果为true，否则为 false。所有比较运算符通常作为判断的依据用在条件语句中。比较运算符共有6个，如表\n\n\n在项目中创建类Compare，在主方法中创建整型变量， 使用比较运算符对变量进行比较运算，并将运算后的结果输出。\npublic class Compare &#123;\t\t\t\t\t&#x2F;&#x2F;创建类\n\tpublic static void main(Stringargs)&#123;\n   \t int number1 &#x3D; 4;\t\t\t\t\t&#x2F;&#x2F;声明int型变量number1\n   \t int number2 &#x3D; 5;\t\t\t\t\t&#x2F;&#x2F;声明int型变量number2\n&#x2F;*依次将变量number1与变量number2的比较结果输出*&#x2F;\n        System.out.println(&quot;number1&gt;number的返回值为:&quot;+(number1 &gt; number2));\n\t\tSystem.out.println(&quot;number1&lt; number2返回值为:&quot;+(number1 &lt; number2));\n\t\tSystem.out.println(&quot;number1&#x3D;&#x3D;number2返回值为:&quot;+ (number1&#x3D;&#x3D; number2));\n\t\tSystem.out.println(&quot;number1!&#x3D;number2返回值为:&quot;+ (number1 !&#x3D; number2));\n\t\tSystem.out.println(&quot;number1&gt;&#x3D; number2返回值为:&quot;+(number1 &gt;&#x3D; number2));\n\t\tSystem.out.println(&quot;number1&lt;&#x3D;number2返回值为:&quot;+(number1 &lt;&#x3D; number2));\n\t&#125;\n&#125;\n\n\n逻辑运算符返回类型为布尔值的表达式，如比较运算符，可以被组合在一起构成一个更复杂的表达式。这是通过逻辑运算符来实现的。\n逻辑运算符表如下\n\n\n使用逻辑运算符进行逻辑运算表如下\n\n\n在项目中创建类Calculation，在主方法中创建整型变量，使用逻辑运算符对变量进行运算，并将运算结果输出。\n\n运行结果如图\n\n位运算符位运算符除“按位与”和“按位或”运算符外，其他只能用于处理整数的操作数。位运算是完全针对位方面的操作。整型数据在内存中以二进制的形式表示，如int型变量7的二进制表示是00000000 00000000 00000000 00000111。\n左边最高位是符号位，最高位是0表示正数，若为1则表示负数。负数采用补码表示，如-8的二进制表示为111111111 111111111 1111111 11111000。这样就可以对整型数据进行按位运算。\n“按位与”运算“按位与”运算的运算符为“&amp;”，为双目运算符。“按位与”运算的运算法则是：如果两个整型数据a、b对应位都是1，则结果位才是1，否则为0。如果两个操作数的精度不同，则结果的精度与精度高的操作数相同。\n“按位或”运算“按位或”运算的运算符为“|”，为双目运算符。“按位或”运算的运算法则是：如果两个操作数对应位都是0，则结果位才是0，否则为1。如果两个操作数的精度不同，则结果的精度与精度高的操作数相同\n\n\n“按位取反”运算“按位取反”运算也称“按位非”运算，运算符为“~”，为单目运算符。“按位取反”就是将操作数二进制中的1修改为0，0修改为1\n\n“按位异或”运算“按位异或”运算的运算符是“^”，为双目运算符。“按位异或”运算的运算法则是：当两个操作数的二进制表示相同（同时为0或同时为1） 时，结果为0，否则为1。若两个操作数的精度不同，则结果数的精度与精度高的操作数相同\n\n除了上述运算符之外，还可以对数据按二进制位进行移位操作。\nJava中的移位运算符有以下3种。\n1.&lt;&lt;：左移左移就是将运算符左边的操作数的二进制数据，按照运算符右边操作数指定的位数向左移动，\n2.&gt;&gt;：右移。右边移空的部分补0。右移则复杂一些。当使用“&gt;&gt;”符号时，如果最高位是0，右移空的位就填入0；如果最高位是1，右移空的位就填入1\n\n3.&gt;&gt;&gt;：无符号右移。\nJava还提供了无符号右移“&gt;&gt;&gt;”，无论最高位是0还是1，左侧被移空的高位都填入0。\n\n\n\n\n\n\n\n\n\n移位运算符适用的数据类型有byte、short、char、int和long。\n移位可以实现整数除以或乘以2n的效果。例如，y&lt;&lt;2与y*4的结果相同；y&gt;&gt;1的结果与y&#x2F;2的结果相同。总之，一个数左移n位，就是将这个数乘以2n；一个数右移n位，就是将这个数除以2n。\n三元运算符三元运算符的使用格式为：条件式?值1:值2\n三元运算符的运算规则为：若条件式的值为true，则整个表达式取值1，否则取值2。例如：\nboolean b &#x3D; 20&lt;45?true:false;\n\n如上例所示，表达式“20&lt;45”的运算结果返回真，那么boolean型变量b取值为true；相反，表达式“45&lt;20”返回为假，则boolean型变量b取值false。\n三元运算符等价于if…else语句。\n运算符优先级通常优先级由高到低的顺序依次是：\n增量和减量运算&gt;算术运算&gt;比较运算&gt;逻辑运算&gt;赋值运算\n如果两个运算有相同的优先级，那么左边的表达式要比右边的表达式先被处理。\n\n数据类型转换类型转换是将一个值从一种类型更改为另一种类型的过程。例如， 可以将String类型的数据“457”转换为数值型，也可以将任意类型的数据转换为String类型。\n如果从低精度数据类型向高精度数据类型转换，则永远不会溢出， 并且总是成功的；而把高精度数据类型向低精度数据类型转换时，则会有信息丢失，有可能失败。\n数据类型转换有两种方式，即隐式转换与显式转换。\n隐式类型转换从低级类型向高级类型的转换，系统将自动执行，程序员无须进行任何操作。这种类型的转换称为隐式转换\n这些类型按精度从低到高排列的顺序为byte &lt; short &lt; int &lt; long &lt; float &lt; double\n使用int型变量为float型变量赋值，此时int型变量将隐式转换成float型变量。\n\n此时执行输出语句，y的结果将是50.0\n\n\n显式类型转换当把高精度的变量的值赋给低精度的变量时，必须使用显式类型转换运算（又称强制类型转换）\n语法为：(类型名)要转换的值\n将不同的数据类型进行显式类型转换\n\n执行显式类型转换时，可能会导致精度损失。除boolean类型以外其他基本类型，都能以显式类型的方法实现转换。\n\n\n\n\n\n\n\n\n\n当把整数赋值给一个byte、short、int、long型变量时，不可以超出这些变量的取值范围，否则必须进行强制类型转换。例如：\nbyte b &#x3D; (byte)129;\n代码注释与编码规范在程序代码中适当地添加注释，可以提高程序的可读性和可维护性。好的编码规范可以使程序更易阅读和理解。\n代码注释通过在程序代码中添加注释可提高程序的可读性。\n注释中包含了程序的信息，可以帮助程序员更好地阅读和理解程序。\n在Java源程序文件的任意位置都可添加注释语句。注释中的文字Java编译器不进行编译， 所有代码中的注释文字对程序不产生任何影响。Java语言提供了3种添加注释的方法，分别为单行注释、多行注释和文档注释。\n单行注释“&#x2F;&#x2F;”为单行注释标记，从符号“&#x2F;&#x2F;”开始直到换行为止的所有内容均作为注释而被编译器忽略。\n语法如下：\n\n\n\n\n\n\n\n\n\n\n\n\n例如，以下代码为声明的int型变量添加注释：\n\n\n\n\n\n\n\n\n\n\n\n\n多行注释“&#x2F; * * &#x2F;”为多行注释标记，符号“&#x2F;* ”与“*&#x2F;”之间的所有内容均为注释内容。注释中的内容可以换行。\n语法如下：\n\n\n\n\n\n\n\n\n\n\n\n\n\n但在多行注释中不可以嵌套多行注释，以下代码为非法：\n\n文档注释“&#x2F;** * &#x2F;”为文档注释标记。符号“&#x2F;**”与“ *&#x2F;”之间的内容均为文档注释内容。当文档注释出现在声明（如类的声明、类的成员变量的声明、类的成员方法声明等）之前时，会被Javadoc文档工具读取作为Javadoc文档内容。文档注释的格式与多行注释的格式相同。对于初学者而言，文档注释并不是很重要，了解即可。\n编码规范在学习开发的过程中要养成良好的编码习惯，因为规范的代码格式会给程序的开发与日后的维护提供很大方便。\n每条语句要单独占一行，一条命令要以分号结束。在声明变量时，尽量使每个变量的声明单独占一行，即使是相同的数据类型也要将其放置在单独的一行上，这样有助于添加注释。对于局部变量应在声明的同时对其进行初始化。Java代码中，关键字与关键字间如果有多个空格，这些空格均被视作一个。由于程序的开发与维护不能是同一个人，所以应尽量使用简单的技术完成程序需要的功能。关键的方法要多加注释，这样有助于阅读者了解代码结构","slug":"JAVA-Foundation","date":"2022-04-23T06:12:34.000Z","categories_index":"","tags_index":"Eclipse,Java","author_index":"ACbug"},{"id":"ba921540c4d1816934a165cfaafbe5c3","title":"Hexo-NexT主题加速运行","content":"删繁就简去掉一些不必要的、花里胡哨的功能，这个可能要关掉pace、canvas_lines、tag-icon等，安心留田种地。\n使用CDN加载部分css、js当我使用FancyBox进行图片放大的时候，每次在F12中看到FancyBox的加载速度十分缓慢，因为他都要调用托管地方的文件，这时候可能需要引用外部响应速度（下载速度）比我们自己站点更好的，而jsdelivr就可以完美解决这一问题\n在Blog/themes/next/_config.yml中搜索jsdelivr，让这些外部资源加载使用jsDeliver\n\n\n\n插件介绍下列是对一些在_config.yml配置中提供CDN加载的插件介绍，如果你使用或者需要这些插件你可以直接把他前面的 # 删去即可使用，不必再将他下载到本地再上传并且不必让他在自己的站中缓慢加载、消耗流量。\nanime：anime.js 是一个简便的JS动画库，用法简单而且适用范围广，涵盖CSS，DOM，SVG还有JS的对象，各种带数值属性的东西都可以动起来。\n实际演示和代码，官网写得很详细清楚了\n官网：中文文档 | anime.js (animejs.cn)\nfontawesome：Font Awesome,一套绝佳的图标字体库和CSS框架\nMathJax：在页面有很多情况需要显示公式，但在单纯在页面显示是不能达到效果的，因此需要MathJax的编译。\nKaTeX通过KaTeX插件，您可以在网站上使用最快的TeX数学排版引擎\npjaxpjax是一个jQuery插件，它通过ajax和pushState技术提供了极速的（无刷新ajax加载）浏览体验，并且保持了真实的地址、网页标题，浏览器的后退（前进）按钮也可以正常使用。\npjax的工作原理是通过ajax从服务器端获取HTML，在页面中用获取到的HTML替换指定容器元素中的内容。然后使用pushState技术更新浏览器地址栏中的当前地址。\n以下两点原因决定了pjax会有更快的浏览体验：\n1.不存在页面资源（js&#x2F;css）的重复加载和应用；\n2.如果服务器端配置了pjax，它可以只渲染页面局部内容，从而避免服务器渲染完整布局的额外开销。\n建议开启pjax使用pjax 实现网站无刷新加载\n开启pjaxpjax的开启很简单，我们只需要用CDN加载pjax（去掉链接前面的#，并且在原pjax前加上#，如下图），然后在主题配置中找到pjax设置pjax: true。\n\n使用pjax，你甚至可以给Next主题添加全局播放翻页不间断的网易云音乐；\nFancyBox支持对放大的图片添加阴影效果，对于一组相关的图片添加导航操作按纽。\nMedium-zoom想为自己网站的文章图片添加缩放的效果,可以选择使用medium-zoom这个插件\nLazy LoadLazy Load延迟加载图像插件,直到用户滚动到它们才显示!\nlazyload 是网站常用的技术，通过按需加载，避免一次性加载过多内容导致的打开缓慢\nPangu对于强迫症来说，中英文混排时加上空格能很大程度改善阅读体验，但是有时候会不小心打漏部分空格，而 pangu 这个项目就可以帮你在展示时自动加上空格\nQuicklink可以在空闲时间预获取页面可视区域（以下简称视区）内的链接，加快后续加载速度。\nDisqusJSDisqusJS:使用DisqusAPI在中国大陆呈现Disqus评论\nValineValine - 一款快速、简洁且高效的无后端评论系统。\nGitalk Gitalk 是一个基于 GitHub Issue 和 Preact 开发的评论插件\nAlgolia SearchAlgolia 搜索插件，懂的都懂\nMermaid绘图插件–mermaid\nVelocityPace通过使用pace,我们可以展示网页进度条加载效果。\ncanvas_ribbon背景彩带动画\n","slug":"acceleration","date":"2022-04-21T09:55:36.000Z","categories_index":"","tags_index":"hexo,NexT","author_index":"ACbug"},{"id":"c738434b6ecd4da095a1bdb7c5e7b073","title":"2022年度SMUCTF的WP笔记","content":"福建三明学院信息工程学院网络攻防大赛（SMUCTF）是由共青团三明学院信息工程学院委员会主办、信息工程学院网络安全协会承办的一场关于网络安全技术练习的CTF夺旗赛。\n本篇文章将展示笔者对2022年度福建三明学院信息工程学院网络攻防大赛（SMUCTF）的部分解题笔记（个人理解）。能解出来的题目，手把手教程！\n》MISCSMUGIFQR\n\n点击下载附件得到一个gif，不同的图片查看器有不同的高度（判断应该是修改了高度）\n\n\n这个gif包含了多个二维码，每个二维码只停留不到1秒钟的时间。\nStegsolve是基于java编写（需要安装Java环境），它能够将掩藏在图形中的重要信息解析过来，它能读取图片中的链接、文本信息，软件操作相对简单。\n用Stegsolve打开解压得到的flag.gif\n接下来使用Stegsolve提供的“Frame Browser”，\n\n\n在Frame Browser中点击 &gt; 按钮，可以逐帧查看，用二维码扫描器逐一扫描二维码得到\nflag&#123;SMUQRs-Are-FUN!&#125;\n\n\n\n冰墩墩的汉信码\n\n点击下载附件得到一张冰墩墩的图片\n\n\n说是有汉信码，一定在图片上，同样使用Stegsolve，调整好窗口大小后直接按下菜单栏的 &gt; 键，在Red plane 0 的频道画面下出现汉信码\n\n\n\n\n\n\n\n\n\n\n\n汉信码是我国具有完全自主知识产权的特殊二维码汉信码具有知识产权免费、汉字编码能力强、抗污损、抗畸变、信息容量大等特点。\n要使用特定的手机APP：中国编码（Android点击下载）  才能扫描\n手机安装中国编码APP后扫描得到：\nDear SMUCTFers, congratulations on getting the flag：flag&#123;Have_YOu_ever_Heard_0f_HanXinMa&#125;\n\n得到flag{Have_YOu_ever_Heard_0f_HanXinMa}\nlistentomusic\n\n点击下载附件解压得到一个音频和另一个压缩包\n\n\npass.wav中是电话拨号音频，使用 在线电话拨号音频解密：Detect DTMF Tones (dialabc.com)，选择文件后进行解密得到\n1933056020\n\n\n\n带到加密包输入密码1933056020得到lsb-silenteye，\n\n\n根据提示使用SilentEye工具，将音频拖进SilentEye工具，点击Decode，在弹出窗口再次点击decode\n\n\n\n\n得到以下提示，下载得到SSTVflag，\n\n\n\n\n\n\n\n\n\n链接：https://pan.baidu.com/s/1Jsy4naAx3JvOaGWmKeKAfg \n提取码：1mci\n在网络上的教程大多对sstv的解法是使用kali的Qsstv，但是我的kali中的qsstv显示，这个音频不支持，所以我们使用另外的方法\n在手机上下载Robot36（Android点击下载）\n手机打开软件使用电脑播放音频得到\n\n\n图片中有\nflag&#123;D0_YOu_know_SMUmusic_ForWAVE&#125;\n\n\n\n\n\n\n\nHigh-level_SMUpdf\n点击这里下载附件，得到一个压缩包，其中flag.pdf为解密文件\n\n\n打开pass.pdf，发现改文件受到密码保护，不允许查看\n\n我们打开PDF Password Recovery（或者其他PDF密码解锁爆破工具），选择恢复用户密码使用枚举攻击\n\n使用1-8位密码字符数字组合\n\n得到pass密码，使用密码并且使用PDF编辑器打开pass.pdf文件\n\n在最后一栏有隐形的字，把他复制到记事本中，得到解压密码6ef23c0845c43d82e0614baeba084d11\n——&gt;password：6ef23c0845c43d82e0614baeba084d11\n打开flag文件后得到包含11张图片的PDF，使用winhex打开发现他拥有两个PDF的文件头，推断使用了wbStego4open把文件隐藏到PDF文件中\n\n\n我们使用wbStego4.3open.exe（百度上不好找这个工具，点击这里下载），第二步中选择Decode ，输入文件地址后，下一步中选择PDF\n\n\n直接下一步，不用输入，之后随便输入命名txt文件，然后点击继续，之后在工具的根目录下出现自己命名的txt文件\n——&gt;\n得到\nflag&#123;0urSMUPDF&#125;\n\n\n\n病毒文件恢复\n点击下载附件，解压得到一个勒索文件，一个加密文件\n\n由于，本人目前能力有限，毕竟专业领域有人做的比我们好，所以我们使用360勒索病毒解密：https://lesuobingdu.360.cn/\n选择在线解密，上传留言文件和加密文件，点击开始解密，稍等片刻后就可以下载到含有flag的源文件\n\nflag&#123;fngD_vwfW_JTqI_E4Kl&#125;\n\n\n\n\n\n》CRYPTOhex\n点击这里下载附件，解压得到mod.txt给了一串字符串解密得到答案;\n分析字符串可以得到是16进制，因为16进制的组成字母范围是 a-f\nd4e8e1f4a0f7e1f3a0e6e1f3f4a1a0d4e8e5a0e6ece1e7a0e9f3baa0fbb9e1e6b3e3b9e4b3b7b7e2b6b1e4b2b6b9e2b1b1b3b3b7e6b3b3b0e3b9b3b5e6fd\n\n\n把其转成ASC码即可,但是往往不是那么顺利,因为存在 ASC码超过最大值的问题,需要减128,再转ASC码;\n\n\n脚本：\ncipher &#x3D; &quot;d4e8e1f4a0f7e1f3a0e6e1f3f4a1a0d4e8e5a0e6ece1e7a0e9f3baa0fbb9e1e6b3e3b9e4b3b7b7e2b6b1e4b2b6b9e2b1b1b3b3b7e6b3b3b0e3b9b3b5e6fd&quot;\nprint(&#39;&#39;.join([chr(int(cipher[i:i + 2], 16) - 128) for i in range(0,len(cipher), 2)]))\n\n\n得到flag{9af3c9d377b61d269b11337f330c935f}\n》REVERSEwarmup\n点击这里下载附件包，得到某个文件，二话不说放进IDA，因为是64位文件，使用IDA64打开。\n\n找到main函数\n\nint __cdecl main(int argc, const char **argv, const char **envp)\n&#123;\n  char s2[8]; &#x2F;&#x2F; [rsp+0h] [rbp-40h]\n  char s1; &#x2F;&#x2F; [rsp+20h] [rbp-20h]\n\n  puts(&quot;plz input flag:&quot;);\n  strcpy(s2, &quot;Reverse_is_very_Fun-_-!&quot;);\n  __isoc99_scanf(&quot;%s&quot;, &amp;s1);\n  if ( !strcmp(&amp;s1, s2) )\n    puts(&quot;right!&quot;);\n  else\n    puts(&quot;wrong!&quot;);\n  return 0;\n&#125;\n\n这里将”Reverse_is_very_Fun-_-!”复制到数组s2中，并将s2和输入的s1进行对比，如果s1和s2相同则输出”right!”否则输出”wrong!”\n所以，flag就是Reverse_is_very_Fun-_-!\nflag&#123;Reverse_is_very_Fun-_-!&#125;\n\n\n\n\n\n附：信息工程学院网络攻防大赛初赛官方解题报告.pdf\n","slug":"SMUCTF","date":"2022-04-15T09:47:24.000Z","categories_index":"测试","tags_index":"CTF,WP","author_index":"ACbug"},{"id":"c213d50a4ba4928fca2cb4dfc93c01e7","title":"0基础学Java-使用Eclipse","content":"Eclipse是目前最流行的Java语言开发工具之一，它具有强大的代码辅助功能，可以帮助程序开发人员自动完成语法修正、补全文字、代码修正、API提示等编码工作，从而节省 大量的时间和精力。\n本篇将介绍如何使用 Eclipse完成HelloJava程序的编写和运行。\n创建Java项目在Eclipse中编写程序，必须先创建项目，然后单击“下一步”或“完成”按钮\n\n\n此时将弹出如下图所示的新建模块化声明文件对话框。模块化开发是JDK 9新增的特性，但模块化开发过于复杂，新建的模块化声明文件也会影响Java项目的运行，因此这里单击Don’t Create按钮。至此，已完成Java项目的新建操作。\n\n\n\n\n\n\n\n\n创建Java类文件创建Java类文件时，会自动打开Java编辑器。创建Java类文件可以 通过“新建Java类”向导来完成。\n在Eclipse菜单栏中选择“文件”&#x2F;“新建”&#x2F;“类”命令，将打开“新建Java类”向导对话框\n使用该向导对话框创建Java类的步骤如下：（1）在“源文件夹”文本框中输入项目源程序文件夹的位置。通常向导会自动填写该文本框，没有特殊情况，不需要修改。（2）在“包”文本框中输入类文件的包名，这里暂时默认为空，不输入任何信息，这样就会使用Java工程的默认包。（3）在“名称”文本框中输入新建类的名称，如HelloJava。（4）选中public static void main(String[] args)复选框，向导在创建类文件时，会自动为该类添加main()方法，使该类成为可以运行的主类。\n\n\n\n\n\n\n\n\n使用编辑器编写程序代码打开Java编辑器在使用向导创建Java类文件之后，会自动打开Java编辑器编辑新创建的Java类文件。除此之外，打开Java编辑器最常用的方法是在“包资源管理器”视图中双击Java源文件或在Java源文件处右击并在弹出的快捷菜单中选择“打开方式”&#x2F;“Java编辑器”命令。\n\nJava编辑器以不同的样式和颜色突出显示 Java语法。这些突出显示的语法包括以下几个方面：\n程序代码注释。 \n\nJavadoc注释。 \n\nJava关键字。\n\n编写Java代码Eclipse的强大之处还在于**编写Java程序代码时，可以使用Ctrl+Alt+&#x2F;快捷 键自动补全Java关键字**，创建HelloJava类之后，向导会自动构建HelloJava类结构的部分代码，并建立main()方法。\n\n\n\n\n\n\n\n\n\n技巧在Eclipse安装后，Java编辑器文本字体为Consolas 10。采用这个字 体时，中文显示比较小，不方便查看。这时，可以选择主菜单上的“窗 口”&#x2F;“首选项”命令，打开“首选项”对话框，在左侧的列表中选择“常 规”&#x2F;“外观”&#x2F;“颜色和字体”节点，在右侧选择Java&#x2F;“Java编辑器文本字 体”节点，并单击“编辑”按钮，在弹出的对话框中选择Courier New字 体，单击“确定”按钮，返回到“首选项”对话框中，单击“应用”按钮即 可。另外，“调试”&#x2F;“控制台字体”节点也需要进行以上修改。\n我们按照图片的代码进行模仿编写\n\n它包括private、static、String 3个关键字。这3个关键字在记事本程序中手动输入虽然不会花多长时间，但却无法避免出现输入错误的情况。\n如果是名称更长、更复杂的关键字，就更容易出现错误。而在Eclipse的Java编辑器 中，可以只输入关键字的部分字母，然后使用Ctrl+Alt+&#x2F;快捷键自动补全Java关键字，如图所示。（对于2021-12-R版本已失效）\n点击窗口&gt;首选项&gt;Java&gt;编辑器&gt;内容辅助，自动激活的自动激活触发器由“.”改为\n.abcdefghijklmnopqrstuvwxyz(\n\n\n\n\n\n使用System.out.println()方法输出文字信息到控制台，这是程序开发时最常使用的方法之一。\n\n\n运行Java程序HelloJava类包含main()方法，它是一个可以运行的主类。例如，在 Eclipse中运行HelloJava程序，可以在“包资源管理器”视图的HelloJava文件处右击，在弹出的菜单中选择“运行方式”&#x2F;“ Java应用程序”命令。程序运行\n\n\n\n\n程序调试读者在程序开发过程中会不断体会到程序调试的重要性。为验证 Java单元的运行状况，以往会在某个方法调用的开始和结束位置分别使用System.out.println()方法输出状态信息，并根据这些信息判断程序执行状况，但这种方法比较原始，而且经常导致程序代码混乱（导出的都是 System.out.println()方法）。\n使用Eclipse的Java调试器需要设置程序断点，然后使用单步调试分别执行程序代码的每一行。\n添加断点设置断点是程序调试中必不可少的手段，Java调试器每次遇到程序断点时都会将当前线程挂起，即**暂停当前程序的运行**。\n1）在Java编辑器中显示代码行号的位置双击添加或删除当前行的断点，\n\n2）或者在当前行号的位置右击，在弹出的快捷菜单中选择“切换断点”命令实现断点的添加与删除\n\n以调试方式运行Java程序要在Eclipse中调试HelloJava程序，可以在“包资源管理器”视图中 HelloJava文件处右击，在弹出的快捷菜单中选择“调试方式”&#x2F;“ Java应用程序 ” 命令。在代码设置了断点，调试器将在该断点处 挂起当前线程，使程序暂停\n程序执行到断点被暂停后，可以通过“调试”视图工具栏上的按钮执 行相应的调试操作，如运行、停止等。\n\n\n\n\n\n\n程序调试程序执行到断点被暂停后，可以通过“调试”视图工具栏上的按钮执 行相应的调试操作，如运行、停止等\n\n单步跳过在“调试”视图的工具栏中单击按钮或按F6键，将执行单步跳过操作，即运行单独的一行程序代码，但是**不进入调用方法的内部**，然后跳到下一个可执行点并暂挂线程。\n单步跳入在“调试”视图的工具栏中单击按钮或按F5键，**将跳入调用方法或对象的内部**，单步执行程序并暂挂线程。\n","slug":"Use-of-eclipse","date":"2022-04-10T06:58:37.000Z","categories_index":"","tags_index":"Eclipse,Java","author_index":"ACbug"},{"id":"7c06e2178707113aab4a2ef35f09117e","title":"Eclipse的安装","content":"​\t\t学习Java语言前，首先来介绍一款功能强大、使用简单、能够辅助程序设计的IDE（集成开发工具）。Eclipse是目前最流行的Java语言开发工具之一，它具有强大的代码辅助功能，可以帮助程序开发人员自动完成语法修正、补全文字、代码修正、API提示等编码工作，从而节省大量的时间和精力。\n下载Eclipse安装包​\t\t打开官网：http://www.eclipse.org/downloads/，点击Download Packages超链接\n\n\n\n\n点击Eclipse IDE for Java Developers进入Eclipse IDE for Java Developers下载页面\n\n\n\n\n为了与语言包的版本保持一致版本，我选择使用eclipse-java-2021-12-R版本。\n​\t\t在页面的右下角点击Eclipse 2021-12 (4.22)打开历史版本下载页面\n\n\n​\t\t根据自己的系统下载对应平台的安装包\n\n\n\n\n下载Eclipse中文语言包​\t\t点击进入语言包下载界面（2021-12-R）找到Language: Chinese (Simplified)&gt;BabelLanguagePack-eclipse-zh_4.22.0.v20211218020001.zip (83.85%)或者点击本文超链接下载\n\n\n\n\n\n\n\n\nEclipse安装​\t\t从网站中下载的Eclipse安装文件是一个压缩包，将其解压缩到指定 的文件夹，将下载完成的汉化包解压缩，解压后生成的eclipse文件夹下 有两个子文件夹：features文件夹和plugins文件夹。将这两个子文件夹覆 盖到Eclipse程序的根目录下\n\n\n​\t\t配置好Eclipse的多国语言包后，可以启动Eclipse了。在Eclipse的安 装文件夹中运行eclipse.exe文件，即开始启动Eclipse。在Eclipse的安 装文件夹中运行eclipse.exe文件，即开始启动Eclipse，将弹出“Eclipse启 动程序”对话框，该对话框用于设置Eclipse的工作空间（用于保存 Eclipse建立的程序项目和相关设置）。本书的开发环境统一设置工作空 间为Eclipse安装位置的workspace文件夹，在“Eclipse启动程序”对话框 的“工作空间”文本框中输入“.\\eclipse-workspace”，单击“启动”按钮，即 可启动Eclipse\n\n\nEclipse首次启动时，会显示Eclipse欢迎界面，如图所示。单 击“欢迎”界面标题上的×，即可关闭该界面。\n\n\n\n\n","slug":"Eclipse的构建","date":"2022-04-10T00:58:22.000Z","categories_index":"","tags_index":"Java","author_index":"ACbug"}]